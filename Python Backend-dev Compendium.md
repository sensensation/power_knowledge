# by cybersen 
>www.linkedin.com/in/rodkir/

# OOP + Agile
1 - ООП | SOLID | Apps Architecture Patterns SOA
	ООП:
		Объектно Ориентированное Программирование. Парадигма разработки программного обеспечения, согласно которой приложения состоят из объектов. Стиль написания кода.
		ООП задумывалось специально, чтобы человеку было удобнее читать и понимать код, так как считается, что люди воспринимают окружающий мир как множество взаимодействующих друг с другом объектов.
		\.
		**ООП не экономит время на стадии разработки, но экономит время на стадии поддержки.**
		\.
		<mark style="background: #BBFABBA6;">Плюсы ООП</mark>:
			- помогает избавиться от дублирования кода 
			- экономит время на стадии поддержки проекта
			- удобен в чтении и написании
			- код становится человечнее
		<mark style="background: #FF5582A6;">Минусы ООП</mark>:
			- Относительно низкое быстродействие программ, незначительный оверхед
			- Чрезмерно большое наследование может привести к перегрузке (замедлению)
			- Класс родитель и дочерний класс тесно связаны, что может привести к многократному переписыванию кода
		\.
		Принципы ООП 3+1:
			<mark style="background: #ADCCFFA6;">Инкапсуляция - это реализация взаимодействия методов и атрибутов внутри класса.</mark> Классы как капсулы, которые содержат в себе данные и методы. Идея инкапсуляции заключается в абстракции, в том, что, пользуясь классом, клиенту не нужно знать о внутреннем устройстве класса. Поэтому разделяют три уровня доступа к данным и методам класса: PUBLIC, PRIVATE, PROTECTED. 
			\.
			PRIVATE вызывается только внутри класса, PROTECTED внутри класса и наследников. PUBLIC доступен всем.
			\.
			<mark style="background: #ADCCFFA6;">Наследование - это получение дочерними классами методов и атрибутов родительского класса</mark>. Позволяет избавиться от дублирования кода, дает возможность гибкому программированию и возможности комбинировать методы родительских классов при множественном наследовании. 
			\.
			<mark style="background: #ADCCFFA6;">П</mark><mark style="background: #ADCCFFA6;">олиморфизм - способность системы использовать объекты с одинаковым интерфейсом без информации о типе объекта</mark>. 
			\.
			Различают два вида полиморфизма:
				<mark style="background: #CACFD9A6;">A</mark><mark style="background: #CACFD9A6;">d hoc</mark> - перегрузка функций. Для различных типов аргументов используется разный код функции. В Python такой полиморфизм не используется. Однако есть декоратор @override
				\.
				<mark style="background: #CACFD9A6;">П</mark><mark style="background: #CACFD9A6;">араметрический</mark> - возможность обрабатывать разные типы данных идентичным образом. Например класс, складывающий А и Б. При этом можно и строки складывать, и числа, хотя используется один интерфейс.
			\.
			<mark style="background: #ADCCFFA6;">А</mark><mark style="background: #ADCCFFA6;">бстракция - фокусирование только на важных деталях.</mark> Это когда мы сосредотачиваемся только на существенных для задачи деталях и игнорируем всё остальное
			\.
			Уровни абстракций - уровни, описывающие вовлеченность более простых уровней в работе более верхних. Компьютерное железо, Машинный код, Язык программирования, приложение.
	\.
	SOLID:
		Само по себе ООП не означает, что разработчик застрахован от возможности создания непонятного, тяжело поддерживаемого кода.
		Акроним SOLID, предложенный Робертом Мартином, включает пять принципов программирования, призванных помогать разрабатывать устойчивые, масштабируемые ООП-приложения. SOLID переводится с английского языка как крепкий, устойчивый.
		\.
		SRP - Single Responsobility Principle (Принцип единой ответственности)
			Означает, что никогда не должно быть более одной причины для изменения класса. <mark style="background: #ADCCFFA6;">Каждый</mark><mark style="background: #ADCCFFA6;"> класс должен обладать только 1 осью изменения.</mark> 
			\.
			<mark style="background: #FFB86CA6;">Ч</mark><mark style="background: #FFB86CA6;">ем больше у класса ответственности, тем выше шанс, что он изменится. </mark><mark style="background: #FFB86CA6;">А многочисленные изменения приводят к высокой вероятности появления ошибки.</mark>
			\.
			Необходимо добиваться HIGH COHESION (высокая связность), то есть стремиться к сбору одинаковых обязанностей вместе. Разделяя разные оси задач мы добиваемся LOW CUPLING (низкая связанность).
			\.
			LOW CUPLING, HIGH COHESION - это GRASP паттерны.
			**GRASP** (General Responsibility Assignment Software Patterns) — 9 шаблонов проектирования, используемых для решения общих задач по назначению обязанностей классам и объектам.
			\.
			Например: класс, который имеет 2 метода: 1(форматирует данные и 2(записывает данные в файл) стоит разбить на 2 класса с 1 методом
			\.
			<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;">ывод: каждый класс должен иметь только одну причину для изменения</mark>
			\.
		OCP - Open Closed Principle (Принцип открытости закрытости)
			Если у нас есть уже какой-то класс с каким-то функционалом, и мы хотим что-то изменить, добавить возможности классу, то вместо того, чтобы делать изменение старого кода, лучше будет расширить основной класс путём наследования или добавления нового функционала. И такое добавление кода будет соответствовать ожиданиям пользователя.
			\.
			<mark style="background: #FFB86CA6;">П</mark><mark style="background: #FFB86CA6;">ри изменении старого, протестированного кода, мы можем сломать функционал, обнулить предыдущую тестировку кода.</mark> Важное замечание: изменять старые баги в коде соответсвует данному принципу.
			\.
			<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;">ывод: программные сущности должны быть закрыты для изменения, но открыты для модификации</mark>
			\.
		LSP - Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
			Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Все классы должны быть еднообразны.
			\.
			Пример: есть класс MergeTables. От него наследуемся. Создаем дочерний класс MySQL ( MergeTables ). И если мы теперь создадим еще один дочерний класс MongoDB ( MergeTables ), то что мы будем присоединять? Таблиц же нет. Это прямое нарушение LSP. 
			Правильнее было бы сделать так: Разбить базовый класс на NOSQL и SQL классы. А уже потом наследоваться от них.
			\.
			<mark style="background: #FFB86CA6;">Е</mark><mark style="background: #FFB86CA6;">сли оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.</mark>
			\.
			<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;"></mark><mark style="background: #ADCCFFA6;">ывод: Базовые классы в программе должны быть заменяемы на их дочерние классы без изменения правильности выполнения программы</mark>
			\.
		ISP - Interface Segregation Principle (Принцип Разделения интерфейса)
			Программные сущности не должны зависеть от принципов, которые они не используют. 
			\.
			Пример: Если у нас есть класс PRINTER, например с методами факса и печати, и мы наследуемся от него в классе OLD PRINTER, который использует только функицонал печати (несмотря на это мы можем использовать также метод и факса, тк они есть в родительком классе, хотя факс в OLD PRINTER должен быть недоступен), то нам основной класс нужно разделить на интерфейсы(классы) и наследоваться уже от нужных нам интерфейсов, чтобы у нас были только нужные методы и никаких лишних. 
			\.
			<mark style="background: #FFB86CA6;">Е</mark><mark style="background: #FFB86CA6;">сли нарушить данный принцип, то у нас будет много дочерних классов, которые не используют лишние для них методы родительского класса. Это приводит к багам и плохой читаемости.</mark>
			\.
			<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;">ывод: Много интерфейсов, специально предназначенных для клиентов лучше чем один интерфейс общего назначения.</mark>
			\.
		DIP - Dependency Inversion Principle (Принцип инверсии зависимостей)
			Служит для создания слабосвязанных сущностей, которые легко тестировать, модифицировать и обновлять. Подходит для комплируемых языков больше, чем для интерпретируемых.
			\.
			Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Главное - это идея (Абстракция).
			\.
			<mark style="background: #FFB86CA6;">Е</mark><mark style="background: #FFB86CA6;">сли нарушить данный принцип, то, грубо говоря, из-за какой-то мелочи, например неправильно работающего класса, пришлось бы переписывать всю программу. </mark>
			\.
			<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;">ывод: Нет зависимости на детали (реализацию), опираемся только на абстракцию</mark>
	\. 
	Другие принципы программирования:
		\.
		DRY - Don’t Repeat Yourself - <mark style="background: #ADCCFFA6;">не дублировать код</mark>
		\.
		YAGNI - You Aren’t Gonna Need It - <mark style="background: #ADCCFFA6;">не писать лишнего, удалять неиспользуемый код</mark>
		\.
		KISS - Keep It Simple, Stupid - <mark style="background: #ADCCFFA6;">не усложнять, не придумывайть к задаче более сложного решения, чем ей требуется.</mark>
		\.
		BDUF - Big Design Up Front - <mark style="background: #ADCCFFA6;">Перед разработкой приложения, его сначала нужно спроектировать.</mark> Прежде чем переходить к реализации, убедиться, что все хорошо продумано.
		\.
		APO - Avoid Premature Optimization - <mark style="background: #ADCCFFA6;">Нужно избегать преждевременной оптимизации кода</mark> Не оптимизировать код до тех пор, пока не понадобится.
		\.
		Бритва Оккама - <mark style="background: #ADCCFFA6;">Нам не нужно делать чего-то без надобности, чтобы не увеличивать кодовую базу.</mark> 
	\.
	Архитектуры web приложений:
		Монолитная 
			Единый модуль(приложение), который работает автономно и независимо от других сервисов. Используется сервер для обработки бизнес логики, база данных может быть вынесена на отдельный сервер. Может использоваться балансировщик NGINX. Однако <mark style="background: #ADCCFFA6;">главная суть в том, что приложение изолированно от других сервисов.
			Используется в случае если приложение не будет высоконагруженным и не будет частых добавлений извне.</mark>
			\.
			Монолитная архитектура предполагает, что при обработке пользовательского запроса система прогоняет его по всем уровням.
			\.
			<mark style="background: #BBFABBA6;">Плюсы</mark>: 
			- Простая разработка
			- Простое развёртывание
			- Удобно проводить тесты
			- Удобная отладка
			- Дешево
			\.
			<mark style="background: #FF5582A6;">Минусы</mark>:
			- Сложно масштабировать
			- Надёжность. Если что-то где-то сломается, то сломается всё приложение
			- При небольшом изменении придётся разварачивать его полность заново 
			\.
		SOA - Service Oriented Architecture
			<mark style="background: #ADCCFFA6;">Сервис</mark><mark style="background: #ADCCFFA6;"> ориентированная архитектура - это модульный подход в архитектуре. </mark>Компоненты собираются отдельно. Тестируются отдельно. И в продакшане деплоятся отдельно. Появилась в 1980-х
			Такая архитектура распределенная.
			\.
			Отличия от микросервисной архитектуры:
				- в SOA компонентны устанавливаются внутрь Aplication Server, а в микросервсиной архитектуре компоненты обычно уже содержат Aplication Service внутри компонента 
				- в SOA достигается экономия ресурсов, так как http service один. В микросервисной архитектуре у каждого сервиса свой http сервис в каждом компоненте.
				- Микросервисы подразумевается переиспользовать
		\.
		ESB - Сервисная шина предприятия - <mark style="background: #CACFD9A6;">паттерн SOA</mark>
			ESB возникла во времена, когда в компаниях были отдельные приложения. Например, одно для работы с финансами, другое для учёта персонала, третье для управления складом, и т. д. Появилась в 1990-х
			\.
			Сервисная шина - посредник, преобразующий запросы клиента (сервера или модульного приложения) в общий формат, который умеет преобразовать под свои нужды каждый модуль.
			\.
			<mark style="background: #ADCCFFA6;">Всё</mark><mark style="background: #ADCCFFA6;"> взаимодействие идёт через сервисную шину, так что если она падает, то с ней падают и все остальные системы. То есть ESB — ключевой посредник, очень сложный компонент системы.</mark>
			\.
			<mark style="background: #BBFABBA6;">Плюсы</mark>: 
			 - Независимость набора технологий
			 - Оптимизированный обмен сообщениями
			 - Асинхронность обмена сообщениями
			 - Простота подключения и отключения сервисов от сервисной шины
			<mark style="background: #FF5582A6;">Минусы</mark>:
			 - Единая точка отказа, слишком ответственная сервисная шина
			 - Высокая зависимость сервисов от шины
			 - Шина так сложна, что для управления ею потребуется целая команда
		\.
		Микросервисная - <mark style="background: #CACFD9A6;">паттерн SOA</mark>
			<mark style="background: #ADCCFFA6;">Назначение</mark><mark style="background: #ADCCFFA6;"> такое же как и в ESB: создать единое общее корпоративное приложение из нескольких специализированных приложений бизнес-доменов.</mark>
			\.
			В микросервисной архитектуре слабо связанные сервисы взаимодействуют друг с другом для выполнения задач, относящихся к их бизнес-возможностям.
			\.
			приложение, состоящее не только из серверов обрабатывабщих логику, работающих асинхронно, но также и из независимых, отдельных приложений, которые имеют собственную бизнес-логику и БД, например сервисы отправки почты или социальные сети.
			Обновление, тестирование и развёртывание выполняется для каждой службы отдельно.
			\.
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
			- Надёжность. если ломается что-то одно, то не ломаются остальные. Ломается только какой-то scope приложения, который потом еще нужно найти.
			- Гибкость технологий
			- Бизнес-логика хранится только в сервисах.
			- Оптимизированный обмен сообщениями.
			<mark style="background: #FF5582A6;">Минусы</mark>:
			- Нужно много вложить в сильную DevOps-культуру.
			- Сложность тестирования. Потому что изменения в интерфейсе могут непредсказуемо влиять на другие сервисы.
			- Финансово затратно
			- Сложнее мониторинг
			- <mark style="background: #FF5582A6;">Антипатерн Равиоли</mark>: _Архитектурой равиоли_ обычно называют антипаттерн микросервисной архитектуры.<mark style="background: #FFB86CA6;"> Равиоли получаются, если микросервисов слишком много, они слишком мелкие и не отражают доменных концепций.</mark>
		\.
		Event Driven Architecture (EDA) - Событийная архитектура:
			<mark style="background: #ADCCFFA6;">Это</mark><mark style="background: #ADCCFFA6;"> распределенная асинхронная архитектура для приложений, состоящая из одноцелевых компонентов, выполняющих получаемые запросы из очереди асинхронно.</mark>
			\.
			Приложение реагирует на изменение в различных источниках.
			Т.е. пользователь производит какие-то изменения, по каналам они посылаются в маршрутизатор событий, который, в зависимости, от этого изменения посылает по каналам его в event consumer.
			\.
			- Событие - действие, инициирубщие изменение в состоянии приложения
			- Маршрутизатор - брокер
			- Брокер - это приложение, действующее в качестве посредника между генератором события и потребителем события.
			\.
			Таким образом, приложения удается аккуратно открепить друг от друга, позаботившись о проблеме **доступности**. Если именно в данный момент приложение недоступно, то, вернувшись в онлайн, оно начнет потреблять события и обрабатывать их, наверстав все те события, которые успели произойти за период, пока оно оставалось недоступным.
			\.
			Эта архитектура включает в себя 5 ключевых компонентов: 
				- Продюсер(пользователь) - тот, кто создаёт событие
				- Начальное событие - событие пользователя
				- Маршрутизатор - определяет куда отправлять обработанное событие
				- Обработанное событие - его передаёт маршрутизатор consumer'у
				- consumer - бизнес-логика приложений, которая выполняет событие
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
				- Масштабирование
				- Производительность
				- Модифицируемость
			<mark style="background: #FF5582A6;">Минусы</mark>:
				- Сложно тестировать
				- Сложно разработать
			Клиент- брокер- сервис
			+логирование
			\.
			Популярные брокеры, реализующие очередь - <mark style="background: #CACFD9A6;">Redis</mark>, Kafka, RabbitMQ
			\. 
			Для создания очереди в Django используется таск-менеджер Celery.
			Для обработки очередей желательно нужны отдельные сервера для решения асинхронных задач.
			\.
			Полнотекстовый поиск реализуется на Sphinx, Luecene для высвобождение ресурсов базы данных. Полнотекстовый поиск может быть и отдельным сервисом.
			\.
			Для обработки потоковых данных используется Apache Kafka. Для записи потоковых данных в отдельную БД используется Hadoop.
		\

2 - Методологии разработки ПО | Design Patterns
	Методологии разработки ПО
		TDD - test driven development
			<mark style="background: #ADCCFFA6;">Т</mark><mark style="background: #ADCCFFA6;">ехника разработки ПО, которая основывается на повторении коротких циклов разработки:</mark>
			- Пишем тест
			- Бизнес-логику которую проверяем этим тестом
			- Написание кода, рефакторинг и прогоняем через тест
			\.
			Основная идея: пишется тест, потом его запускают. Он фейлится, так как еще нет кода тестируемого. А уже потом под этот тест пишется код до тех пор, пока не перестанет фейлится. 
			\.
			<mark style="background: #ADCCFFA6;">T</mark><mark style="background: #ADCCFFA6;">DD больше для разработчиков, про unit тестирование. Остальные члены команды могут просто невдуплять, что происходит.</mark>
			\.
			<mark style="background: #BBFABBA6;">П</mark><mark style="background: #BBFABBA6;">люсы</mark>:
			- Весь функционал протестирован
			- Ускорение процесса разработки за счет уменьшения возникновения ошибок в несколько раз
		\.
		BDD - behaviour driven development 
			Данный метод придумал Dan North. 
			\.
			Какую задачу должен решать BDD? 
			<mark style="background: #ADCCFFA6;">О</mark><mark style="background: #ADCCFFA6;">стальные участники команды должны понимать, что происходит, какой функционал покрыт тестами и на каком этапе сейчас разработка. Позволяет всем участникам разработки говорить на одном языке.</mark>
			\.
			Похоже на TDD, но основана не на тестах, которые пишут сами программисты, а на описании тестировщиком или аналитиком поведения(пользовательских сценариев). 
			Перевод на естественных язык программного кода. Сценарии дает представитель заказчика. 
			\.
			Тесты сценариев пишут в определённом формате, где есть:
			- контекст
			- событие
			- результат
			\.
			Заказчик: хочу чтобы банкомат работал, выдавал или принимал деньги, показывал баланс.
			Тогда, используя метод BDD, мы можем создать, например, такой сценарий:
			\.
			-Сценарий 1: на счету есть деньги-
			ИМЕЯ счет с деньгами
			И валидную карточку
			И банкомат с наличными
			КОГДА клиент запрашивает наличные
			ТОГДА убидеться, что со счета было списание
			И убедиться, что наличные выданы
			И убедиться, что карточка возвращена
			\.
			<mark style="background: #BBFABBA6;">П</mark><mark style="background: #BBFABBA6;">люсы</mark>:
			- Тесты может читать кто угодно
			- Их легко менять, так как пишутся почти на чистом английском
			- Не зависят от языка программирования
			\.
			<mark style="background: #FF5582A6;">М</mark><mark style="background: #FF5582A6;">инусы</mark>:
			- Кожет возникнуть дублирование кода
			- Каждый специалист пишет тесты как ему вздумается WHEN, WAS. Сильно плавает контекст
		\.
		DDD - domain driven development
			Данный метод придумал Эрик Эванс.
			\.
			 Набор правил, которые помогают постоить правильное проектное решение,
			 помогает быстро найти решение проектирования ПО в незнакомой предметной области. Методолгия нужна для того чтобы ознакомить разработчиков с бизнесом, так как разработчики не всегда понимают как должно что-то реализовываться. 
			 \.
			 Главная суть: <mark style="background: #ADCCFFA6;">когда разработчик что-то начинает воплощать в жизнь, он думает своими терминами, он думает про код. А заказчик думает про бизнес. И так получается, что происходит некоторый ментальный разрыв между заказчиком и исполнителем. И в какой-то момент исполнитель просто перестает понимать, что от него просят. </mark>
			 \.
			 ("платформа десктруктивных испытаний", напрмиер, нихера не понятно, для этого нужны термины то есть разработка по DDD).
			 \.
			 Подходит в тех ситуациях, когда разработчик не является специалистом в определённой предметной области
			 Основная цель этой методологии — борьба со сложностью бизнес процессов, их автоматизация и реализация в коде
			 В DDD используют :
			 - единый язык для общения в рамках проекта. Этим языком может быть любой, т.к. в DDD язык не один единственный
			 - доменная модель - словарь терминов
			 \.
			 <mark style="background: #BBFABBA6;">П</mark><mark style="background: #BBFABBA6;">люсы:</mark> 
			 - Почти все участники проекта могут читать код
			 - Постановка задач более понятная 
			 - Тестировщику намного легче читать код и находить баги
			 \.
			 <mark style="background: #FF5582A6;">М</mark><mark style="background: #FF5582A6;">инусы:</mark>
			 - Требуется высокая квалификация работников, особенно на старте проекта
			 - Это дорого, не все клиенты готовы много потратить 
	\.
	Паттерны проектирования - 
		это шаблоны, реюзбл решение, для обыденных проблем. **Паттерны стали популярны из книги банды четырех.** Миксины - это пример паттернов проектирования.
		\.
		Есть 3 группы паттернов : 
			- <mark style="background: #FFB86CA6;">Порождающие</mark> - нужны для того, чтобы создать группу обьектов, которая потом может использоваться в других проектах
			- <mark style="background: #FFB8EBA6;">Структурные</mark> - нужны для того, чтобы мы могли обьеденить структуры для создания более сложного приложения
			- <mark style="background: #ABF7F7A6;">Поведенческие</mark>  упрощают взаимодействие между объектами 
			\.
		<mark style="background: #FFB86CA6;">Factory</mark> - Порождающий паттерн 
			Фабричный метод предоставляет общий интерфейс дочерним классам для создания экземпляров (объектов). <mark style="background: #ADCCFFA6;">Позволяет классу делегировать создание объектов подклассам.</mark>
			Отличие: абстрактная фабрика позволяет создавать интерфейсы на основе которых создаются группы объектов.
			\.
			?т.е. мы создаём абстракнтые классы, а в дочерних классах уже определяем экземпляр какого класса нам надо создать но не для обычной фабрики
			\.
			Когда применять?:
			- Когда хотим дать возможность расширять библиотеку в будущем.
			- Когда необходимо отделить код создания объектов от остального кода.
			\.
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
			- код создания обьектов более универсальный, нет привязок к классам
			<mark style="background: #FF5582A6;">Минусы</mark>:
			- нужно создавать класс наследник для каждого нового типа
		\.
		<mark style="background: #FFB86CA6;">Singleton</mark> - Порождающий паттерн 
			<mark style="background: #ADCCFFA6;">П</mark><mark style="background: #ADCCFFA6;">озволяет создать только один инстанс у класса и обеспечить к нему глобальную точку доступа.</mark> 
			\.
			Примеры использования:
				- Создание файловой системы
				- Создание дисплея
				- lazy loading (создать инстанс только когда инстанс еще не создан)
			\.
			Заключается в том, что у нас есть один (одиночный) глобальный экземпляр класса, через который мы получаем доступ ко всему приложению(это как точка входа),
			который должен быть доступен в любом месте программы. Нарушает SRP. 
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
			- единая точка входа
			- единственный экземпляр 
			- ускоряет начальный запуск программы
			- порядок в глобальном пространстве имён
			<mark style="background: #FF5582A6;">Минусы</mark>:
			- в некоторых случаях проект становится немаштабируемым
			\.
			Код SINGLETON
				**class Character:
					_instance = None
					def __new__(cls):
						if not cls._instance:
							cls._instance = super().__new__(cls)
						return cls._instance
					def __init__(self):
						self.race = 'Elf'**_
		\.
		<mark style="background: #FFB8EBA6;">Adapter</mark> - Структурный паттерн
			<mark style="background: #ADCCFFA6;">Э</mark><mark style="background: #ADCCFFA6;">то обертка-переводчик, которая трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.</mark>
			\.
			Бывает двух видов:
			- Object Adapter (экземпляр класса)
			- Class Adapter 
			\.
			помогает объектам с несовместимыми интерфейсами работать вместе
			из этого вытекает минус - усложняем код из-за добавления дополнительных классов. 
			Его использует когда:
				- У нас уже есть конкретный класс и нужно, чтобы этот класс реализовывал определенный интерфейс, при этом сам класс менять нельзя.
				- Когда необходимо использовать уже существующие производные классы, в которых отсутствует некоторая общая функциональность, которую нельзя реализовать путем расширения их базового класса.
			Пример использования:
				Создем приложение для торговли на бирже. Приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики.
		\.
		<mark style="background: #FFB8EBA6;">Decorator</mark> - Структурный паттерн
			<mark style="background: #ADCCFFA6;">П</mark><mark style="background: #ADCCFFA6;">озволяет динамически подключать различные поведения к объекту.</mark>
			Т.е. мы создаём подклассы чтобы расширить функционал.
			Его использует когда:
				- Когда имеется необходимость динамически и незаметно для клиенсткого кода добавлять обязанности существующим объектам
				- Если нет возможности использовать наследование для расширения функциональности объекта
				- Когда обязанности, накладываемые на объект, могут быть с него сняты
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
				- Позволяет динамически добавлять как одну, так и несколько обязанностей объекту
				- Предоставляет больше гибкости в отличие от наследования
			<mark style="background: #FF5582A6;">Минусы</mark>:
				- Разрастается кодовая база проекта из-за наличия большого числа маленьких классов
		\.
		<mark style="background: #FFB8EBA6;">Facade</mark> - Структурный паттерн
			<mark style="background: #ADCCFFA6;">З</mark><mark style="background: #ADCCFFA6;">аключается в том, что все клиентские запросы мы направляем к одному объекту - экзмепляру класса Facade, который затем решает, в какой конкретно объект программы этот запрос направить.</mark>
			Его использует когда:
				- Когда необходимо предоставить простой или урезанный интерфейс к сложной подсистеме
				- Когда необходимо ращложить подсистему на отедльные слои
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
				- Позволяет изолировать клиентов от компонентов подсистемы
				- Ослабляет связность COHESION (зависимость)
			<mark style="background: #FF5582A6;">Минусы</mark>:
				- Фасад может разрастись до АНТИ-ПАТТЕРНА GOD OBJECT
		\.
		<mark style="background: #ABF7F7A6;">Observer</mark> - Поведенческий паттерн
			Один из наиболее распространенных шаблонов. Играет ключевую роль в паттерне MVC. 
			\.
			Главная суть: <mark style="background: #ADCCFFA6;">позволяет какому-то куску кода анонсировать любые изменения в его состоянии без какого-либо волнения о том, кто именно получит эту информацию.</mark> Например AJAX работает по принципу Observer
			\.
			Когда объект может наблюдать за всем, что происходит в другом объекте.
			Например, система наблюдения за ценой товара. Это объект, который видит изменения в другом объекте. 
			Его использует когда:
				- Когда необходимо при модификации одного объекта произвести изменения в других объектах и нет понимания о каком количестве изменяемых объектов идет речь
				- Когда необходимо в определнных случаях наблюдать за изменениями ряда объектов в разрабатываемой системе
				- Если у приложения есть хотя бы один объект, который рассылает сообщения
				- И есть не меньше одного получателя этих сообщений 
			<mark style="background: #BBFABBA6;">Плюсы</mark>:
				- Позволяет одним объектам быстро подписываться и отписываться от событий другого объекта
				- Объекты, выступающие в качестве подписчиков, не зависят от генераторов событий
			<mark style="background: #FF5582A6;">Минусы</mark>:
				- Оповещение объектов производится в случайном порядке
		\.
		<mark style="background: #ABF7F7A6;">Command</mark> - Поведенческий паттерн
			Оборачивает функцию в обертку и позволяет работать с ней как с объектом. Похоже на замыкание, callbacks. Это объектно-ориентированная замена callbacks.
		\.
	?отличие фабрики от абстрактной: фишка в том, что если взять абсркт фабрику мы можем создавать иерархию фабричных методов, семейство объектов. Абстрактная фабрика позволяет создавать объекты в стилях: например, обычная фабрика создает столы, стулья. Абстрактная мебель создает те же столы и стулья, но например в стиле модерн.
		 https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns

3 - Code standarts
		Pep8
		Название классов - CamelCase
		Название функций - function_name
	Запахи кода - говорят о том, что код пора улучшить
		Запахи в ООП:
			- Дублирование - это использование одинаковых структур кода в нескольких местах
			- Длинный метод - Среди объектных программ дольше всего живут программы с короткими методами
			- Большой класс - GOD OBJECT
			- Много параметров функции - если функция принимает слишком много параметров
			- Отказ от наследства - если наследник использует лишь малую часть унаследованных методов и свойств родителя, это является признаком неправильной иерархии.
			- Расходятся модификации - когда мы хотим что-то изменить что-то в каком то месте, но чтобы это сделать придётся менять это во многих местах
			- Посредник - чрезмерное использование делегирования может привести к появлению классов, у которых большинство методов состоит только из вызова метода другого класса
			- Часто комментарии играют роль «дезодоранта» кода, который появляется в нём лишь потому, что код плохой.
	Refactoring
		Это совершенствование своего написанного кода, стремление к чистому коду
		сюда <mark style="background: #FFF3A3A6;">НЕ</mark> относится:
			- улучшение функционала приложения
		Для чего нужен рефакторинг:
			- повышается читаемость кода за счёт его сокращения и(или) его реконструирования
			- избавление от дублирования кода
			- меньше от неиспользуемого кода 
			- после рефакторинга легче искать ошибки в коде, т.к. его колличество сокращается
			- подготовка функций к переиспользованию
			- оптимизация
		Когда нужен рефакторинг:
			- В случае, если мы хоти что-то добавить, иногда это слишком сложно сделать, т.к. кода слишком много и нужно много времени, чтобы в нём разобраться
			- Если читать код становиться слишком сложно
		Методы рефакторинга: 
			- Фрагментация
				Разбиение больших сущностей на более мелкие, например, функции
			- Абстракция 
				Нужна при избавлении от дублирования кода. Создаётся абстрактный класс или класс высокого уровня в который выносят дублирующиеся методы
			- Red-Green-Refactor
				Выбираем кусок кода, пишем тест для него и начинаем переписывать его попутно тестируя, чтобы не сломать
	Code review
		<mark style="background: #ADCCFFA6;">Проверка</mark><mark style="background: #ADCCFFA6;"> и анализ кода определённой задачи разработчиком перед её релизом</mark>
		Первое на что нужно обратить внимание:
			- Как выполняется задача, мини-недочеты, излишества в коде
			- Наличие / отсутствие документации
			- Есть ли тесты (должны быть)
			- Форматирование кода
			- Нейминг
			- Стиль кода
		<mark style="background: #BBFABBA6;">Плюсы</mark>:
			+ Найти ошибки и баги в коде
			+ Другие разработчики проекта в курсе как выполняется какая-то задача 
			+ Обучение, т.к. методы реализаций какой-то задчи можно повзаимствовать, таким образом все учатся друг у друга
			+ Bus factor - снизить фактор накопления необсужденных вопросов по измененному коду с коллегами. Требуется групповое ревью. Так как код, который знает один человек, может разрастись настолько, что никто в команде не будет ничего понимать, кроме того самого одного хранителя знаний.
		<mark style="background: #FF5582A6;">Минусы</mark>:
			- Время
			- В 1 задаче задействованны как минумум 2 разработчика
		\.
		Как организовывать:
			Если ты отправляешь запрос:
				- не слать сишком много кода
				- писать нормальное описание
				- сделать импорты, чтобы было понятно откуда этот кусок
			Если смотришь:
				- нужно ли это
				- проверить архитектуру
				- проверить наличие тестов и документацию
				- относиться уважительно к чужому коду
				- ответ давать наталкивая к решению, а не давать готовое решение
				- дать ответ максимально расширенно, дать направление
				- проверить нейминг
				- решается ли задача
				- посмотреть подход к решению
				- дать фидбек
		Инструменты: 
				- git hub code review
				- gitlab
	linters and formatters:
		Они нужны для форматирования кода по PEP8 
		линтеры ищую ошибки но не исправляют их, т.к. программист должен будет это сделать. (pylint)
		форматтеры ищут ошибки и предлагают вариант решения(исправляют сами)
		Black - автоматически форматирует текст по стандарту PEP8
	\.
	?признаки запаха кода
	?технический долг - когда откладываем рефакторинг
	?командый код ревью и одиночный
	?порядок в классе какой

4 - Agile, Scrum, Kanban, Waterfall - методологии разработки ПО
	<mark style="background: #BBFABBA6;">Agile</mark> - гибкая методология разработки
		Разработка идет параллельно: и фронт, и бэк и тд. Можно возвращаться к задачам.
		В данном подходе коммуникация важнее инструментов и технологий. Проект бьется на итерации длиной не более месяца. В любой момент можно изменить направление разработки. С заказчиком контакт осуществялется в конце каждой итерации. 
		<mark style="background: #FF5582A6;">Главный минус</mark>:
			- Мало документации. Если уходит один человек, то знания уходят вместе с ним.
		<mark style="background: #BBFABBA6;">Плюсы</mark>:
			- Быстрая разработка
			- Всегда уточняешь вопросы с заказчиком
			- Моментальный фидбек
		Цикл разработки по Agile (инкрементная модель)
			1) Начальное планирование проекта
			2) Проектирование, создание прототипа
			3) Исполнение выбранного прототипа
			4) Тестировка проекта
			5) Оценка и деплой проекта
		\.
		<mark style="background: #ABF7F7A6;">Scrum</mark> - это фреймворк <mark style="background: #BBFABBA6;">Agile</mark>, сухая выжимка. Нужен для слаженной работы и внесение правок на проекте в быстро меняющемся IT мире.
		Имеет:
			- 3 роли 
			- <mark style="background: #FFB86CA6;">product owner</mark> - обладает виденьем, каким должен быть продукт (1 человек)
			- <mark style="background: #FFF3A3A6;">scrum master</mark> - это мост между овнером и командой, его задача наладка стабильного процесса обмена данными между овнером и разработчиками
			- <mark style="background: #D2B3FFA6;">команда разработчиков</mark> - специалисты, работающие над проектом от начала и до конца. Разница обычной команды от Scrum команды заключается в том, что в Scrum команду входят сразу три роли: product owner, scrum master и команда разрабтчиков.
			- 5 событий: 
			- sprint - от 1 недели до 1 месяца отрезок времени, который фиксируется на старте проекта. В этот период времени должен будет выполнен определенный scope задач.
			- sprint planning - митинг, на котором определяется список задач на текущий sprint
			- daily scrum - на этом митинге участники говорят, что сделали вчера и что будут делать сегодня.
			- grooming - velocity (сложность задачи измеряемой в story points) & capacity (длительность выполнения на Jira). velocity выставляется командой на grooming
			- sprint review (DEMO) - показ результатов клиенту последнего sprint командой
			- retrospective - на данном митинге проводится анализ прошлой работы, что было хорошо, что следуюет исправить в будущей работе. Её анализирует Scrum Master
			- 3 артефакта
			- product backlog - список задач всего продукта, за которым нужно следить. Расширять и дополнять. Им занимается product owner.
			- sprint backlog - список задач текущего спринта, должен быть выполнен за sprint. Им занимается Team Lead или Project Manager
			- burn down chart - график сгорания. Показывает тенденцию выполнения задач.
			\.
		<mark style="background: #FFB86CA6;">Kanban</mark> - метод улучшения работы (с японского Сигнал/Карточка)
			Система, построенная на визуализации процесса выполнения задач команды. Метод Kanban появился в Японии в компани Тайота. Вместо sprint в Kanban идут задачи.
			Основная суть:
				- Сокращать количество задач выполняемых в данный момент
			Плюсы:
				- простота использования: высокая вовлеченность команды
				- более гибкий, чем Scrum. Можно взяться за сложную задачу не дожидаясь sprint.
			Минусы:
				- нестабильный список задач
				- тяжело применять на долгосрочных проектах
				- нет дедлайнов
			Work in progress - количество задач которые решаются в канбан деск. Есть лимит, например 3 задачи.
			Kanban подходит больше на оказание поддержки существующим проектам.
		\.
		<mark style="background: #ADCCFFA6;">Waterfall</mark> - это каскадная модель управления разработанная в 1970-х
			Строго по этапам.
			Данная модель подразумевает последовательное прохождение стадий, каждая из которых должна завершиться полностью до начала следующей.
			В модели Waterfall легко управлять проектом. Благодаря её жесткости, разработка проходит быстро, стоимость и срок заранее определены. Однако необходимо сразу знать все этапы работы. 
			Цикл разработки по Waterfall
				- Проектирование - разработчики собирают все требования к проекту и включают их в соответствующий документ
				- Дизайн - на основе требований к проекту создаются прототипы приложения
				- Кодирование - Заказчик выбирает понравившийся ему прототип
				- Тестировка - Тестируем наш продукт
				- Деплой - развертка проекта на боевой сервер
				- Поддержка - сопровождение продукта
			\.

# Core Python 
5 - int, bool, float, str, bytes, bytearray, complex, Decimal, NoneType - базовые типы данных в Python
	<mark style="background: #ABF7F7A6;">Type Casting</mark> - преобразование типов. 
	Преобраования типов бывают:
	- явные - преобразование через функции int(), float(), str() и так далее. Тут могут возникнуть потери данных.
	- неявные - преобразовании типов <mark style="background: #FFB86CA6;">Python</mark> <mark style="background: #FFB86CA6;">автоматически</mark> преобразует один тип данных в другой (например: float + int = float) при этом не допуская потери данных
	\.
	Типы данных делятся на группы:
	- Изменяемые / незименяемые
	- Хешируемые / не хешируемые (<mark style="background: #CACFD9A6;">hashable объект - это объект, который не изменяется и которой можно сравнивать</mark>)
	- Контейнерные (списки например с разными типами) / плоские (строка)
	\.
	<mark style="background: #ABF7F7A6;">int</mark> - Целые числа - numbers.Integral
		в <mark style="background: #FFF3A3A6;">Pyt</mark><mark style="background: #ADCCFFA6;">hon</mark> нет предела длины значения целого числа. Длина ограничивается только памятью. Поддерживает десятичные (1,2,3 и тд), двоичные(0b0, 0b1 и тд), восьмеричные (0o0, 0o1 и тд.) и шестнадцатеричные целые числа (0xABCDF и тд)
		\.
		<mark style="background: #ABF7F7A6;">int</mark> является неизменяемым объектом. Выполняя операции над целым числом мы всегда получаем новый объект. 
		Тип <mark style="background: #ABF7F7A6;">int</mark> в Python представлен классом <mark style="background: #ABF7F7A6;">Int()</mark>
		\.
		Класс Int(x, base=10):
			`x` - число или строка,
			`base` - числовой формат, по умолчанию 10.
			Возвращает целочисленный объект, созданный из числа или строки `x`, или возвращает `0`, если аргументы не заданы.
			\.
			<mark style="background: #FFB86CA6;">Не</mark><mark style="background: #FFB86CA6;"> может преобразовать числа типа complex </mark> так как нет однозначного способа сделать это
			<mark style="background: #FFB86CA6;">Не</mark><mark style="background: #FFB86CA6;"> может преобразовать строку типа "1.1"</mark>
		\.
		<mark style="background: #ABF7F7A6;">int</mark> поддерживает следующие операции:
			- аримфетические операции (сложение, вычитание, деление и тд)
			- побитовые операции. Операции над цепочками битов.
			- операции сравнения (больше, меньше, равно и тд)
			\.
		Битовые операции над целыми числами:
			Целые числа можно интерпретировать как битовые строки и использовать в битовых операциях. 
			<mark style="background: #ADCCFFA6;">Могут</mark><mark style="background: #ADCCFFA6;"> использоваться например в комбинаторике, есть много примеров, например в алгоритме генерации множества всех подмножеств.</mark>
			\.
			Битовые операторы имеют более низкий приоритет чем арифметические операции
			\.
			Положительные целые числа расширяются влево неограниченной строкой битов `0`
			Отрицательные числа, для представления которых используется дополнительный код, расширяются влево неограниченной строкой битов `1`.
			\.
			-   `x << y` - побитовый сдвиг влево
			-   `x >> y` - побитовый сдвиг вправо
			-   `x & y` - побитовое И
			-   `x ^ y` - побитовое исключающее ИЛИ
			-   `x | y` - побитовое ИЛИ
			-   `~x` - побитовое НЕ
			\.
		\.
		id объектов типа int в диапазоне от -5 до 256 является одинаковым 
			a = 256
			b = 256
			print(id(a), id(b))
	\.
	<mark style="background: #BBFABBA6;">bool</mark> - Логический тип данных numbers.Integral
		Логический тип данных, подкласс целочисленного типа данных, принимающий 2 значения: True или False.
		\.
		В иерархии типов наследуется от <mark style="background: #ABF7F7A6;">int</mark>:
			c = True
			c.\_\_class\_\_.\_\_bases\_\_  
			Посмотреть все дандер методы доступные dir() или object.\_\_dir\_\_()
		\.
		Функция bool():
			Приводит другие типы данных к булевому типу
			Вернет <mark style="background: #BBFABBA6;">True</mark> если:
				- непустая строка (пробелы считаются)
				- не ноль
				- непустой список/кортеж
				- функция
			\.
			Вернет <mark style="background: #FF5582A6;">False</mark> если:
				- пустая строка
				- ноль
				- пустой список/кортеж
	\.
	<mark style="background: #FFB8EBA6;">float</mark> - Вещественные числа - numbers.Real
		Числа с плавающей точкой (тип `float`) - это последовательность десятичных цифр, которая включает десятичную точку `.`, за которой следуют числа.
		<mark style="background: #FFB8EBA6;">float</mark> - аппроксимация вещественного числа. То есть это максимальное приближение к числу.  (например 1/3 - это и 0.3, и 0.33333)
		\.
		Тип <mark style="background: #FFB8EBA6;">float</mark> в Python соответствуют числам с двойной точностью в <mark style="background: #CACFD9A6;">С</mark> тип `doube` как в отношении диапазона допустимых значений, так и точности.
		\.
		Поддерживает операции:
			- арифметические (сложение, вычитание, деление тд)
			- операции сравнения (больше, меньше и тд)
		\.
		Тип <mark style="background: #FFB8EBA6;">float</mark> в Python представлен классом <mark style="background: #FFB8EBA6;">float()</mark> 
		\.
		Функция <mark style="background: #FFB8EBA6;">float()</mark> :
			- преобразовывает строку (a='1' или a='1.1') в <mark style="background: #FFB8EBA6;">float</mark>
			- преобразовывает <mark style="background: #ABF7F7A6;">int</mark> в <mark style="background: #FFB8EBA6;">float</mark> 
			<mark style="background: #FFB86CA6;">Не</mark><mark style="background: #FFB86CA6;"> сможет преобразовать числа типа complex</mark>
	\.
	<mark style="background: #FFB86CA6;">str</mark> - Текстовые строки - Неизменяемая последовательность
		Тип <mark style="background: #FFB86CA6;">str</mark> - это текстовые строки представляют собой **неизменяемые последовательности Юникода**.
		\.
		Способы создания:
			1.  Одинарные кавычки: 'позволяет вставлять "двойные" кавычки'
			2.  Двойные кавычки: "позволяет использовать встроенные 'одинарные' кавычки".
			3.  Тройные кавычки:
			    -   '''три одинарные кавычки''',
			    -   """три двойные кавычки"""
			4.  Могут быть созданы из других объектов с помощью функции <mark style="background: #FFB86CA6;">str()</mark>
		\.
		Строки, которые являются частью одного выражения и имеют только пробелы между собой, будут неявно преобразованы в одну строку. 
		То есть выражение `("hello" 'world') == "helloworld"` будет True.
		\.
		Доступные операции над строковым типом данных:
			- Общие операции с последовательностями (Вычисление длины, получение среза, index() и так далее)
			- Методы самого класса <mark style="background: #FFB86CA6;">str()</mark>
		\.
		Форматирование строк:
			- <mark style="background: #CACFD9A6;">f</mark>"You are {name}" - работает быстрее, чем <mark style="background: #CACFD9A6;">format</mark>
			- "You are {name}".<mark style="background: #CACFD9A6;">format</mark>('Кирилл') - обрабатывает больше типов чем <mark style="background: #CACFD9A6;">f</mark>
			- "You are s%" % (name) - устаревшая версия форматирования
		\.
		escape-последовательности - например экранирование:
		 <mark style="background: #CACFD9A6;">'I\`m Kirill and I\`m a "strong" programmer</mark><mark style="background: #CACFD9A6;">'</mark>
		\.
		Сырая строка:
			- r"text" - используется для отработки escape-последовательностей, например путь к файлу.
		\.
		Тип данных <mark style="background: #FFB86CA6;">str</mark> неизменяемый, однако используя str<mark style="background: #FFF3A3A6;">.join()</mark> мы можем эффективно строить строки из нескольких фрагментов
		\.
		Методы строк:
		- <mark style="background: #FFF3A3A6;">.capitalize() </mark> - первая буква предложения будет заглавной
		- <mark style="background: #FFF3A3A6;">.title()</mark> - каждое слово в строке начинается с заглавной буквы
		- <mark style="background: #FFF3A3A6;">.lower()</mark> - текст переводится в нижний регистр. (проверка регистра <mark style="background: #CACFD9A6;">.islower()</mark> ) 
		- <mark style="background: #FFF3A3A6;">.upper()</mark> - текст переводится в верхний регистр (проверка регистра <mark style="background: #CACFD9A6;">.isupper()</mark> ) 
		- <mark style="background: #FFF3A3A6;">.swapcase()</mark> - переводит символы верхнего регистра в нижний, а нижний в верхний
		- <mark style="background: #FFF3A3A6;">.find(symbol, start, stop)</mark> - возвращает индекс первого найденного символа, который в неё передаем. start - с какого символа начать поиск. stop - на каком закончить поиск.
		- <mark style="background: #FFF3A3A6;">.isalnum()</mark> - проверяет, состоит ли строка из букв и цифр.
		- <mark style="background: #FFF3A3A6;">.isalpha()</mark> - проверяет, состоит ли строка только из букв.
		- <mark style="background: #FFF3A3A6;">.isspace()</mark> - проверяет, пустая ли строка (состоит из пробелов)
		- <mark style="background: #FFF3A3A6;">.strip(obj)</mark> - вырезает <mark style="background: #CACFD9A6;">obj</mark> из строки с начала и конца (боков). По умолчанию без obj очищает пробелы и перенос строк.
		- <mark style="background: #FFF3A3A6;">.startswith(symbol)</mark> - проверяет, начинается ли строка с <mark style="background: #CACFD9A6;">symbol</mark>
		- <mark style="background: #FFF3A3A6;">.endswith(symbol)</mark>- проверяет, заканчивается ли строка с <mark style="background: #CACFD9A6;">symbol</mark>
		- <mark style="background: #FFF3A3A6;">.split(sep=)</mark> - разделяет строчку на подстрочки по сепаратору <mark style="background: #CACFD9A6;">sep</mark> 
		- <mark style="background: #FFF3A3A6;">.partition(sep)</mark> - делит строку на подстроки при нахождении хотя бы одного первого попавшегося символа из <mark style="background: #CACFD9A6;">sep</mark>
	\.
	<mark style="background: #D2B3FFA6;">bytes</mark> - Байтовые строки - Неизменяемая последовательность
		Тип данных <mark style="background: #D2B3FFA6;">bytes</mark> - это ==**неизменяемые== последовательности** отдельных байтов. 
		В конечном счете все символы и информация в компьюьтере представлена числами. Строки состоят из символов. И каждому символу присваивается определенное битовое число по кодировочной таблице, например ASCII или UTF-8.
		Кодировка важна при обмене информацией по сети или через файлы. Когда уже байтовое представление находится в памяти Python, то такое понятие как кодировка стирается. Все становится так называемыми Code Points. Просто последовательность символов UNICODE.
		\.
		Работа со строчками в памяти Python бесшовная. 
		\.
		Для создания битовой строки используются одинарные, двойные, тройные кавычки с префиксом `b` перед ними:
		- b'text' 
		- b"text"
		- b"""text"""
		\.
		Три способы создать байтовую строку:
				'Байты'.encode('utf-8')
				bytes('bytes', encoding = 'utf-8')
				bytes([50, 100, 76, 72, 41])
				\.
				Прочеть строку: b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'.decode('utf-8') 
				output -> 'Байты'
		\.
		Используются префикс `r` может так же, как и <mark style="background: #FFB86CA6;">str</mark> обрабатывать escape-последовательности. 
		\.
		Функция <mark style="background: #FFF3A3A6;">ord( )</mark> - помогает узнать код любого символа
		Функция <mark style="background: #FFF3A3A6;">chr( )</mark> - создает по коду символ. Например 97 даст 'a'
		\.
		<mark style="background: #FF5582A6;">СМЕШНО!</mark> Не пытайся переводить байтовую строку в <mark style="background: #FFB86CA6;">str</mark> без указания кодировки, получится бредятина! Он все символы вместе с кавычками как символы воспримет.
		\.
		Читая файлы с байтами нужно передавать режим чтения или записи по типу:
		<mark style="background: #FFF3A3A6;">with</mark><mark style="background: #FFF3A3A6;"> open ('bytefile.bin', 'w+b') as file:</mark>
	\.
	<mark style="background: #D2B3FFA6;">bytesarray</mark> - Байтовый массив - Изменяемая последовательность.
		Метод bytearray() в Python возвращает объект bytearray, который представляет собой массив заданных байтов.  Тоже самое, что и <mark style="background: #D2B3FFA6;">bytes</mark>, только ==изменяемый==
		\.
		b = bytearray(b'hello world!')
		b[0] = 105
		output -> bytearray(b'iello world!')
	\.
	<mark style="background: #CACFD9A6;">complex</mark> - Комплексные числа -  numbers.Complex
		Комплексное число состоит из двух чисел с плавающей точкой, представляющую его действительную (float) и мнимую части (i^2 = -1)
		\.
		Функция <mark style="background: #FFF3A3A6;">complex( )</mark> создает комплексное число по переданным в нее числам.
		Метод комплексного числа <mark style="background: #FFF3A3A6;">.real</mark> выделяет вещественную часть
		Метод комплексного числа <mark style="background: #FFF3A3A6;">.imag</mark> выделяет мнимую часть
		Функция <mark style="background: #FFF3A3A6;">abs( )</mark> возвращает модуль числа
		\.
		Комплексные числа поддерживают все арифметические операции, кроме:
			- // - деление без остатка
			- % - остаток от деления
			- int(), float(), divmod()
			- <mark style="background: #FFB86CA6;">не поддерживает операции сравнения</mark>
	\.
	Decimal - Модуль для работы с десятичными числами - стандартная библиотека Python
		Более точный аналог <mark style="background: #FFB8EBA6;">float</mark>. Точность составляет до 28 цифр. Импортируется из <mark style="background: #CACFD9A6;">decimal</mark>.
		Яркий пример использования: финансовые расчеты
		\.
		Нельзя складывать с <mark style="background: #FFB8EBA6;">float</mark> : Decimal('0.1') + 0.1 выдаст ошибку.
		\.
		С целыми числами можно складывать. 
		\.
		<mark style="background: #FFB86CA6;">Тяжеловеснее</mark>, чем  <mark style="background: #FFB8EBA6;">float</mark>: 24 байта против 104 если брать '1.1'
		\.
		Функция <mark style="background: #FFF3A3A6;">quantize( )</mark> - округляет числа Decimal по заданному методу:
		- ROUND_HALF_EVEN - по дефолту стоит. Округляет до ближайшего четного числа
		- ROUND_HALF_UP - округление в большую степень
		- ROUND_HALF_DOWN - округление в меньшую степень
		- ROUND_FLOOR - не округляет
		x1 = 1.1 + 1.2332
		x2 = Decimal(x1)
		x2.quantize(<mark style="background: #CACFD9A6;">Decimal("0.00")</mark>, ROUND_HALF_UP)
		output --> Decimal('2.33')
		\.
		<mark style="background: #CACFD9A6;">Decimal("0.00")</mark> - формат округления
	\.
	<mark style="background: #CACFD9A6;">NoneType</mark> - None/Ничто- стоит в начале иерархии типов
		Специальное состояние переменной, заглушка, которая означает, что в переменной ничего нет. Аналог NULL. Единый пустой <mark style="background: #FFB86CA6;">SingletoneObject</mark> который уже существует в памяти питона.
		\.
		<mark style="background: #CACFD9A6;">None</mark>  воспринимается интерпретатором как <mark style="background: #FF5582A6;">False</mark>. 
		\.
		Если нужна переменная без инициализации, то ей присваивается значение <mark style="background: #CACFD9A6;">None</mark>
		Чаще используется для какой-то проверки по типу <mark style="background: #CACFD9A6;">is None</mark> 
		Сравнение через == тоже можно, но не следует его использовать так как мы можем переопределять \_\_eq\_\_ и может получиться не совсем то, что мы ожидали. К тому же <mark style="background: #CACFD9A6;">is None</mark> работает быстрее. 
		 при сравнении булевых типов, проверяя например пустой список на <mark style="background: #CACFD9A6;">None</mark>, результат будет <mark style="background: #FF5582A6;">False</mark>
	\.

6 - Collections: list, tuple, set, frozenset, dict, defaultdict
	Коллекции:
		Это типы данных, которые содержат набор элементов.
	\.
	Разница между <mark style="background: #FFF3A3A6;">.sort()</mark> и <mark style="background: #FFF3A3A6;">sorted(</mark><mark style="background: #FFF3A3A6;">)</mark>:
		Разница только в том, что метод sort не создает новой коллекции, а меняет уже существующую. Функция же sorted не меняет исходную коллекцию, а создает новую с отсортированными элементами.
		\.
		- <mark style="background: #FFF3A3A6;">sort()</mark> - сортирует существующую коллекцию
		- <mark style="background: #FFF3A3A6;">sorted()</mark> - создает новую отсортированную коллекцию
		\.
		<mark style="background: #ADCCFFA6;">П</mark><mark style="background: #ADCCFFA6;">араметр reverse = True делает сортировку по убыванию</mark>
		Либо можно в <mark style="background: #FFF3A3A6;">.sort()</mark> передать параметр <mark style="background: #FFF3A3A6;">key=</mark> и уже в него передать то, по чему мы будем сортировать, например результат функции <mark style="background: #FFF3A3A6;">len()</mark>
	\.
	Разница между <mark style="background: #FFF3A3A6;">.reverse()</mark> и <mark style="background: #FFF3A3A6;">reversed()</mark>:
		Важно заметить, что основное **отличие** метода .**reverse** () **и** функции **reversed** () заключается в том, что метод .**reverse** () меняет непосредственно исходный список. В то время как функция **reversed** () не изменяет сам исходный список, и полученное новое значение следует сохранять в новую переменную.
		\.
		- <mark style="background: #FFF3A3A6;">.reverse()</mark> - меняет исходный список 
		- <mark style="background: #FFF3A3A6;">reversed()</mark> - создает новое значение, которое нужно сохранить в переменную
	\.
	<mark style="background: #ABF7F7A6;">list</mark> - список - Изменяемая последовательность
		Список - это тип данных, предназначенный для хранения набора или последовательности разных элементов, каждый из которых имеет свой индекс.
		\.
		Под капотом у списка - динамический массив (vector из C). 
		\.
		Объект списка в CPython:
			typedef struct {
				 PyObject_VAR_HEAD 
				 PyObject <mark style="background: #FFF3A3A6;">**ob_item</mark>; 
				 Py_ssize_t <mark style="background: #FFF3A3A6;">allocated</mark>; 
			} PyListObject;
			\.
			Где:
			- <mark style="background: #FFF3A3A6;">ob_item</mark> - список указателей на элементы списка
			- <mark style="background: #FFF3A3A6;">allocated</mark> - количество выделенной памяти
			\.
			Память для списков питон выделяет с запасом по коэффициенту 1.12, поскольку когда в списке заканчивается место, питон перестраивает его, а это затратною.
			\.
			Если уменьшить список в 2 раза через `.pop()` , то питон список скукожит - выделит новый массив поменьше и перенесет элементы в него.
		\.
		Получение значения по индексу в списке отрабатывает за О(1) так как все элементы нумеруются как 0, 1, 2 и тд. Тогда элемент `X` находится по адресу `HEAD + X*8` если каждый элемент будет занимать по 8 байт. 
		\.
		<mark style="background: #ADCCFFA6;">С</mark><mark style="background: #ADCCFFA6;">писок хранит указатель на HEAD массива и количество элементов в массиве.</mark> 
		Количество элементов также хранится отдельно, чтобы функция <mark style="background: #FFF3A3A6;">len( )</mark> отрабатывала за О(1), а не считала каждый раз количество элементов.
		\.
		Список такой быстрый, потому что все элементы в нем имеют одинаковый вес. При этом хранить он может разные типы данных. Все благодаря тому, что он хранит в себе не сами значения, а указатели на них. Элемент динамического массива - адрес в памяти, а если обратиться по адресу - получишь настоящее значение.
		\.
		<mark style="background: #ADCCFFA6;">Р</mark><mark style="background: #ADCCFFA6;">азмер указателя - 8 байт.</mark>
		\.
		Методы списка:
			<mark style="background: #BBFABBA6;">Быстрые</mark>:
			- Выборка по индексу <mark style="background: #FFF3A3A6;">list[index]</mark> О(1)
			- Запрос длины <mark style="background: #FFF3A3A6;">len(list)</mark> О(1)
			- Добавление элемента в конец списка <mark style="background: #FFF3A3A6;">.append(item)</mark> О(1)
			- Удаление элемента с конца списка <mark style="background: #FFF3A3A6;">.pop()</mark> О(1)
			<mark style="background: #FF5582A6;">Медленные</mark>:
			- Вставка и удаление элемента произвольной позиции <mark style="background: #FFF3A3A6;">.insert(index, item)</mark> O(n)
			- Поиск и удаление элемента по значению for item in list. <mark style="background: #FFF3A3A6;">.index(item), .remove(item)</mark> - работают за О(n)
			- Выборка среза из `k` элементов - <mark style="background: #FFF3A3A6;">list[from:to]</mark> - работает за O(k)
			- Подсчет количества вхождений элемента <mark style="background: #FFF3A3A6;">.count()</mark> O(n)
			- Удалить все элементы списка <mark style="background: #FFF3A3A6;">.clear( ) </mark> O(n)
		\.
		List comprehansion - используется дла заполнения различных структур данных
		\.
		Поверхностная копия списка:
		<mark style="background: #FFF3A3A6;">c</mark><mark style="background: #FFF3A3A6;">oppied_list = numbers.copy( my_list )</mark>
		Bне зависимости от копирования, изменения 1 объекта, не влияют на другой, за исключением вложенных структур, в deepcopy изменения вложенной структуры не влияет на другой объект, а в copy - влияет
		\.
		Источник: 
			https://antonz.ru/list-internals/
	\.
	<mark style="background: #D2B3FFA6;">tuple</mark> - кортеж - Неизменяемая последовательность
		**Кортеж** является неизменяемой упорядоченной коллекцией. Может стать ключом словаря, если содержащиеся в нем объекты будут неизменяемыми.
		\.
		Кортежи используются, <mark style="background: #ADCCFFA6;">чтобы обезопасить данные от случайного изменения</mark>.
		Кортежи<mark style="background: #ADCCFFA6;"> занимают меньше памяти</mark>, чем список (\_\_sizeof\_\_) поскольку у них не аллоцируется дополнительная память.
		Кортежи <mark style="background: #ADCCFFA6;">работают быстрее</mark>, чем списки из-за внутреннего устройства.
		Кортежи <mark style="background: #ADCCFFA6;">имеют бесконечную глубину вложенности</mark> ( кортеж, кортежей кортежей.) -   доступ к элементам происходит по смещению, а не по ключу
		Кортежи <mark style="background: #ADCCFFA6;">хранят указатели на другие объекты</mark>, а значит их можно представлять, как массивы ссылок
		\.
		Распаковка кортежа:
		Если мы помещаем кортежи по обе стороны от оператора `=` , происходит операция распаковки
		(a, b, c) = (1, 2, 3)
		output -> a 1, b 2, c 3
		\.
		Если элемент кортежа есть вложенный кортеж, то применяются дополнительные квадратные скобки (в зависимости от уровня вложенности):
		<mark style="background: #CACFD9A6;">i</mark><mark style="background: #CACFD9A6;">nput_box = ('firstbox', (15, 150))</mark>
		<mark style="background: #CACFD9A6;">p</mark><mark style="background: #CACFD9A6;">rint(input_box[1][1])</mark>
		output -> 150
		\.
		Методы кортежей:
		- Удалить кортеж <mark style="background: #FFF3A3A6;">del tuple</mark>
		- Срез <mark style="background: #FFF3A3A6;">tuple[start : stop : step]</mark>
		- Узнать длину <mark style="background: #FFF3A3A6;">len()</mark>, индекс <mark style="background: #FFF3A3A6;">index()</mark>, число вхождений <mark style="background: #FFF3A3A6;">.count()</mark>
	\.
	<mark style="background: #BBFABBA6;">set</mark> & <mark style="background: #ADCCFFA6;">frozenset</mark>- неупорядоченное множество уникальных элементов.
		Множество — это контейнер, содержащий не повторяющиеся элементы в <mark style="background: #FFB86CA6;">случайном порядке.</mark> К ним **нельзя** обратиться по индексу.
		Замороженные множества нельзя изменить после создания, но все операции по объединению, пересечению и разности они поддерживают: результатом этих операций тоже будут <mark style="background: #ADCCFFA6;">frozenset</mark>.
		\.
		Какие элементы можно включить в состав множества? <mark style="background: #ADCCFFA6;">Это могут быть только элементы иммутабельных типов.</mark> `float`, `int`, `string`, `bool` и прочие подобные. 
		А вот <mark style="background: #FF5582A6;">мутабельные типы</mark> — списки, словари, да и сами множества, <mark style="background: #FF5582A6;">в состав множеств включать нельзя.</mark>
		\.
		Множества не поддерживают конкатенацию (сложение множеств, умножение и тд)
		\.
		Множества занимают много памяти. Больше, чем списки или кортежи.
		\.
		Методы множества:
		- <mark style="background: #FFF3A3A6;">.add( )</mark> - добавить элемент во множество
		- <mark style="background: #FFF3A3A6;">.update( )</mark> - добавить итерируемый объект во множество
		- <mark style="background: #FFF3A3A6;">.discard( )</mark> - удалить элемент, если существует и ничего не сделать, если его и не было
		- <mark style="background: #FFF3A3A6;">.remove( )</mark> - удалить элемент. Если его не было, то выдаст ошибку
		- <mark style="background: #FFF3A3A6;">.pop( )</mark> - удаление крайнего элемента. Можно сказать по сути случайного
		- <mark style="background: #FFF3A3A6;">.clear( )</mark> - удаление всех элементов
		Пересечения множеств
		- <mark style="background: #FFF3A3A6;">.intersection( )</mark> - вернет только общие элементы множеств 
		- <mark style="background: #FFF3A3A6;">.intersection_update( )</mark> - <mark style="background: #FF5582A6;">удаляет элементы из исходного множества, которые отсутствуют в обоих множествах</mark>
		Пример:
			x = {"apple", "banana", "cherry"}  
			y = {"google", "microsoft", "apple"}  
			x.intersection_update(y) 
			print(x) -> output: "apple"
		- <mark style="background: #FFF3A3A6;">.isdisjoint( )</mark> - возвращает True, если два множества имеют нулевое пересечение. То есть общих элементов нет, тогда вернет True
		- <mark style="background: #FFF3A3A6;">.issubset( )</mark> - содержит ли этот набор другой набор
		- <mark style="background: #FFF3A3A6;">.issuperset( )</mark> - содержит ли другой набор этот набор
		- <mark style="background: #FFF3A3A6;">.union( )</mark> - объединение множеств
		Определение общих элементов множеств (пересечение)
			setA & setB
			setA.intersection(setB)
		Объединение множеств
			setA | setB
			setA.union(setB)
		Вычитание множеств
			setA - setB
			Симметричная разность
			setA ^ setB
		Сравнение множеств
			- Равенство: setA == setB
			- Неравенство: setA != setB
			- Определение вхождения одного подмножества в другое множество: 
				Является ли setA подмножеством setB: setA < setB
	\.
	<mark style="background: #FFB86CA6;">dict</mark> & <mark style="background: #FFB86CA6;">defaultdict</mark> & <mark style="background: #FFB86CA6;">OrderedDict</mark> - ассоциативный массив - изменяемые отображения ссылок на объекты, доступные по ключу. <mark style="background: #CACFD9A6;">{None: "1", type(None): "2"}</mark> два разных объектов
		<mark style="background: #FFB86CA6;">dict</mark>: 
			Словарь (dict) представляет собой изменяемую <mark style="background: #FF5582A6;">неупорядоченную</mark> структуру данных, предназначенную для хранения произвольных объектов с доступом по ключу.
			\.
			Под капотом в основе словаря лежит hash-table. 
			\.
			Ключом в словаре может быть только неизменяемый, хешируемый тип данных:
			- int, float, str
			- frozenset
			- кортеж (tuple) содержащий неизменяемы типы данных
			Реализация словаря:
				Словарь - это хеш-таблица. 
				Для разрешения коллизий в Python используется метод открытой адресации. Он позволяет значительно сэкономить память на хранении указателей, которые используются в хэш-таблицах с цепочками.
				\.
				Представление каждой записи в хэш-таблице словаря:
					typedef struct { 
						Py_ssize_t me_hash; 
						PyObject <mark style="background: #CACFD9A6;">*me_key</mark>; 
						PyObject <mark style="background: #CACFD9A6;">*me_value</mark>; 
					} PyDictEntry;
					\.
					<mark style="background: #CACFD9A6;">*me_key</mark> - ключ
					<mark style="background: #CACFD9A6;">*me_value</mark> - словарь
				\.
				Структура словаря PyDictObject:
					typedef struct \_dictobject PyDictObject; 
					struct \_dictobject {
						PyObject_HEAD 
						Py_ssize_t ma_fill; 
						Py_ssize_t ma_used; 
						Py_ssize_t ma_mask; 
						PyDictEntry \*ma_table; 
						PyDictEntry \*(\*ma_lookup)(PyDictObject \*mp, PyObject \*key, long hash); PyDictEntry ma_smalltable<mark style="background: #CACFD9A6;">[PyDict_MINSIZE]</mark>; 
					};
					\.
					- PyDict_MINSIZE - определяет размер словаря, по умлочанию 8 объектов
					- ma_smalltable и ma_table - переменные для хранения хеш-таблицы.
				\.
			Добавление элемента:
			<mark style="background: #FFF3A3A6;">d</mark><mark style="background: #FFF3A3A6;">ict_name[key] = value</mark>
			\.
			Удаление элемента:
			<mark style="background: #FFF3A3A6;">del</mark><mark style="background: #FFF3A3A6;"> dict_name[key]</mark>
			\.
			Обращение к ключу словаря, ошибка не выбрасывается, даже если ключа не было:
			<mark style="background: #FFF3A3A6;">dict</mark><mark style="background: #FFF3A3A6;">_name.get('key')</mark> --> value or None
			\.
			Возвращает значение ключа. Если значения нет, можно передать через запятую, либо вернет None:
			<mark style="background: #FFF3A3A6;">dict_name</mark><mark style="background: #FFF3A3A6;">.setdefault("key")</mark>
			\.
			Также словари можно: копировать <mark style="background: #FFF3A3A6;">copy()</mark>, добавлять объекты <mark style="background: #FFF3A3A6;">update(obj)</mark>, получать ключи <mark style="background: #FFF3A3A6;">.keys()</mark> и значения <mark style="background: #FFF3A3A6;">.values()</mark>, а также пары <mark style="background: #FFF3A3A6;">.items()</mark>, очистить словарь <mark style="background: #FFF3A3A6;">.clear()</mark>
			\.
			Распаковка словаря:
				x, y = {'a': 2, 'b': 5}
				x -> 'a'
				y -> 'b'
		\.
		<mark style="background: #FFB86CA6;">d</mark><mark style="background: #FFB86CA6;">efaultdict from collections</mark> 
			Defaultdict — <mark style="background: #ADCCFFA6;">словарь с дефолтным значением для любого нового ключа.</mark> 
			Пример:
				from collections import defaultdict 
				my_default_dict = defaultdict(int) 
				for letter in 'nigger': 
					my_default_dict[letter] += 1
				\.
				output -> defaultdict(<class 'int'>, {'n': 1, 'i': 1, 'g': 2, 'e': 1, 'r': 1})
				\.
				С помощью данного словаря мы можем задавать значение по умолчанию:
				<mark style="background: #FFF3A3A6;">m</mark><mark style="background: #FFF3A3A6;">y_dict = defaultdict( default_value )</mark>
				\.
				Обращаясь по несуществующему ключу - создает пару ключ + дефолтное значение, либо переданное значение. 
				\.
				Узнать или определить дефолтное значение можно через <mark style="background: #FFF3A3A6;">.default_factory</mark>
				<mark style="background: #FFF3A3A6;">m</mark><mark style="background: #FFF3A3A6;">y_dict.default_factory = lambda: [какое-то правило]</mark> - задаст дефолтное значение по какому-то правилу.
		\.
		<mark style="background: #FFB86CA6;">OrderedDict from collections</mark> - упорядоченный словарь <mark style="background: #FF5582A6;">[УСТАРЕЛО]</mark>
			Обычный словарь не проверяет упорядоченность данных. Если сравнивать два одинаковых словаря, то результат будет True, даже если они расположены в рандомном порядке.
			\.
			OrderedDict - <mark style="background: #ADCCFFA6;">сравнивая, учитывает порядок добавления пар ключ-значение</mark>
			\.
			from collections import ordereddict
			my_dict = OrderedDict()
	\.

7 - Обработка ошибок. Exceptions
	Ошибки в Python представлены <mark style="background: #ADCCFFA6;">исключениями</mark>. Когда интерпретатор обнаружит ошибку - программа тут же останавливается. Если ошибку не обработать - программа умрет. Если обработать, то после обработки продолжит работу.
	\.
	Для обработки исключений используется блок `try + except + else + finally ` 
	Блок `else` вставляется между `except` и `finally` 
	\.
	В try пишем код, который нужно выполнить
	В except передаем ошибку, которую нужно перехватить (`ValuErorr` например). Да, передавать их можно через `,` : <mark style="background: #FFF3A3A6;">except(ZeroDivisionError, ValueError, TypeError):</mark>
	Можно также передавать блоки `except:` один за другим. 
	В else попадаем если код в try отработал нормально без ошибок.
	В finally код вызывается всегда вне зависимости была ошибка или нет. Полезен при создании контекстных менеджеров. 
	\.
	<mark style="background: #FFF3A3A6;">General Except блок</mark> - это обычный `except` без указания ошибки. Сюда будут попадать все неуказанные исключения.
	\.
	Можем также ошибку обозначить через `as` как нам удобно чтобы можно было обратиться к экземпляру этой ошибки. <mark style="background: #FFF3A3A6;">as</mark> сохраняет ошибку в переменную
	\.
	Можно использовать например только блоки `try + finally` 
	\.
	<mark style="background: #FFF3A3A6;">Traceback (трассировка)</mark> — это отчёт, содержащий вызовы функций, выполненные в определенный момент. Трассировка помогает узнать, что пошло не так и в каком месте это произошло.
	\.
	Raise - самостоятельный вызов исключений.
		Исключения можно генерировать самостоятельно — для этого нужно запустить оператор `raise`. Перехватываются такие сообщения точно так же, как и остальные.
	\.
	Пропустить ошибку (не обрабатывать ее) можно через `pass` в блоке `except`
	\.
	<mark style="background: #FF5582A6;">Кастомный</mark><mark style="background: #FF5582A6;"> тип Exception:</mark> 
		В Python можно создавать свои исключения. При этом есть одно обязательное условие: они должны быть потомками класса `Exception`:
		\.
		class MyError(Exception):
			def __init__(self, text):
		        self.txt = text
	 \.
	Иерархия исключений:
		Все исключения наследуются от BaseException: ![[Pasted image 20230109165531.png]]
		<mark style="background: #FFB86CA6;">О</mark><mark style="background: #FFB86CA6;">днако стоит учесть, что кастомные исключения наследуются от просто Exception</mark>
	\.
	Модуль traceback:
		Traceback – это результат трассировки, содержащий вызовы функции в строках кода в определенной точке. Traceback нужно читать снизу вверх. 
		Источники:
			https://www.youtube.com/watch?v=7cBw0x8Tq44
		\.
		Трассировка - это непрерывный отчет, что-то типа логирования, который формируется при выполнении программы. Traceback - вызов к этому отчету.
		\.
		Traceback возвращается при возникновении исключения 
		\.
		Модуль traceback помогает извлекать и печатать трассировку программ.
		Модуль использует <mark style="background: #ADCCFFA6;">объекты traceback - то есть то, что хранится в sys.last_traceback.</mark>
		\.
		Сущности traceback:
			- Value - название ошибки
			- Exception - класс исключения
			- Traceback - объект класса Traceback
			- exc_type - тип исключения, показывает Exception class
			- Frame - stack frame (стековый кадр) суть: при вызове функции её аргументы попадают в стек, а только потом происходит её выполнение. 
			- Stack - цепочка вызовов функций
		\.
		Функции traceback:
			- <mark style="background: #FFF3A3A6;">traceback.print_tb( tb, limit=None, file=None )</mark> - распечатывает до limit записей трассировки из объекта tb. Если limit не указан (None), печатаются все записи.
			  Если file не указан (None), тогда вывод идет в sys.stderr
			- <mark style="background: #FFF3A3A6;">traceback.print_exception( etype, value, tb, limit=None, chain= True )</mark> - распечатывает информацию об исключении и записи трассировки объекта tb до file. Если chain=True, тогда цепочные исключения (\_\_cause\_\_ и \_\_context\_\_) будут распечатаны
			  Отличается от print_tb тем, что:
			  1. Если tb не None, тогда печатает заголовок  `Traceback (most recent call last):`
			  2. Печатает исключение etype и value после трассировки стека
			  3. Если type(value) имеет значение SyntaxError, а value соответствующий формат, печатает строку, в которой произошла синтаксическая ошибка.
			- <mark style="background: #FFF3A3A6;">traceback.print_stack( f=None, limit=None, file=None)</mark> - распечатывает до limit записей или если limit=None, то все записи. Необязательный аргумент f используется для указания дополнительного фрейма стека. file показывает куда вывод сделать. Если не указан, то в sys.stderr
			- <mark style="background: #FFF3A3A6;">traceback.format_exc( limit=None, chain=True )</mark> - делает тоже самое, что и <mark style="background: #FFF3A3A6;">.print_exception( )</mark> но возвращает строку вместо печати в файл.
	\.
	Контекст исключений | raise from
		\.
		Когда мы обрабатываем один вид ошибки в `try-except` блоке у нас может возникнуть какая-нибудь другая ошибка, <mark style="background: #ADCCFFA6;">которую, если мы не обработаем через raise-from, мы скорее всего понять не сможем, откуда она возникла?</mark> Это неудобно:
		def divide(a, b): 
			try: 
				return a / b 
			except <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> as <mark style="background: #FFF3A3A6;">ex</mark>: 
				raise <mark style="background: #D2B3FFA6;">ValueError</mark>('b must not be zero') 
		\.
		Тогда при возникновении <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> также вылезет ошибка <mark style="background: #D2B3FFA6;">ValueError</mark>, однако traceback будет содержать сообщение: 
		<mark style="background: #CACFD9A6;">D</mark><mark style="background: #CACFD9A6;">uring handling of the above exception, another exception occurred:</mark>
		\.
		Чтобы мы получили данные о том, почему сработала <mark style="background: #D2B3FFA6;">ValueError</mark> надо использовать конструкцию `raise-from`:
		def divide(a, b): 
			try: 
				return a / b 
			except <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> as <mark style="background: #FFF3A3A6;">ex</mark>: 
				raise <mark style="background: #D2B3FFA6;">ValueError</mark>('b must not be zero') <mark style="background: #FFF3A3A6;">from</mark><mark style="background: #FFF3A3A6;"> ex</mark>
		\.
		Тогда при возникновении <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> мы увидим сообщение об ошибке <mark style="background: #D2B3FFA6;">ValueError</mark>, с добавленной причиной (\_\_cause\_\_) в traceback:
		<mark style="background: #CACFD9A6;">The</mark><mark style="background: #CACFD9A6;"> above exception was the direct cause of the following exception:</mark>
		\.
		При этом первичная ошибка <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> остается доступной в \_\_context\_\_.
		\.
		Также мы можем использовать `raise-from` не от переменной, содержащей ошибку, а от типа <mark style="background: #CACFD9A6;">None</mark>. Стоит это применять, если причина возникновения ошибки не столь важна и мы можем <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> (причину) опустить:
		def divide(a, b): 
			try: 
				return a / b 
			except <mark style="background: #CACFD9A6;">ZeroDivisionError</mark> as <mark style="background: #FFF3A3A6;">ex</mark>: 
				raise <mark style="background: #D2B3FFA6;">ValueError</mark>('b must not be zero') <mark style="background: #FFF3A3A6;">from </mark><mark style="background: #CACFD9A6;">None</mark>
		\.
		Тогда traceback будет содержать просто сообщение об ошибке _b must not be zero_
		\.
		`__cause__` является причиной исключения - из-за данного исключения было вызвано текущее исключение. Это прямая ссылка - X выдал это исключение, поэтому Y должен выдать это исключение.
		`__context__` означает, что текущее исключение было вызвано при попытке обработать другое исключение, и определяет исключение, которое обрабатывалось в момент возникновения этого исключения.
		`__traceback__` показывает вам стек - различные уровни функций, которые были пройдены, чтобы добраться до текущей строки кода.
		\.
		Источники:
			https://django.fun/ru/docs/python/3.10/library/exceptions/
			https://www.pythontutorial.net/python-oop/python-raise-from/
	\.

8 - Annotations + Dataclasses, namedtuple, Enum
	Аннотации (type hints) - 
		это <mark style="background: #ADCCFFA6;">дополнительное описание в классах, функциях, переменных, которое указывает какой тип данных должен быть в этом месте</mark>.
		При этом сам <mark style="background: #ADCCFFA6;">интерпретатор не проверяет типы данных</mark>. 
		Для проверки используется статический анализатор кодал <mark style="background: #FFF3A3A6;">mypy</mark>
		Можно ли про аннотировать класс - да можно
		\.
		Модуль <mark style="background: #FFB86CA6;">typing</mark>:
			Optional
				Это аннотация неопределенного типа. То есть может быть либо ожидаемый тип, либо None
				<mark style="background: #CACFD9A6;">def</mark><mark style="background: #CACFD9A6;"> foo(arg: Optional[int]) -> None:</mark>
			\.
			Union
				Тип, который позволяет быть либо X, либо Y, либо etc. :
				<mark style="background: #CACFD9A6;">def</mark><mark style="background: #CACFD9A6;"> foo(arg: Union[int, str, float]) -> Union[int, str, float]:</mark>
			\.
			Any
				Неограниченный тип. То есть тип аргумента может быть любым, ожидаем что угодно.
			\.
			Literal
				Мы можем заранее создать переменную, куда добавим типы Literal и потом использовать её при аннотировании:
				<mark style="background: #CACFD9A6;">GENDER</mark><mark style="background: #CACFD9A6;"> = Literal['male', 'female', 'atack_helicopter']</mark>
				<mark style="background: #CACFD9A6;">def</mark><mark style="background: #CACFD9A6;"> foo( name: str, sex: GENDER) -> dict[str, GENDER]:</mark>
					. . .
			\.
			NoReturn
				Он используется для объявления того, что функция не имеет возврата. Если не ожидаем возврат - используем NoReturn
				<mark style="background: #CACFD9A6;">def</mark><mark style="background: #CACFD9A6;"> foo() -> NoReturn:</mark>
					<mark style="background: #CACFD9A6;">print</mark><mark style="background: #CACFD9A6;">('niggers')</mark>
			\.
			Final
				Создав заранее переменную данного типа, в дальнейшем в использовании не позволительно будет её переопределять. При проверке типов при переопределении будет выдана ошибка.
			\.
			TypedDict
				Что-то типа датакласса. Позволяет создать класс, где атрибуты класса будут заранее проанатированны. И по образу и подобию можно будет создавать объекты:
				class Card(TypedDict): 
					rank: Union[str, int] 
					suit: str
				\.
				ace_of_spade: Card = {'rank': 'A', 'suit': '♤'}
			\.
			List
				тип всех элементов списка
				primes: List[int]
			\.
			Tuple
				тип каждого элемента кортежа
				person_info: `Tuple[str, int, float, float]`
				Чтобы указать кортеж переменной длины однородного типа, используйте буквальное многоточие, например `Tuple[int, ...]`.
			\.
			Dict
				тип ключей, тип значений
				stock_prices: Dict[str, float]
			\.
			Set
				тип всех элементов множества
				valid_answers: Set[str]
			\.
			Generator
				Генератор может быть аннотирован общим типом 
				<mark style="background: #FFF3A3A6;">Generator[YieldType, SendType, ReturnType]</mark>.
				def foo() -> Generator\[int, float, str\]:
					. . .
			\.
			Iterator & Iterable
				- Iterable\[some_type\] нам говорит, что объект должен быть итерируемым и принадлежать какому-нибудь типу или классу. 
				- Iterator\[some_value\] - объект является итератором какого-то типа
			\.
			Callable
				Аннотация функций, которые мы возвращаем как результат выполнения других функций:
				def apply_func( a: int, b: int, func: <mark style="background: #FF5582A6;">Callable[[int, int], int]</mark>) -> int:
					return func(a, b)
				\.
				Формат будет такой: два числа что берет, одно число что возвращает
				typing.Callable\[\[int, int\], int\]
			\.
			TypeVar & Type
				Переменная типа. Нужна, чтобы заменить Any при вводе и выводе. Мы можем явно указать тип какой переменной ожидаем. Нужно просто для проверки совпадает ли тип вхождение и тип выхода. Any так не может:
				T = TypeVar( "T" )
				def foo( <mark style="background: #FF5582A6;">value: T</mark>) -> <mark style="background: #FF5582A6;">T</mark>:
				Также TypeVar может принимать разные значения подобно кортежу: 
				T = TypeVar("T", int, UUID)
				\.
				Type("T") - выполняет ту же роль, однако является более простой версией, которую не надо заранее определять.
			\.
			Generic
				Чтобы TypeVar работал внутри методов класса и мы не теряли информацию о типах данных, которые принимаются на вход, необходимо в классе унаследоваться от типа Generic() и передать туда наш TypeVar. В итоге должно получиться что-то типа такого:
				T = TypeVar( "T" )
				class Record(Generic\[<mark style="background: #FFB86CA6;">T</mark>\]):
					id : int
					value : <mark style="background: #FFB86CA6;">T</mark>
					\.
					def \_\_init\_\_(self, id: int, value: <mark style="background: #FFB86CA6;">T</mark>):
						self.id = id
						self.value = value
			\.
			Protocol
				Это не аннотация, а строительный блок для создания универсальных типов. С помощью Protocol( ) можно создавать класы для так называемой "утиной типизации". Если это выглядит как утка, плавает как утка, то это - утка. Проще говоря, Protcol( ) используется для проверки не типов переменных, а их наличие.
				**Протокол** лишь указывает на ожидаемое поведение или атрибуты без всякой заботы о типе:
				class <mark style="background: #FFB86CA6;">MeasurementLike</mark>(<mark style="background: #FFF3A3A6;">Protocol</mark>):
				    timestamp: datetime
			    \.
				def calculate_windowed_avg(
				        measurements: List\[<mark style="background: #FFB86CA6;">MeasurementLike</mark>\],
				        window_size: timedelta,
				        field_name: str
				    ) -> Dict\[datetime, float\]:
				    window_upper_bound = measurements\[0\].timestamp + window_size
			\.
			@overload
				С помощью данного декоратора можно создать дубликаты функций, а уже в этих дубликатах проаннотировать, что мы ожидаем или получаем. 
				`@overload` только декларирует (для линтеров или IDE) разные возможные сочетания аннотаций типов для **одной функции**:
				```
				@overload
				def some_function(value: int) -> int: ...
				@overload
				def some_function(value: float) -> float: ...
				@overload
				def some_function(value: str) -> str: ...
				```
			Источник по типам:
				https://www.youtube.com/watch?v=7Chd5gPHlDg
			\.
		Можно писать свои собственные аннотации:
			Vector = List[ float ]
			def foo(v: Vector) -> Vector:
				print(v)
		<mark style="background: #BBFABBA6;">Плюсы аннотаций</mark>:
			- При создании объектов сразу описаны типы данных, повышается читаемость
			- IDE могут делать подсказки ссылаясь на указанные аннотации типов данных
			- Самодокументация кода путем указания типов данных
		<mark style="background: #FF5582A6;">Нюансы аннотаций</mark>:
			- Нужно импортировать модуль typing для таких типов данных как List, DIct, Tuple и другие
			- лучше использовать последнюю версию Python
		Можно создать пустую переменную благодаря аннотации
			- username: str
		Аннотация типов и наследование[](https://advpyneng.readthedocs.io/ru/latest/book/02_type_annotations/syntax.html#id6 "Permalink to this heading")
			Дочерний класс должен поддерживать те же типы данных, что и родительский
		\.
		Аннотация классов[](https://advpyneng.readthedocs.io/ru/latest/book/02_type_annotations/syntax.html#id5 "Permalink to this heading")
			Аннотация классов пишется так же как аннотация функций. Единственный нюанс методов - self пишется без аннотации.
	\.
	<mark style="background: #ABF7F7A6;">Dataclasses</mark> (DTO - data transfer object, без атрибутов и методов)
		from dataclasses import dataclass
		\.
		@dataclass используется для:
			- <mark style="background: #BBFABBA6;">Хранения данных</mark>
			- <mark style="background: #BBFABBA6;">Автоматизирования генерации кода классов</mark> (чтобы не переписывать каждый раз атрибуты init, repr, str, eq)
			- <mark style="background: #BBFABBA6;">Сокращения дублирования кода</mark>
			- <mark style="background: #BBFABBA6;">Проверка переменных на типы</mark> 
		\.
		Для более жесткой проверки используется метод \_\_post\_init\_\_ .
		\_\_post\_init\_\_ вызывается всякий раз после инициализации объекта. Надо этот дандер метод реализовать внутри дата-класса.
		\.
		Удобнее ближайший конкурентов DICT и LIST в том плане, что позволяет проще заполнять поля и не надо явно прописывать ключи, а также меньше занимает памяти. При этом от него можно наследоваться, чтобы избавиться от дублирования кода. Однако написание методов внутри датакласса считается плохой практикой.
		\.
		Как проверить, является ли класс дата-классом? - <mark style="background: #FFF3A3A6;">is_dataclass(obj)</mark> возвращает True или False
		\.
		Как делать слоты? - \_\_slots\_\_
		Нюансы Dataclass:
			- Порядок постановки таков, что параметры с дефолтными значениями будут ниже
			- без объявления аннотации типов Dataclass проигнорирует такие параметры
			- при создании экземпляра дата класса нужно передавать столько аргументов, сколько объявлено в датаклассе
			- передав в @dataclass(frozen= True) мы можем сделать экземпляр дата класса неизменяемым
			- При использовании frozen=True применяется также дандер метод \_\_hash\_\_
		\.
		Автоматически реализует такие дандер методы как:
						<mark style="background: #FF5582A6;">__init__, __str__, __repr__, __eq__</mark> \.
		\.
		Можно установить дефолтные значение. Датакласс играется со слотами, можно динамически добавлять атрибуты. Новые атрибуты не добавить. 
		\.
		Разница между Namedtuple и Dataclass:
			Но несмотря на общую схожесть, именованные кортежи имеют свои ограничения. Они происходят из того, что именованные кортежи все ещё являются кортежами.
			1. Не такие кастомизируемые как Dataclass
			2. Именованные кортежи неизменяемы.
			3. Не поддерживают наследование
		\.
		Типичный dataclass:
			from dataclasses import dataclass 
			@dataclass 
			class Book: 
				title: str 
				author: str ="Unknown author"
		\.
		Источник:
			https://www.youtube.com/watch?v=kwrpKa_jKtU
		\.
	<mark style="background: #ABF7F7A6;">Namedtuple</mark>:
		Импортируется из collections. Занимает еще меньше памяти, чем DICT и меньше чем Dataclass. 
		Тип импортируется from typing import NamedTuple 
		Мы можем унаследоваться от нашего dataclass и тогда у именнованного кортежа будут указаны типы данных по всем полям. Это позволяет самодокументировать код. Именованный кортеж, похож на словарь, но нельзя менять элементы.
		\.
		Типичный Namedtuple:
			from collections import namedtuple 
			NamedTupleBook = namedtuple("NamedTupleBook", \["title", "author"\])
			\.
			\. теперь можем создать объекты этого кортежа V V V
			\.
			books = \[NamedTupleBook( "Война и Мир", "Толстой" ), NamedTupleBook( "Мастер и Маргарита", "Булгаков" )\]
			\.
			и теперь мы можем обратиться к имени:
			books\[0\].title 
			output -> "Война и Мир"
			\.
			В итоге именнованные кортежи нужны для создания классов этих кортежей с атрибутами, которые не могут быть изменены, что весьма удобно. 
			<mark style="background: #FFB86CA6;">Неизменяемость помогает разрабатывать более устойчивые программы, которые защищены от случайных изменений</mark>.
	\.
	<mark style="background: #ABF7F7A6;">Enum</mark> - Перечисления - from enum import Enum
		— это наборы символических имен, связанных с уникальными константными значениями.
		\.
		<mark style="background: #ADCCFFA6;">И</mark><mark style="background: #ADCCFFA6;">спользуются для создания простых пользовательских типов данных,</mark> таких как времена года, недели, виды оружия в игре, планеты, оценки или дни.
		\.
		Когда перечисления нужны?
			<mark style="background: #ADCCFFA6;">Если есть список логически связанных именованных констант, то будет полезным объявить Enum с помощью которого можно писать понятный код</mark>.
		\.
		Пример кастомного типа данных:
		class ClientResponse(Enum):
	        ok = 1
	        fail = 2
	        `ok - это .name`
	        `1 - это .value`
	    \.
	    Задача перечислений - <mark style="background: #FFB86CA6;">собирать в себе данные определенного типа</mark>. 
	    Например отправляем данные на сервер и нам надо постоянно проверять статус его ответа. И мы можем создать свой кастомный тип данных Req. И в нем определить атрибуты "ok" и "fail". И сравнивать ответ сервера: 
	    if status == <mark style="background: #BBFABBA6;">req.ok</mark>.value: --> <mark style="background: #BBFABBA6;">Все хорошо</mark>
	    if status == <mark style="background: #FF5582A6;">req.fail</mark>.value: --> <mark style="background: #FF5582A6;">Что то не так</mark>
	    \.
	    Посмотреть все элементы:
	    - либо пройтись циклом \[e.value for e in Color\]
	    - либо через дандер метод ClientResoinse.\_member\_names\_
	    \.
	    Клевый пример использования Enum:
		    class Planet(Enum):
			    MERCURY = (3.303e+23, 2.4397e6)
			    VENUS   = (4.869e+24, 6.0518e6)
			    EARTH   = (5.976e+24, 6.37814e6)
			    MARS    = (6.421e+23, 3.3972e6)
				JUPITER = (1.9e+27,   7.1492e7)
				SATURN  = (5.688e+26, 6.0268e7)
				URANUS  = (8.686e+25, 2.5559e7)
				NEPTUNE = (1.024e+26, 2.4746e7)
				\.
				def \_\_init\_\_(self, mass, radius):
					 self.mass = mass      
					 self.radius = radius   
				@property
				def surface_gravity(self):
					G = 6.67300E-11
					return G * self.mass / (self.radius * self.radius)
					\.
			Теперь можем написать: <mark style="background: #FFF3A3A6;">Planet.EARTH.surface_gravity </mark>
			Поолучим: 9.8026...

9 - Logging
		 - это пакет стандартной библиотеки Python для логирования.
		 Зачем нужны логи?
			 Логи - это записи, необходимые для протоколирования. Чем детальнее лог, тем проще разобраться в нестандартных ситуациях работы скрипта. Служит для выявления рода ошибки, время и момента возникновения. Нужны для отладки работы приложения. Это все что разработчики любят принтить через print()
		Logger
			Логер это рычаг за который мы дёргаем каждый раз, когда нам нужно записать информацию в лог.	 
			<mark style="background: #ABF7F7A6;">Уровни сообщения класса Logger</mark>:
				- DEBUG - уровень отладочной информации
				- INFO - уровень вспомогательной информации о ходе работы приложения
				- **WARNING** - уровень предупреждения, можно предупредить, например, что какая-то функция в будущем будет удалена. Стоит по умолчанию в логгере.
				- ERROR - уровень ошибки предоставляет возможность логирования ошибки, например недоступен какой-то сервис
				- CRITICAL - уровень сообщений после которых работа приложения не может продолжаться, например закончилось место на диске. После CRITICAL приложение падает.
			По умолчанию в logging задан уровень **WARNING**, это означает, что сообщения уровня **DEBUG** и **INFO** будут игнорироваться при записи в лог. Разработчик может самостоятельно задать необходимый ему уровень логирования через метод `setLevel` у инстанса Logger
		\.
		Handler 
			Задача класса Handler и его потомков обрабатывать запись сообщений/логов. Т.е. Handler отвечает за то куда будут записаны сообщения.
			Виды Handlers:
				- SteamHandler — запись в поток, например, _stdout_ или _stderr_.
				-  FileHandler — запись в файл, класс имеет множество производных классов с различной функциональностью (ротация файлов логов по размеру, времени и т.д.)
				-  SocketHandler — запись сообщений в сокет по TCP
				-  DatagramHandler — запись сообщений в сокет по UDP
				-  SysLogHandler — запись в syslog
				-  HTTPHandler — запись по HTTP
		\.
		Formatter
			Formatter это ещё один класс в семействе logging, отвечающий за отображение лога.
			Шаблоны записи логов:
				https://docs.python.org/3/library/logging.html#logrecord-attributes
		\.
		Filter
			Задача класса фильтровать сообщения по заданной разработчиком логике. Предположим, что я хочу записывать в лог сообщения, содержащие слово `python`. Чтобы задать фильтр необходимо вызвать метод `addFilter` у инстанса Logger. Передать можно либо инстанс класса, реализующий метод filter либо callable объект (например, функцию).
		\.

10 - Python memory model
	Python изнутри:
		 <mark style="background: #FFF3A3A6;">Pyt</mark><mark style="background: #ADCCFFA6;">hon</mark> - высокоуровневый интерпретируемый язык программирования общего назначения с динамической строгой неявной типизацией и автоматическим управлением памятью. 
		\.
		CPython интерпретируемый, с некоторой компиляцией в нетрадиционном понимании - CPython компилирует* исходный код на Питоне в байткод, а затем интерпретирует этот байткод, запуская его в процессе
		Компиляция -  это конвертация из высокоуровневого языка в машинный код. 
		**Интерпретация** - это чтение файла с исходным кодом программы и поэтапное ее выполнение
		\.
		<mark style="background: #FFF3A3A6;">Строгая типизация</mark>: В JS можно сложить 1 + "1" и результат будет '11'. В Python так нельзя: TypeError.
		\.
		<mark style="background: #FFF3A3A6;">Динамическая типизация</mark>: типы объектов определяются в момент исполнения программы. Переменные можно переопределять, не указывая заранее тип данных как например в Java.
		\.
		При запуске программы создается процесс. ОС выделяет виртуальное адресное пространство. В эту память загружается интерпретатор питона. Для управления свободной виртуальной памятью в этом пространстве используется <mark style="background: #FFF3A3A6;">аллокатор</mark>
		\.
		<mark style="background: #ADCCFFA6;">Главная</mark><mark style="background: #ADCCFFA6;"> задача аллокатора - оптимизация количества вызовов в ОС.</mark>
		\.
		<mark style="background: #D2B3FFA6;">Memory Leak</mark> - утечка памяти. Программа память зарезервировала. Она ее не использует, но память грузит и грузит. Пример: кольцевая зависимость когда в список добавляем такой же список.
		- для поиска утечек памяти можно использовать модуль `gc` и `pympler`
		\.
		Как устроен аллокатор:
			- Арена - большой кусок памяти, содержащий страницы виртуальной памяти ОС
			- Пул - это страница виртуальной памяти, предназначенная для хранения объектов одинакового размера
			- Блок - маленький кусочек памяти для хранения 1 объекта. размеры объектов бывают: 8. 16. 24. 32 ... 512 байт. 
			\. ![[арена питон 7.png]]
		\. 
		Между собой арены связаны двусвязным списком. Отсортированны от самой заполненной, до менее заполненной.
		Три статуса пулов:
			- Full - пул занят, места нет
			- Used - пул свободен, но тип объекта уже занят
			- Empty - пустой пул
			Если empty пулов нет - запрашивается новая арена.
		\.
		<mark style="background: #ADCCFFA6;">Ч</mark><mark style="background: #ADCCFFA6;">ем компактнее живут объекты в рамках арен, тем ниже общее потребление оперативной памяти программой.</mark>
		\.
		Оптимизация часто используемых целых чисел:
			 **Python** заранее выделяет в **памяти** небольшое количество целых чисел **в** **диапазоне** **от** -**5** **до** **256**. Это выделение происходит во время инициализации, и поскольку мы не можем изменить целые числа (иммутабельность), эти предварительно выделенные числа являются синглтонами и на них ссылаются напрямую вместо реаллокации.
		\.
		<mark style="background: #ABF7F7A6;">Garbage collector & счетчик ссылок</mark> - механизмы очистки памяти:
			PyObject - базовый класс для всех объектов в питоне.
			\.
			PyObject считает два поля:
			- <mark style="background: #CACFD9A6;">ob_refcnt</mark> - количетсво ссылок
			- <mark style="background: #D2B3FFA6;">ob_type</mark> - указатель на другой тип данного объекта
			\.
			Когда счетчик ссылок <mark style="background: #CACFD9A6;">ob_refcnt</mark> становится 0, то Python удаляет такой объект.
			\.
			<mark style="background: #FFF3A3A6;">Garbage Collector (GC)</mark> - сборщик мусора, работает так же, как и счетчик, только проверяет еще кольцевые зависимости ссылок друг на друга. 
			В отличие от счетчика, запускается понадобности. Если объекты проходят чистку, то переносит их на поколение назад. И так до трех поколений. В младших (новых) поколениях <mark style="background: #FFF3A3A6;">GC</mark> вызывается чаще, чем в старых.
			\.
			По дефолту счетчик ссылок выключить <mark style="background: #FF5582A6;">невозможно</mark>, а GC - возможно
			\.
			Посмотреть на количество ссылок на объект можно через <mark style="background: #FFF3A3A6;">sys</mark>:
			import sys
			<mark style="background: #FFF3A3A6;">s</mark><mark style="background: #FFF3A3A6;">ys.getrefcount(object)</mark>
			\.
		import <mark style="background: #BBFABBA6;">gc</mark>:
			\.
			Нужна для ручного управления сборщиком мусора: настроить частоту сбора, отключить или включить его, поиск утечки памяти.
			\.
			https://docs.python.org/3.6/library/gc.html
			\.
			Garbage Collector (GC) можно выключить и включить:
			<mark style="background: #FFF3A3A6;">gc</mark><mark style="background: #FFF3A3A6;">.disable() gc.enable()</mark>
			\.
			Функция для отладки утечки памяти:
			<mark style="background: #FFF3A3A6;">gc</mark><mark style="background: #FFF3A3A6;">.set_debug(gc.DEBUG_LEAK)</mark>
			\.
	\.

11 - MRO | Method Resolution Order
	MRO
		MRO решает The Diamond Problem в Python 3. Это порядок разрешения методов. Для поиска атрибутов и методов при множественном наследовании применяется алгоритм поиска в ширину.
		\.
		<mark style="background: #ABF7F7A6;">The Diamond Problem</mark> - проблема выбора методов у наследников, если у нескольких родителей будут одинаковые методы.
		\.
		**Множественное наследование**. - возможность у класса потомка наследовать функционал не от одного, а от нескольких родителей. Благодаря этому мы можем создавать сложные структуры, сохраняя простой и легко-поддерживаемый код.
		\.
		Конечный класс в цепочке всегда – `object`; от него неявно наследуются все объекты в Python 3. Поэтому любое множественное наследование (когда у класса более одного непосредственного родителя) <mark style="background: #ADCCFFA6;">порождает ромбовидные структуры</mark>, потому что все цепочки в конечном счете сходятся в `object`.
		\.
		`__bases__` - применим данный атрибут к классу мы увидим его базовые классы
		\.
		.mro() - функция, помогающая определить порядок наследования
			def print_mro(T):
				print([c.__name__ for c in T.mro()], sep=' -> ')
			\.
			Вывод: 
				print_mro(Z)
				# Z -> K1 -> A -> K2 -> B -> K3 -> C -> D -> E -> O -> object
			\.
	Пример множественного наследования:
		Есть класс машина:
			`class` `Auto:`
			    `def` `ride(``self``):`
				    `print``(``"Riding on a ground"``)`
		Так же у нас есть класс для лодки:
			`class` `Boat:`
			    `def` `swim(``self``):`
				    `print``(``"Sailing in the ocean"``)`
		Стоит задача сделать класс амфибию:
			`class` `Amphibian(Auto, Boat):`
			    `pass`
			    \.
			`a` `=` `Amphibian()`
			`a.ride()`
			`a.swim()`
		Теперь мы можем создать инстанс класса Amphibian, который будет уметь и плавать и ездить. При этом инстанс класса Amphibian, будет одновременно инстансом класса Auto и Boat:
			`a` `=` `Amphibian()`
			`>>>` `isinstance``(a, Auto)`
			`True`
			`>>>` `isinstance``(a, Boat)`
			`True`
			`>>>` `isinstance``(a, Amphibian)`
			`True`
	\.
	Алгоритм С3-линеаризации:
		С3  называется из за трех критериев:
		<mark style="background: #FFB86CA6;">Критерии разрешения методов</mark>:
			\.
			1. Каждый класс должен <mark style="background: #ADCCFFA6;">входить в список ровно 1 раз</mark>.
			\.
			2. <mark style="background: #ADCCFFA6;">В каком порядке класс D наследуется</mark> от нескольких классов **A**, **B**, **C** (`class D(A, B, C):`), <mark style="background: #ADCCFFA6;">в таком же порядке они должны появиться в MRO</mark>. (Монотонность)
			\.
			3. Родители данного класса должны появляться по порядку старшинства. <mark style="background: #ADCCFFA6;">Сначала идут непосредственные родители</mark>, потом дедушки и бабушки, но не наоборот.
			\.
		<mark style="background: #ABF7F7A6;">C3 superclass linearization</mark> – это алгоритм превращения графа наследования в плоский список. 
		\.
		Когда нельзя линеаризовать? Виды неразрешимых насследований:
			<mark style="background: #CACFD9A6;">Пример 1</mark>:
				class X: ...
				class Y: ...
				class A(X, Y): ...
				class B(Y, X): ...
				class G(A, B): ...
				Для **A** порядок `X -> Y`, а для **B** – обратный `Y -> X`. Класс **G** обязан удовлетворить обоим порядкам наследования, что невозможно, так как они противоречат друг другу. Возникнет ошибка в строке объявления класса **G**:
				<mark style="background: #FF5582A6;">TypeError: Cannot create a consistent method resolution</mark>.
				\.
			<mark style="background: #CACFD9A6;">Пример 2</mark>:
				class X: ...
				class Y(X): ...
				class A(X, Y): ...
				<mark style="background: #FFB86CA6;">Здесь класс X наследуется дважды</mark>, и куда мы его не поместили в цепочке MRO, он либо нарушит правило старшинства (`A -> X -> Y -> object`), либо порядка наследования (`A -> Y -> X -> object`)
		\.
		Как задать свой порядок MRO?
			Это возможно, используя метаклассы. Для «конфликтного» класса мы определим особый метакласс, который переопределяет явно метод **mro()**, указывая вручную, какой именно должен быть порядок разрешения методов. На первом «неразрешимом» примере решение будет такое:
				class X: ...
				class Y: ...
				class A(X, Y): ...
				class B(Y, X): ...
				\.
				class MyMRO(type): \н\а\с\л\е\д\о\в\а\н\и\е\ \t\y\p\e\ \-\ \э\т\о\ \м\е\т\а\к\л\а\с\с
					def mro(cls):
						return (cls, A, B, X, Y, object) \я\в\н\о\ \з\а\д\а\е\м\ \п\о\р\я\д\о\к\!
				\.
				class G(A, B, metaclass=MyMRO):
					...
				print_mro(G) # G -> A -> B -> X -> Y -> object \н\и\к\а\к\и\х\ \о\ш\и\б\о\к\!
		\.
	Ты super()!
		**super()** – функция, позволяющая явно ссылаться на родительский класс.
		\.
		Два основных сценария при наследовании:
			Расширение (extended) - наследование от родительского класса, с целью добавить какие-то новые методы в дочернем
			\.
			Переопределение (overriding) - переопределение методов родительского класса в дочернем. <--- <mark style="background: #FFF3A3A6;">super()</mark> используется здесь
		\.
		<mark style="background: #BBFABBA6;">Плюсы super()</mark>:
			- Избавляет от дублирования кода в дочерних классах
			- Не нужно запоминать имя родительского класса при переопределеннии метода
		<mark style="background: #FF5582A6;">Ограничения super()</mark>:
			- Аргументы задаются в <mark style="background: #FFF3A3A6;">super(args)</mark>. Аргументы в функции и super() должны совпадать
			- В случае многоуровневого наследования super() всегда будет ссылаться на  суперкласс.  (на родительский класс). То есть она будет ссылаться на первый найденный метод с таким именем в цепочке mro
		\.
		Иногда требуется обратиться к родительскому классу из дочернего. Например, если дочерний класс переопределяет метод инициализации, то ему, как правило, следует вызвать инициализатор родительского класса. Делать по имени класса не очень удобно и порождает кучу проблем и багов, особенно, если наследование множественное, и мы мало что знаем об устройстве и родственных связях наследуемых классов. Тем более если со временем иерархия изменится, нужно будет поддерживать все вызовы в актуальном состоянии.
		\.
		Явно указывать так методы родительского класса нельзя:
			class C(A, B):
				def \_\_init\_\_(self):
					<mark style="background: #FF5582A6;">A.__init__</mark>(self)
					<mark style="background: #FF5582A6;">B.__init__</mark>(self)
		\.
		Вот как надо:
			class C(B, A):
				def \_\_init\_\_(self):
					<mark style="background: #FFF3A3A6;">super()</mark>.\_\_init\_\_()
		\.
		Источники:
			https://pythonim.ru/osnovy/super-python - норм про super() написано
			https://tirinox.ru/mro-python/ - в целом норм статья
		\.
12 - Scopes & Namespaces (local, nonlocal, global) 
	Scopes - области имен
		Правило, описывающие область видимости переменных <mark style="background: #ABF7F7A6;">L.E.G.B.</mark> :
		- <mark style="background: #D2B3FFA6;">Local</mark> - локальный контекст - присвоение именам внутри функции или внутри лямбды
		- <mark style="background: #FFB8EBA6;">Enclosing function locals</mark> - имена в локальном скоупе, но обернутые в еще одну функцию.
		- <mark style="background: #ABF7F7A6;">Global</mark> - когда переменные находятся вне классов и методов
		- <mark style="background: #CACFD9A6;">Build in</mark> - зарезервированные имена в Python, например <mark style="background: #FF5582A6;">list, import, set</mark>, которые нельзя использовать для переменных. Build in scope трогать не надо.
		\.
		В каждом scope приходится работать со своей переменной. Поэтому переопределить глобальную переменную из замыкающиего или локального скоупа не получится.
		\.
		<mark style="background: #FFB86CA6;">Интерпретатор ищет ближайшее объявление переменной: он спускается из скоупа в скоуп, пока не встретит переменную с заданным именем</mark>. 
		\.
		Если сильно хочется, то из любого скоупа можно переопределить глобальную переменную использовав перед этим ключевое слово <mark style="background: #BBFABBA6;">global</mark>.
		- global greeting 
		- greeting = "Now it is a global variable"
		\.
		Однако следует быть аккуратным, поскольку global жрет много памяти и не очищается, может привести к утечке памяти и вызвать различные баги. Такой код тяжело контролировать, поскольку переменные global могут быть легко изменяемыми.
		\.
		Если в <mark style="background: #FFB8EBA6;">Enclosing function locals</mark> у нас есть желание работать с переменными <mark style="background: #D2B3FFA6;">Local</mark>, то мы можем использовать ключевое слово <mark style="background: #BBFABBA6;">nonlocal</mark>
		- def outer():
			x = 1
			def inner():
				nonlocal x
				x = 2
		в таком случае outer x будет равна 2
	\.
	globals() & locals()
		locals() - обновляет и возвращает словарь текущей локальной таблицы символов.  
		В основном есть два вида таблиц символов. 
		- Таблица глобальных символов. 
		- Таблица локальных символов.
		В глобальной таблице символов хранится вся информация, относящаяся к глобальной области действия программы, доступ к ней в Python осуществляется с помощью метода globals().  
	\.
	Namespaces - пространства имен
		В рамках одного пространства все имена будут уникальны и будут использоваться без конфликтов. Все строки, списки, функции и тд - это объекты. Python реализует пространства имен как словари с привязкой имени к объекту. Несколько пространств имен могут использовать одно и то же имя. 
		- <mark style="background: #FFF3A3A6;">Локальное пространство имен</mark> - содержит локальные имена внутри функции. Это пространство имен создается при вызове функции и продолжается до тех пор, пока функция не вернется.
		- <mark style="background: #FFF3A3A6;">Глобальное пространство имен</mark> - содержит имена из различных импортированных модулей. Создается, когда модуль включен в проект. Существует до завершения скрипта.
		- <mark style="background: #FFF3A3A6;">Встроенное пространство имен</mark> - содержит встроенные функции, имена и исключения.
	\.
	Инструкция if \_\_name\_\_ == "\_\_main\_\_"
		Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной \_\_name\_\_ значение \_\_main\_\_.
		\.
		Конструкция нужна для:
		- Чтобы указать точку входа как main. Посольку по умолчанию Python берет за название файла (точку входа) первую строку
		- Чтобы разделить код. Чтобы при вызове файла как модуля (import) работал одним образом, а при прямом запуска другим образом.
		\.
		Если файл запускается как импортированный, то в качестве \_\_name\_\_ будет указано имя импортированного модуля. 
		Если файл запускается напрямую, то \_\_name\_\_  будет \_\_main\_\_
	\.
13 - Double underscore methods | Descriptors | Python Data Model | @property
			Python Data Model | <mark style="background: #FFB86CA6;">Dunder methods</mark>
				Красота объектной модели в _Python_ состоит в том, что если на уровне класса реализовать определенный функционал, то с объектами этого класса можно будет работать используя “**питонический стиль**” – стиль написания программного кода на Python, который отличается большей выразительностью, читаемостью и понятностью. Такой <mark style="background: #ADCCFFA6;">стиль называют идиоматический</mark> – использующий наиболее естественные для данного языка решения.
				\.
				Всю мощь объектной модели _Python_ можно осознать через изучение назначения и возможностей **специальных методов**. **Это методы, которые вызываются интерпретатором для выполнения различных операций над объектами**.
				\.
				Дандер методы -
					<mark style="background: #FFB86CA6;">это перегрузка операторов</mark>. То есть переопределение выполнения функций при их вызове.
					\.
					<mark style="background: #CACFD9A6;">__str__ & __repr__ </mark> - оба отвечают за строковую репрезентацию объекта. Разница в том, что \_\_repr\_\_ показывает сырые данные для разработчиков и вызывается при потребности в отображении сырых данных, например, если мы создадим экземпляр класса и напишем (передадим) его же в python консоль и нажмем Enter, 
					а \_\_str\_\_ отобразит красивую строку для пользователя, например при вызове str() или print()
					\.
					<mark style="background: #CACFD9A6;">__enter__ и __exit__</mark> - срабатывают при вызове конструкции with open или например если мы собираемся сделать контекстный менеджер. \_\_enter\_\_ срабатывает при создании менеджера контекста, например при вызове оператора with. Когда менеджер завершает свою работу вызывается \_\_exit\_\_ вне зависимости от наличия ошибки
					\.
					<mark style="background: #CACFD9A6;">__iter__ и __next__</mark> - нужны для реализации протокола итератора. С помощью
					 \_\_iter\_\_ создается итерируемый объект (интерфейс, по которому мы будем итерировать). А с помощью \_\_next\_\_ осуществляется переход от элемента к элементу.
					 \.
					<mark style="background: #CACFD9A6;"> __eq__ </mark> - определяет поведение оператора сравнения \=\=. 
					\.
					<mark style="background: #CACFD9A6;">__hash__</mark> - определяет поведение функции hash(). Тесно связан с <mark style="background: #CACFD9A6;">__eq__</mark>, поскольку для равенства объектов между собой при переводе из хеша в объект и из объекта в хеш одного хеша недостаточно. Нужно, чтобы также отрабатывал \=\=. Переопределяя <mark style="background: #CACFD9A6;">__eq__</mark> в классе и пытаясь объекты хешировать,  у нас будет возникать ошибка unhashable type. Поэтому важно также определить \_\_hash\_\_ для того, чтобы объекты все таки хешировались
					\.
					<mark style="background: #CACFD9A6;">__contains__</mark> -  вызывается при проверке того, содержит ли один объект в себе другой объект (in or not in). Например, если мы справшиваем, содержит ли строка какую-то букву: 
					my_str = "Nigger"
					print(my_str.\_\_contains\_\_('g')) --> True
					\.
					<mark style="background: #CACFD9A6;">__new__ & __init__ </mark> - \_\_new\_\_  управляет процессом создания объекта, может использоваться при создании синглтона например. \_\_init\_\_ инициализатор объекта, дополняет его значениями. \_\_new\_\_ возвращает экземпляр класса, а
					 \_\_init\_\_ ничего. Инит создает словарь, обозначать переменные в нем экономнее (\_\_dict\_\_)
					\.
					<mark style="background: #CACFD9A6;">__init_subclass__(cls)</mark> - когда класс наследуется от другого класса, то для этого вызывается данный метод. Таким образом, можно писать классы, которые изменяют поведение подклассов. `__init_subclass__` применяется исключительно к будущим подклассам класса, определяющего метод.
					\.
					<mark style="background: #CACFD9A6;">__getattribute__ </mark> - срабатывает при попытке получить значение атрибута у экземпляра класса
					\.
					<mark style="background: #CACFD9A6;">__getattr__</mark> - будет вызван если мы пытаемся получить атрибут, которого не существует. Хорош для использования в качестве резервного копирования отсутствующих атрибутов
					\.
					<mark style="background: #CACFD9A6;">__getitem__</mark> - определяет поведение получения значения по ключу. Проще говоря: 
					есть класс Student. Создадим экземпляр класса c именем и оценками:
					`s1 = Student("Кирилл", [5, 5, 3, 2])`
					если мы определим метод `__getitem__`, то сможем вызывать значения по индексу:
					`mark = s1[2]` - вот как раз `__getitem__` отвечает за квадратные скобки
					\.
					<mark style="background: #CACFD9A6;">__setitem__</mark> - делает тоже самое, что и <mark style="background: #CACFD9A6;">__getitem__</mark>, только позволяет изменять по индексу:
					`s1[2] = 4` теперь можно через `=` присвоить индексу `[2]` значение 4
					\.
					<mark style="background: #CACFD9A6;">__delitem__</mark> - вызывается при удалении элемента в итерируемом объекте. Теперь можно сделать вот так:
					`del s1[2]` и теперь элемент с индексом `[2]` будет удален
					\.
					<mark style="background: #CACFD9A6;">__await__ </mark> - Возвращает итератор, превращая класс в кортуину, результат которой можно получить с помощью `await`. Вызвать async def: `__await__()`
					Пример:
					def `__await__`(self):
						yield from asyncio.sleep(2)
						print('ok')
			\.
		Дескрипторы
			Дескрипторы это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, изменение, удаление) к атрибутам других объектов. 
			\.
			Дескрипторы не подразумевается использовать сами по себе. Предполагается, что ими будут владеть какие-нибудь связанные с ними классы. 
			\.
			Где будут полезны дескрипторы:
				- Для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. 
				- В частности, дескрипторы полезны при пред ставлении атрибутов в нескольких системах исчисления или каких-либо вычисляемых атрибутов
				\.
			Где используются дескрипторы:
				- В моделях Django при заполнении полей и заполнения БД
				- В SQL Alchemy и в целом в orm
				- Прокси-класс super() - это дескриптор
				\.
				<mark style="background: #FFB86CA6;">Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из</mark> `__get__`, `__set__` или `__delete__`. 
				\.
				Дескрипторы бывают:
				- Data - get
				- Nondata - set, del
		\.
		@property - декоратор функции property()
			объединяет сеттары, геттары и делитторы.
			Нужен для автоматического вызова уже написанных геттаров и сеттаров. Проперти облегачает использование класса. Можно вызывать методы класса как атрибуты.
			\.
			Асинхронный property:
				<mark style="background: #FF5582A6;">@property не поддерживает асинхронные методы.</mark> Однако мы можем использовать методы по типу <mark style="background: #FFF3A3A6;">setattr()</mark>:
				await setattr(attr, 'attrib', 3)
			\.
			Функция: <mark style="background: #FFF3A3A6;">property(fget=None, fset=None, fdel=None, doc=None)</mark>
			\.
			где: 
			- <mark style="background: #FFF3A3A6;">fget</mark> - Функция, возвращающая значение управляемого атрибута
			- <mark style="background: #FFF3A3A6;">fset</mark> - Функция, позволяющая установить значение управляемого атрибута
			- <mark style="background: #FFF3A3A6;">fdel</mark> - Функция для определения того, как управляемый атрибут обрабатывает удаление
			- <mark style="background: #FFF3A3A6;">doc</mark> - docstring
			\.
			Пример использования функции <mark style="background: #FFF3A3A6;">property()</mark>:
				class Circle:
					def \_\_init\_\_(self, radius):
						self.\_radius = radius
						\.
					def \_get\_radius(self):
						print("Get radius")
						return self.\_radius
						\.
					def \_set\_radius(self, value):
						print("Set radius")
						self.\_radius = value
						\.
					def \_del\_radius(self):
						print("Delete radius")
						del self.\_radius
						\.
					radius = property(
					<mark style="background: #FFF3A3A6;">fget</mark>=\_get\_radius,
					<mark style="background: #FFF3A3A6;">fset</mark>=\_set\_radius,
					<mark style="background: #FFF3A3A6;">fdel</mark>=\_del\_radius,
					<mark style="background: #FFF3A3A6;">doc</mark>="The radius property.")
					\.
					Так, можно создать экземпляр класса Circle, например circle = Circle(42.0) и <mark style="background: #FFB86CA6;">теперь можно обращаться к методам класса как к управляемым атрибутам</mark>.
			\.
			Как использовать декоратор @property:
				class Circle:
					def \_\_init\_\_(self, radius):
						self.\_radius = radius
						\.
					@<mark style="background: #FFF3A3A6;">property</mark>
					def radius(self):
						print("Get radius")
						return self.\_radius
						\.
					@<mark style="background: #FFF3A3A6;">radius.setter</mark>
					def radius(self, value):
						print("Set radius")
						self.\_radius = value
						\.
					@<mark style="background: #FFF3A3A6;">radius.deleter</mark>
					def radius(self):
						print("Delete radius")
						del self.\_radius
						\.
						Теперь больше не нужно использовать такие имена методов, как `._get_radius()`, `._set_radius()` и `._del_radius()`. Отныне есть три метода с одинаковым понятным и описательным именем, похожим на атрибут. Код стал чище.
		\.
		@property - lazy-инициализация
			Представим ситуацию, что нам нужно проинициализировать класс, но при этом сэкономить память - то есть проинициализировать его только при обращении к нему. Для этого надо создать метакласс и определить в нем @property.
			\.
			class MyMetaClass(type):
			    @property
			    def my_data(cls):
			        if <mark style="background: #FFF3A3A6;">getattr</mark>(cls, '\_MY\_DATA', None) is None:
			            my_data = ...  # ресурсно затратный вызов к БД
			            cls.\_MY\_DATA = my_data
			        return cls.\_MY\_DATA
			\.
			class MyClass(metaclass=MyMetaClass):
			    # ...
			\. Таким образом, my_data становится атрибутом класса. Поэтому дорогостоящий вызов к БД откладывается до тех пор, пока не попытаемся получить доступ к <mark style="background: #FFF3A3A6;">MyClass.my_data</mark>
		\.
		@classmethod & @staticmethod 
			**@staticmethod** — используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Это типа обычной функции внутри класса. <mark style="background: #FFB86CA6;">@staticmethod функцию можно вызывать без создания экземпляра класса</mark>. <mark style="background: #FF5582A6;">Не принимает self в качестве первого аргумента</mark>
			\.
			**@classmethod** — метод, получающий в качестве неявного первого 
			аргумента класс (cls). 
			Это позволяет использовать класс и свойства внутри метода, а не конкретного экземпляра. <mark style="background: #FFB86CA6;">Также можно вызвать без создания экземпляра класса</mark>, но с помощью такой функции мы можем, например, изменить константу в классе. Проще говоря: <mark style="background: #FFB86CA6;">@classmethod позволяет переопределять такие методы в дочерних классах без механизма наследования. classmethod показывает нам, как должен метод вести себя при вызове дочерниими классами . </mark>
		\.
14 - Generators. Context manager. Comprehensions
	<mark style="background: #ABF7F7A6;">Генераторы</mark>:
		Генератор - <mark style="background: #ADCCFFA6;">это итератор</mark>, где для возврата значений используется yield вместо return. 
		yield ставит функцию как бы на паузу.
		\.
		В объекте-генераторе определены методы <mark style="background: #FFB86CA6;">__next__</mark> и <mark style="background: #FFB86CA6;">__iter__</mark>, то есть реализован протокол <mark style="background: #ADCCFFA6;">итератора</mark>, с этой точки зрения, в Python <mark style="background: #ADCCFFA6;">любой генератор является итератором.</mark> Однако:
		- <mark style="background: #FFB86CA6;">генераетор позволяет отложено создавать результат при итерации.</mark>
		\.
		<mark style="background: #ADCCFFA6;">Итератор</mark> - результат функциеи `iter`, с помощью которого происходит итерирование **итерируемого объекта**.
		\.
		<mark style="background: #ADCCFFA6;">Итерируемый объект</mark> - это что-то, что можно итерировать, то есть пройтись по элементам объекта цикле.
		\.
		-> <mark style="background: #FF5582A6;">Итератор не имеет индексов и может быть использован только один раз</mark>.
		\.
		Где могут использоваться генераторы?
			- может создавать последовательности на основе какого-то алгоритма
			- может брать элементы из источника данных попорционно (коллекции, файлы, сетевое подключение)
			- lazy evaluation - экономия памяти. Генератор не хранит в себе (в памяти) сразу весь результат перебора, чтобы избежать MemoryError
			- генераторы можно использовать в асинхронном программировании и использовать их как корутины
			- можно сделать аналог ChainMap из коллекций, только не по словарям, а по итерируемым объектам используя <mark style="background: #FF5582A6;">либо два цикла</mark> (плохое решение), <mark style="background: #BBFABBA6;">либо конструкцию yield from</mark> (хорошее решение)
		\.
		Объект генератора содержит внутри себя:
			 - последний вычисленный элемент
			 - правило  перехода к следующему элементу
			 - условие, при котором выполнение прерывается
		\.
	    Выдаёт StopIteration, если следующего элемента нет
	    StopIteration - exception, когда элементы закончились
	    В цикле for StopIteration обрабатывается автоматически
	    \.
		yield 
			возвращает элемент и останавливает выполнение функции с сохранением состояния до тех пор, пока мы не захотим получить следующий элемент с помошью метода next. <mark style="background: #FFB86CA6;">yield может быть несколько тогда при вызове next мы будем переключаться между каждым yield</mark>.
		    yield так же использует метод \_\_send\_\_(), чтобы отправлять событие в генератор, например, передать значение в yield, которое оно вернёт
		\.
		Четыре способа создать генератор:
			1. функуия генератор yield:
				 def square_nums(nums):
					 for i in nums:
						 yield (i\*i)
				\.
			2. generator expression (genexp)
			   Всё тоже самое, что и list comprehension, только возвращает итератор
				my_nums = (x\*x for x in range(10))
				next(my_nums) 
				\.
			3. yield from
			   Упрощает использование yield в цикле for
				def generate():
					yield from range(10)
				\.
				Аналог ChainMap (объединение словарей). Объедигяет итерируемые <mark style="background: #FFB86CA6;">объекты в кортеж</mark> и проходится по ним по очереди:
				def chain(\*iterables):
					for iter in iterables:
						yield from iter
				\.
				<mark style="background: #ADCCFFA6;">yield from подходит, когда нам нужно из итерируемого объекта (строка, список) перебрать все элементы и всем им сделать yield без изменения этих элементов</mark>.
				\.
			4. Класс генератор
			   \_\_iter\_\_ определить 100% нужно с ключевым словом yield. \_\_next\_\_ можно определить если не хочется лишний раз писать f = iter(Fib())
					class Fib:
					    def \_\_init\_\_(self):
					        self.a, self.b = 0, 1
					    def \_\_iter\_\_(self):
					        while True:
					            yield self.a
					            self.a, self.b = self.b, self.a+self.b
		\.
		send | throw | close - доп. методы генератора | Data Flow
			<mark style="background: #FFF3A3A6;">.close( )</mark> теперь можно извне заставить генератор остановиться на следующем обращении к нему,
			<mark style="background: #FFF3A3A6;">.throw( exception )</mark> заставляет генератор  при следующей итерации бросить исключение.
			<mark style="background: #FFF3A3A6;">.send( obj )</mark> отправляет данные в генератор перед вызовом следующего блока кода
		\.
		Генератор и асинхронщина:
			StopAsyncIteration - Используется для остановки асинхронного прохода. Это исключение обрабатывается конструкцией `async for` и должно возбуждаться методом `__anext__()` асинхронного итератора для индикации остановки итерирования.
			\.
			асинхронный генератор реализует дандер методы: \_\_aiter\_\_, \_\_anext\_\_
		\.
		Тролинг итератора:
			class Foo:
			   def \_\_iter\_\_(self):
			       return self
			   def \_\_next\_\_(self):
			       return 1
		\.
		Источники:
			Девушка круто объясняет генераторы https://www.youtube.com/watch?v=6J0j8MonKCU
			Более менее адекватная статья по генераторам https://xakep.ru/2014/10/06/generatora-iteratory-python/
			ПРАВДА ОТ НИКИТЫ МАТЮХИНА:
			https://habr.com/ru/post/488112/
	\.
	<mark style="background: #ABF7F7A6;">Контекстный менеджер</mark>. 
		Context manager - это объект, который выполняет рутинную работу при использовании определенный ресурсов. Менеджер контекста <mark style="background: #FFB86CA6;">задаёт временный контекст и ликвидирует его после выполнения операций</mark>. 
		асихнронный контекстный менеджер реализует дандер методы: aexit, aenter
		\.
		Где можно использовать? :
			- при работе с файлами
			- при работе с классами
			- при работе с потоками для управления GIL (try + except блок реализовать блокировку и разблокировку потока при работе с чем-либо)
		\.
		with | open | as
			with — <mark style="background: #ADCCFFA6;">автоматически закрывает файл при выходе вне зависимости была ошибка или нет поскольку сработает __exit__</mark>. Заменяет try + except блок.
			Иногда нужно работать одновременно с двумя файлами. Например, надо записать некоторые строки из одного файла, в другой. Поэтому with open поддерживает перечисление:
			<mark style="background: #CACFD9A6;">with open('r1.txt') as src, open('result.txt', 'w') as dest</mark>:
			   for line in src:
					if line.startswith('service'):
						dest.write(line)
			\.
			open — открывает файл с параметрами на чтение или запись
			as — позволяет обращаться к файловому объекту сохраняя его в переменную
		\.
		Протокол контекстного менеджера:
			Контекстный менеджер вызывает дандер методы
			\_\_enter\_\_ и \_\_exit\_\_ для того, чтобы при работе с файлом у нас всегда <mark style="background: #FFB86CA6;">файл закрывался вне зависимости была ли ошибка или нет поскольку сработает __exit__</mark>. 
			\.
			class ContextManagerExample:  
				def \_\_init\_\_(self, somefilename, filemode):  
					print("Context Manager Created")  
					self.somefilename = somefilename
			        self.filemode = filemode
				\.
				<mark style="background: #FFF3A3A6;">def __enter__(self)</mark>:  
					print("Begin Context Management")
					self.openfile = open(self.somefilename, self.filemode)
			        return self.openfile
				\.
				<mark style="background: #FFF3A3A6;">def __exit__</mark>(self, <mark style="background: #ABF7F7A6;">exc_type</mark>, <mark style="background: #D2B3FFA6;">exc_val</mark>, <mark style="background: #FF5582A6;">exc_tb</mark>):  
					print("End Context Management")    
					self.openfile.close()
				\.
				with ContextManagerExample():  
					FileOpen("temp.txt", "+a") as a:
				        a.write(num)
			\.
			Где:
			- <mark style="background: #ABF7F7A6;">exc_type</mark> - это тип класса ошибок, который вы получите при обработке ошибок 
			  в \_\_enter\_\_ (например AttributeError).
			- <mark style="background: #D2B3FFA6;">exc_val</mark> - это значение ошибки, которое вы получите при обработке 
			  ошибок в \_\_enter\_\_.
			- <mark style="background: #FF5582A6;">exc_tb</mark> - это трассировка ошибки, которую вы получите при обработке 
			  ошибок в \_\_enter\_\_.
			\.
			Если нам потребуется <mark style="background: #FFB86CA6;">подавить исключение (то есть предотвратить его распространение)</mark> внутри контекстного менеджера, то надо вернуть <mark style="background: #BBFABBA6;">True в __exit__</mark>. Дальше уже можем распечатать данный Exception.
			\.
			Контекстный менеджер через генератор + TRY EXECPT
				Инкапсуляция логики класса Ресурс.
				from contextlib import contextmanager
				\.
				@contextmanager
				def open_resource(\*args):
					resource = None
					try:
						resource = Resource()
						resource.open(\*args)
						yield resource
					execpt:
						raise
					finally:
						if resource:
							resource.close()
			\.
			Асинхронный контекстный менеджер через генератор + TRY EXECPT
				from contextlib import asynccontextmanager
				@asynccontextmanager
				async def smtp_connection():
				    client = SMTPAsync()
				    ...
				    try:
				        await client.connect(smtp_url, smtp_port)
				        await client.starttls()
				        await client.login(smtp_username, smtp_password)
				        yield client
				    finally:
				        await client.quit()
			\.
			Асинхронный контекстный менеджер через <mark style="background: #CACFD9A6;">__aenter__, __aexit__</mark> 
				class SMTPConnection():
				    def \_\_init\_\_(self, url, port, username, password):
				        self.client   = SMTPAsync()
				        self.url = url
				        self.port  = port
				        self.username = username
				        self.password = password
					\.
				    <mark style="background: #FFF3A3A6;">async def __aenter__(self)</mark>:
				        await self.client.connect(self.url, self.port)
				        await self.client.starttls()
				        await self.client.login(self.username, self.password)
				        return self.client
					\.
				    <mark style="background: #FFF3A3A6;">async def __aexit__(self, exc_type, exc, tb)</mark>:
				        await self.client.quit()
			\.
			Источники:
				более менее нормальная статья для понятия контекстных менджеров https://medium.com/nuances-of-programming/менеджеры-контекста-в-python-выходим-за-пределы-with-open-file-be9bea60fe99
	\.
	Comrehensions
		Comrehensions - <mark style="background: #ADCCFFA6;">это специальные выражения, которые позволяют компактно создавать списки, словари, множества, которые обычно используют при распаковке данных.</mark>
		\.
		Генераторы словарей (dict)
			Генераторы словарей (dict comprehension) — это метод преобразования одного словаря в другой. Во время этого преобразования элементы исходного словаря, соответствующие заданным условиям, включаются в новый словарь. При этом каждый элемент может быть преобразован по мере необходимости.
			Пример:
				dict1 = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
				dict_variable = {key:value\*\*2 for (key,value) in dict1.items()}
				print(dict_variable)
		Генераторы множеств (set)
			Генератор множества (set comprehension) — это метод создания множеств с использованием элементов из других итерируемых объектов, таких как списки, другие множества или кортежи.
			Пример:
				bebraset = {x for x in range(10)}
				print(type(bebraset), bebraset)
		Генератор списков (list)
			List comprehension — это упрощенный подход к созданию списка, который задействует цикл for, а также инструкции if-else для определения того, что в итоге окажется в финальном списке. 
			\.
			Как выглядит list comprehension:
			<mark style="background: #BBFABBA6;">new_list</mark> = \[<mark style="background: #D2B3FFA6;">operation</mark> for <mark style="background: #FFB86CA6;">list_element</mark> in <mark style="background: #ABF7F7A6;">list</mark>\]
			\.
			<mark style="background: #BBFABBA6;">new_list</mark> - конечный список
			<mark style="background: #D2B3FFA6;">operation</mark> - действие над элементом
			<mark style="background: #FFB86CA6;">list_element</mark> - объект из списка (элемент)
			<mark style="background: #ABF7F7A6;">list</mark> - итерируемый объект (список)
			\.
			Пример:
				my_lsit = <mark style="background: #CACFD9A6;">[x for x in range(10) if x % 2== 0]</mark>
			\.
			Как распаковать список списков:
				items = <mark style="background: #CACFD9A6;">[[1,2,3],[4,5,6],[7,8,9]]</mark>
				comrehension = <mark style="background: #FFB86CA6;">[print(number) for group in items for number in group]</mark> <-- важно 
			\.
		Преобразование generator expression в tuple
			Просто перед genexp прописать ключевое слово tuple
			tuple(i for i in (1, 2, 3))
		\.
		С Python 3.6 появились асинхронные компрехеншены:
			result = <mark style="background: #CACFD9A6;">[i async for i in aiter() if i % 2]</mark>
	\.
15 - Decorators
	Декораторы – это обертка вокруг функций (или классов) в Python, которая меняет способ работы этой функции без измненения кода.  Разработчик может писать свой код так, как ему хочется, и использовать декораторы только для расширения функциональности.
	@wraps(wrapped, asigned, updated) - декоратор, который позволяет заменить атрибуты декоратора на атрибуты исходной функции.
	\.
	Чтобы создать класс декоратор надо в нем реализовать \_\_call\_\_
	\.
	Разница между шаблоном декоратор и просто декоратором:
		- Декораторы Python привязаны к существующему методу и изменяют поведение этого метода.
		  @modifyBehavior 
		  def original(myString): 
			  print myString
			\.
		- Шаблон декоратора - это полиморфизм. В нем мы можем вызывать различные функции декоратора. Фактически, в шаблоне декоратора вы обычно заменяете исходный объект.
		  class Class(object): 
			  def __init__(self): 
				  pass 
			  def something_useful(self, string): 
				  return string 
			\.
		  class Decorator(object): 
			  def __init__(self, wrapped): 
				  self.\_wrapped = wrapped 
			  def withUnderscores(self, string): 
				  return '\_'.join(string.split(' ')) 
			   def \_\_getattr\_\_(self, name): 
				   return getattr(self.\_wrapped, name)
	\.
    wrapped - исходная функция
    <mark style="background: #FFF3A3A6;">Иерархия декораторов</mark>:
	    Один из варианитов использования для тестирования моков. например обращение к базе данных, и нам не нужно чтобы было реальное обращение к БД
	    @dec3()
		@dec2()
		@dec1()
		def foo():
		    pass
	Отработает как -> dec3(dec2(dec1(foo()))) (<mark style="background: #FFF3A3A6;">снизу вверх</mark>)
		@dec3(sigma)
		@dec2(betta)
		@dec1(alpha)
		def foo(alpha, betta, sigma):
			alpha = ....
			betta = ....
			sigma = ....
    Если не использовать wraps, то имя декорируемой функции становится wrapper, а также теряем строку документации функции и свойства функции (имя, документация и так далее)
    Т.е. единственная задача функции wraps – это копирование имени, документации, списка аргументов и т.д., для предотвращения перезаписи. Если учесть, что wraps – это тоже декоратор, можно просто добавить его в нашу actual_func, и проблема решена!
    \.
16 - Metaclasses
	Метапрограммирование - это вид программирования, связанный с написанием программ, которые порождают другие программы.  
	\.
	Метопрограммирование в Python выражено Metaclass\`ами
	Metaclass - <mark style="background: #D2B3FFA6;">это класс, экземпляры которого являются классами</mark>. 
	\.
	Метаклассы в Django:
	Django - использует метаклассы для связи объектов с записями баз данных. То есть <mark style="background: #FFB86CA6;">метаклассы используются реализации API ORM Django</mark>
	\.
	Основная цель метаклассов:
		<mark style="background: #ADCCFFA6;">Иметь возможность автоматически изменять классы при их создании</mark>. 
		Для этого надо в классе определить атрибут \_\_metaclass\_\_ и присвоить ему значение в виде какого-нибудь метакласса. 
		Однако, это не всегда может быть именно тип класса.
		\_\_metaclass\_\_ - <mark style="background: #FFB86CA6;"> в роли метакласса может быть ЛЮБОЙ вызываемый объект.</mark> Поэтому можно использовать функции как метакласс.
		Пример:
			Представим, что нам нужно, чтобы в классе все названия атрибутов были в верхнем регистре. И это можно сделать так:
			\.
			def upper_attr(future_class_name, future_class_parents, future_class_attr): 
			\В\ы\б\р\а\т\ь\ \в\с\е\ \а\т\р\и\б\у\т\ы\,\ \к\о\т\о\р\ы\е\ \н\е\ \н\а\ч\и\н\а\ю\т\с\я\ \с \'\_\_\' 
				 attrs = 
				 ((name, value) for name, value in future_class_attr.items() if not name.startswith('\_\_'))
				 \П\р\е\о\б\р\а\з\у\й\т\е\ \и\х\ \в\ \в\е\р\х\н\и\й\ \р\е\г\и\с\т\р 
				 uppercase_attr = dict((name.upper(), value) for name, value in attrs) 
				 \С\о\з\д\а\н\и\е\ \о\б\ъ\е\к\т\о\в\ \к\л\а\с\с\а\ \с\ \п\о\м\о\щ\ь\ю\ \'\t\y\p\e\' 
				 return type(future_class_name, future_class_parents, uppercase_attr)
				 \В\е\р\н\у\т\ь\с\я\ \в\ \к\л\а\с\с 
			class Foo(object): 
				<mark style="background: #FFF3A3A6;"> __metaclass__ </mark>= upper_attr 
				bar = 'bip'
			\.
		\_\_metaclass\_\_ - при создании класса, он не будет выгружен в память и проинициализирован. <mark style="background: #ADCCFFA6;">Только при запуске программы в рантайме будет создаваться объект класса. </mark>
		И сначала питон будет смотреть, есть ли у класса атрибут \_\_metaclass\_\_. Если в нем содержится метакласс `Foo`, то питон создать объект по правилам `Foo`. 
		Если же его там нет, то питон будет искать атрибут \_\_metaclass\_\_ у родителей и далее по цепочке. 
		Если не найдет совсем, то создаст класс, используя по умолчанию `type` в качестве метакласса.
	\.
	Как создать метакласс:
		Для этого необходимо воспользоваться встроенным подклассом type. 
		Вызывается type для создания экземпляра класса.
		Метаклассы определяется с помощью базовых классов в атрибуте \_\_metaclass\_\_
		\.
		Внутреннее устройство type:
		ClassName = type( "<mark style="background: #ADCCFFA6;">ClassName</mark>", <mark style="background: #ABF7F7A6;">(Mixin, BaseClass)</mark>, <mark style="background: #BBFABBA6;">{"validated":  True}</mark> )
		\.
		Где:
		- <mark style="background: #ADCCFFA6;">ClassName</mark> - имя созданного класса
		- <mark style="background: #ABF7F7A6;">(Mixin, BaseClass)</mark> - кортеж с классами от которых наследуемся 
		- <mark style="background: #BBFABBA6;">{"validated":  True}</mark> - словарь, содержащий аттрибуты, переменные и их значения
		\.
		Добавить новый метод к динамически созданному классу:
			\.
			def echo_message (echo):
				return echo
			\.
			<mark style="background: #ADCCFFA6;">ClassName</mark>.<mark style="background: #FFF3A3A6;">echo_message = echo_message</mark>
		\.
		Применение метакласса:
		class Meta(type):
			def \_\_new\_\_(cls, name, bases, attrs):
				. . . 
		\.
		class User( <mark style="background: #FFF3A3A6;">metaclass=Meta</mark> ):
			def \_\_init\_\_ (self):
				. . .
	\.
	 По умолчанию если метакласса нет, то он будет PyObject
	\.
	 Может ли у класса быть несколько метаклассов? - нет. Попробуйте указать два метакласса в metaclass= и увидите, что будет ошибка.
	 \.
	Можно ли использовать функцию как метакласс?
		Да, можно. type - это и функция, и метакласс, создающий типы. Но как сделать свою функцию?
		def choose_class(name): 
			if name == 'foo': 
				class Foo(object): 
					pass 
				return Foo \В\о\з\в\р\а\щ\а\е\т\с\я\ \к\л\а\с\с\,\ \а\ \н\е\ \э\к\з\е\м\п\л\я\р\ \к\л\а\с\с\а 
			else: 
				class Bar(object): 
					pass 
				return Bar 
		MyClass = choose_class('foo')
	\.
	Исходный код PyObject и источники:
		https://hg.python.org/cpython/file/v2.7.10/Python/ceval.c#l4620 - исходный код
		https://habr.com/ru/post/145835/ - норм статья про метаклассы и глубины
	\.
17 - Инкапсуляция
	Из определения ООП:
	<mark style="background: #ADCCFFA6;">Инкапсуляция - это реализация взаимодействия методов и атрибутов внутри класса.</mark> Классы как капсулы, которые содержат в себе данные и методы. 
	<mark style="background: #FFB86CA6;">Идея инкапсуляции заключается в том, что, пользуясь классом, клиенту не нужно знать о внутреннем устройстве класса</mark>. Поэтому разделяют три уровня доступа к данным и методам класса: PUBLIC, PRIVATE, PROTECTED. 
	\.
	Инкапсуляция как связь:
		В данном случае любой класс, в котором есть хотя бы одна переменная и один метод, который этой переменной управляет, наглядно демонстрирует этот принцип.
		\.
		class <mark style="background: #ABF7F7A6;">Phone</mark>: 
			<mark style="background: #CACFD9A6;">number</mark> = "111-11-11" 
			def <mark style="background: #FFF3A3A6;">print_number(self)</mark>: 
				print( "Phone number is: ", self.number ) 
		my_phone = Phone() 
		my_phone.print_number() 
		input( "Press Enter to exit" )
		\.
		Теперь класс '<mark style="background: #ABF7F7A6;">Phone</mark>' объединяет данные в переменной <mark style="background: #CACFD9A6;">number</mark> с методом <mark style="background: #FFF3A3A6;">print_number()</mark>.
		\.
	Инкапсуляция как управление доступом:
		Доступ - это способность видеть или заменять внутреннее содержимое класса. Доступ - это просто соглашение между программистами. Это не является блокером кода.
		\.
		Существует несколько уровней доступа.
		- PUBLIC: данные доступны всем `publicBanana`
		- PROTECTED: <mark style="background: #ADCCFFA6;">служит для обращения внутри класса и во всех дочерних классах</mark> `_protectedBanana`
		- PRIVATE: включает <mark style="background: #CACFD9A6;">namemangling</mark> для атрибутов с двойным подчеркиванием - запутывание имени. <mark style="background: #ADCCFFA6;">Служит для обращения только внутри класса</mark>. Но мы все равно можем изменить такой атрибут извне, обратившись к нему так: `c._ClassName__privatBanana = "value"`
		\.
		Модуль accessify:
			Данный модуль нужен создания более надежной защиты методов класса.
			Добавляет два декоратора для методов класса.
			- @protected
			- @private
			\.
			Такая защита является более сильной, чем стандартные подчеркивания. 
	\.
	Магические методы - приватные, так как они не предполагаются для прямого вызова
	\.
18 - Абстрактные классы | abc
	В Python <mark style="background: #FF5582A6;">нет интерфейсов</mark> класса, однако любой класс может предоставлять любой интерфейс, достаточно определить методы с нужными именами и аргументами и убедиться, что их поведение соответствует ожидаемому.
	\.
	Интерфейс - класс с набором методов, определяющих какое-то поведение без конкретной реализации, не хранящий состояния. Предоставляет просто методы взаимодействия.
	\.
	Абстрактные базовые классы и интерфейсы — близкие по назначению и смыслу сущности.
	Что абстрактные классы, что интерфейсы — это способы документирования кода.
	\.
	Разница интерфейса и абстрактного класса 
		- состояние - атрибуты
		- у интерфейса нет состояния, т.е. это просто набор методов, также его объект сам по себе существовать не может, создать мы его, конечно, можем, но работать с ним не получиться 
		- abc может иметь состояние 
	\.
	Абстрактный класс - <mark style="background: #ADCCFFA6;">это такой класс, в котором реализован хотя бы один абстрактный метод</mark>. То есть <mark style="background: #ADCCFFA6;">такой метод, при наследовании от абстрактного класса который нужно обязательно переопределить</mark>, чтобы создать у наследника экземпляр класса.
	\.
	ABC (Abstract Base Class) - это класс, реализующий дандер метод `__slosts__`, метакласс которого называется ABCMeta. 
	\.
	<mark style="background: #FFB86CA6;">Важно! У абстрактного класса нельзя создать экземпляр</mark>.
	Типичный абстрактный класс и работа с ним:
	\.
	from abc import ABC, abstractmethod
	class Shape( ABC ):
		def \_\_init\_\_(self):
			super().\_\_init\_\_()
		\.
		@abstractmethod
		def draw(self):
			. . .
		\.
		@abstractmethod
		def area(self):
			. . .
		\.
	Теперь создадим дочерний класс:
	class Rectangle( Shape ):
		def \_\_init\_\_(self):
			 . . .
		\.
		def draw( self ):
			print( ' Drawing Rectangle ' )
		\.
		def area( self ):
			print(' Area is {self.a} * {self.b} ') 
		\.
	Теперь мы можем создать экземпляр класса Rectangle <mark style="background: #FFB86CA6;">после переопределния абстрактных методов</mark>:
	r = Rectangle(10, 20)
	r.area --> 200	
	\.
	Комбинирование докароторов с @abstractmethod:
		Можно объединять все декораторы:
		@property
	    @abstractmethod
	    def prop1(self):
		    . . .
		\.
		@classmethod
		@abstractmethod
		def from_dict(cls, d):
			. . .
		\.
19 - Lambda functions | throw-away fucntion
	Лямбда функция - это анонимная функция, функция без имени.
	\.
	Главный смысл лямба функций - создание **функции**, которая используется в коде <mark style="background: #FFB86CA6;">единожды</mark>.
	\.
	Причина по которой мы используем лямбда функции проста:
	Для использования таких функций как <mark style="background: #FFF3A3A6;">map( func, iterable)</mark> и <mark style="background: #FFF3A3A6;">filter( func, iterable)</mark> нам нужно их прогнать через цикл, иначе они просто будут возвращать map object и filter object. 
	<mark style="background: #ADCCFFA6;">Объявлять лишнюю функцию только лишь для распаковки map & filter неразумно</mark>. 
	\.
	Тут нам и поможет lambda:   
		is_adult = lambda age: age >= 18
		\.
		list(<mark style="background: #FFF3A3A6;">filter</mark>(lambda age: age>=18, ages))
		\.
		<mark style="background: #FFF3A3A6;">map</mark>(lambda x : x\*2, [1, 2, 3, 4]) -> [2, 4, 6, 8]
		\.
		Лямба может работать и с двумя переменными:
		`multiplier = lambda x, y: x*y`
		\.
		Лямбду можно вызвать как функцию:
		`multiplier( 10, 2)` -> 20
	\.
	lambda expressions выглядит так:
		lambda <mark style="background: #ADCCFFA6;">Аргумент(ы)</mark>=<mark style="background: #BBFABBA6;">DefaultValue</mark>: <mark style="background: #ABF7F7A6;">Выражение</mark>
		Где:
		- <mark style="background: #ADCCFFA6;">Аргумент(ы)</mark> множество аргументов. Может быть как много аргументов, так и нисколько. 
		- <mark style="background: #BBFABBA6;">DefaultValue</mark> значение, которое мы можем задать по дефолту аргументам
		- <mark style="background: #ABF7F7A6;">Выражение</mark> - Ламбда функции могут не иметь аргументов. Либо иметь любое их количество. Но <mark style="background: #FFB86CA6;">создать лямбда функцию без выражения нельзя</mark>. И также <mark style="background: #FFB86CA6;">Лямбда-функции в  всегда принимают только одно выражение</mark>.
	\.
	Обязательно ли создавать лямбда-функцию только при случае присвоения её к переменной?
		Мы можем например при указании сортировки sorted( list, key= ) в key= передать лямбда функцию.
	\.
	Аннотирование lambda:
		Для аннотирования лямбда функций, как и для других функций, используется <mark style="background: #FFF3A3A6;">Callable</mark>.
		`from typing import Callable`
		`func: Callable[[int, int], int] = lambda var1, var2: var1 + var2``
		\.
		Формат будет такой: два числа что берет, одно число что возвращает
				`typing.Callable[[int, int], int]
		\.
20 - Вложенные функции и замыкание | Рекурсия
	Рекурсия
		Рекурсивная функция - это функция, которая вызывает сама себя и <mark style="background: #ADCCFFA6;">использует данные прошлого вызова в текущем вызове</mark>. И чтобы хранить где-то эти данные используется стек вызова.
		\.
		Стек - это структура данных, работающая по принципу "ПОСЛЕДНИЙ ВОШЕЛ, ПЕРВЫЙ ВЫШЕЛ", то есть стопка.
		Стек вызовов - это область памяти, в которой выполняются функции. 
		При каждом вызове функции создается <mark style="background: #ADCCFFA6;">фрейм - фрагмент памяти</mark>, в котором содержится:
		- <mark style="background: #FFF3A3A6;">Информация</mark> о текущем статусе выполнения функции
		- <mark style="background: #FFF3A3A6;">Значения</mark> всех переменных, которые функция получила для обработки
		- <mark style="background: #FFF3A3A6;">Локальные данные</mark>, созданные во время вызова
		- <mark style="background: #FFF3A3A6;">Сведение о строке программы</mark>, к которой нужно вернуться после выполнения функции
		\.
		Фреймы помещаются в стек вызовов и также оттуда удаляются. <mark style="background: #ADCCFFA6;">Рекурсивные функции при каждом новом вызове используют эти фреймы</mark>.
		\.
		Управлением добавления и удаления фреймов из стека вызова занимается интерпретатор. Однако мы можем переполнить стек вызовов и получить ошибку <mark style="background: #FFB86CA6;">StackOverFlow</mark>
		\.
		<mark style="background: #ADCCFFA6;">Чтобы стек вызовов не переполнялся</mark>, в каждой рекурсивной функции всегда должны быть предусмотрены два случая:
		1. <mark style="background: #BBFABBA6;">Граничный</mark>, при котором функция завершает работу и возвращает данные в основную программу.
		2. <mark style="background: #FFB8EBA6;">Рекурсивный</mark>, при котором функция продолжает вызывать себя.
		\.
		Пример рекурсивной функции:
		def greetings(st): 
			print(st) 
			if len(st) == 0: %%Граничный случай%% 
				return 'Done!'
			else:  %%Рекурсивный случай%% 
				greetings(st[:-1]) 
				\.
		greetings('Hello, world!')
		\.
		Скорость выполнения: ИТЕРАЦИЯ VS РЕКУРСИЯ
			<mark style="background: #ADCCFFA6;">Итерация - это альтернатива рекурсии</mark>.
			\.
			Скорость неоднозачна:
			\.
			Рекурсивные функции медленно работают с большим объемом данных обычных, так как рекурсия делает множество повторных вызовов, с увеличением числа элементов последовательности <mark style="background: #FFB86CA6;">количество повторов растет лавинообразно</mark>, <mark style="background: #ADCCFFA6;">поэтому их стоит применять только тогда, когда задачу можно разбить на маленькие подзадачи</mark>
			\.
			Если работа с рекурсией неизбежна, то для ускорения работы можно использовать декоратор <mark style="background: #FFF3A3A6;">@lru_cache( maxsize= )</mark> из functools для мемоизации
			Этот декоратор кеширует результат выполнения функции в памяти вплоть до `maxsize=`
		\.
		<mark style="background: #BBFABBA6;">Плюсы рекурсии</mark>:
		- Рекурсивный код <mark style="background: #ADCCFFA6;">снижает время выполнения функции</mark> так как в отличие от циклов, тратят меньше времени до завершения функции. Чем меньше строк кода у нас будет, тем быстрее функция будет обрабатывать вызовы внутри себя.
		- Компактный и лаконичный код
		<mark style="background: #FF5582A6;">Минусы рекурсии</mark>:
		- Рекурсивные методы часто вызывают исключение <mark style="background: #FFB86CA6;">StackOverflowException</mark> при обработке больших наборов
		- Накладные расходы на доп. вызовы функций в виде памяти
		\.
		Разница между рекурсией и while=True:
			- Рекурсивная функция будет многократно вызывать сама себя. При каждом вызове функции переменные помещаются в стек.
			- Бесконечный цикл будет просто повторять выполнение одного и того же кода. Вечное повторение кода.
			   Хотя это может звучать очень похоже, фактические эффекты очень разные.
	\.
	Вложенность и замыкание
		 inner function - это функции, которые мы определяем внутри других **функций**.
		 \.
		 Замыкание -  это функция, которая находится внутри другой функции и ссылается на переменные объявленные в теле внешней функции (свободные переменные).
		 <mark style="background: #ADCCFFA6;">На практике замыкания используются для инкапсуляции кода и скрытия важных данных</mark>С помощью замыканий также можно избежать использования глобальных переменных.
		 \.
		 Пример замыкания:
			 def multiply(<mark style="background: #FFB86CA6;">num1</mark>):
			    var = 10
			    def inner(num2):
			        return <mark style="background: #FFB86CA6;">num1</mark> * num2
			    return inner
			\.
			Замыканием является функция inner, так как <mark style="background: #FFB86CA6;">num1</mark> - параметр функции multiply
			<mark style="background: #ADCCFFA6;">Сохранение доступа к переменным функции более высокого порядка возможно благодаря записи данных в стек</mark>.
		 \.
		 Различия вложенности и замыкания:
			 - замыкание <mark style="background: #FF5582A6;">всегда возвращает колбл объект.</mark> Внешняя функция возвращает внутреннюю. Реализация замыкания: декоратор
			 - А вложенная функция это просто функция определенная в локальном скоупе 
		 \.
		 Можно ли создать inner function внутри inner function:
			 - да, но нужно сделать return`ы
			 def foo():
			   def inner():
			      def inner():
			         def inner():
			            return 'убейте меня'
			         return inner()
			      return inner()
			   return inner()
		\.

21 - Filesystem Paths | os | pathlib 
	Абсолютный (он же полный) путь — это когда мы указываем все диски и папки, в которые нужно зайти, чтобы добраться до нужного файла.
	\.
	Относительный путь — это **путь к файлу относительно текущего каталога**.
	\.
	Что os, что pathlib нужны для работы с операционной системой, файлами, директориями.
	\.
	os
		\.
		Изменения рабочей директории
			По умолчанию рабочей директорией программы является каталог, где содержится документ с ее исходным кодом. 
			- os.<mark style="background: #FFF3A3A6;">getcwd()</mark> - вернет текущий адрес расположения файла на компьютере
			- os.<mark style="background: #FFF3A3A6;">chdir( absolute_path )</mark> - изменяет рабочую директорию на absolute_path
		\.
		Проверка существующего пути
			Для избежания ошибки в случае отсутсвия файла надо заранее проверить существует ли он.
			- os.<mark style="background: #FFF3A3A6;">path.exists("D:/test.txt"))</mark> - передав адрес проверки существования файла вернет True или False
		\.
		Создание директорий
			Создание папок
			- os<mark style="background: #FFF3A3A6;">.mkdir(r"D:\folder)</mark> - указываем путь где надо создать папку folder
			Множественное создание папок
			- os.<mark style="background: #FFF3A3A6;">makedirs(r"D:\folder\first\second\third")</mark> - создаст вложенные папки first/second/third
		\.
		Удаление файлов и директорий
			Удалить конкретный файл по указанном пути
			- os.<mark style="background: #FFF3A3A6;">remove(r"D:\test.txt")</mark> - удалить файл
			- os.<mark style="background: #FFF3A3A6;">rmdir(r"D:\folder")</mark> - удалить папку
			- os.<mark style="background: #FFF3A3A6;">removedirs(r"D:\folder\first\second\third")</mark> - удалить сразу вложенные папки first/second/third
		\.
		Получение имени файла и директории
			- os.<mark style="background: #FFF3A3A6;">path.basename("D:/test.txt")</mark> - преобразует путь в имя файла 
			  output --> test.txt
			\.
			- os.<mark style="background: #FFF3A3A6;">path.dirname("D:/folder/test.txt")</mark> - преобразует путь в имя папки 
			  output --> D:/folder
		\.
		Вычисление размера
			Определяет размер документа или папки
			- os.<mark style="background: #FFF3A3A6;">path.getsize("D:\\test.txt")</mark> --> 136226 вернет размер файла
		\.
		Переименование файла или папки
			- os.<mark style="background: #FFF3A3A6;">rename(r"D:\folder", r"D:\catalog")</mark> - переименование folder в catalog
		\.
		Содержимое директорий
			- os.<mark style="background: #FFF3A3A6;">listdir(r"D:\folder")</mark> - вернет список всех файлов в каталоге
			- os.<mark style="background: #FFF3A3A6;">stat(r"D:\test.txt")</mark> - вернет основные сведения об объекте
		\.
		Обработка путей
			- os.<mark style="background: #FFF3A3A6;">path.split(r"D:\folder\test.txt")</mark> - вернет --> `('D:\\folder', 'test.txt')`. Просто делит маршрут
			- os.<mark style="background: #FFF3A3A6;">path.join(r"D:\folder", "test.txt")</mark> - соединит два маршрута в один, 
			  вернет --> `D:\folder\test.txt`
		\.
		Прикольные фишки:
			- <mark style="background: #FFF3A3A6;">os.system( command )</mark> - выполнит в консоли любую команду
			- <mark style="background: #FFF3A3A6;">os.replace( current path, new path)</mark> - перемещает файл
			- <mark style="background: #FFF3A3A6;">os.listdir(path)</mark> - вернет список всех папок в текущем каталоге
			- <mark style="background: #FFF3A3A6;">os.scandir(path)</mark> - вернет итерируемый объект файлов, работает подобно listdir
			\.
			Проитерировать директорию 
			for item in <mark style="background: #FFF3A3A6;">os.scandir(path):</mark>
				if item.is_file():
					. . .
			\.
			for item in <mark style="background: #FFF3A3A6;">os.walk(path)</mark>:
				. . .
			- <mark style="background: #FFF3A3A6;">os.walk(path) </mark> - точно так же, как и listdir позволяет ходить по файлам, однако os.walk возвращает полный адрес всех вложенных объектов в директории
		\.
		Сложить относительный и абсолютный пути
			- <mark style="background: #FFF3A3A6;">os.path.splitdrive(path)</mark> - делит путь на драйвер (диск С например) и остальной путь
			Если задать os.path.splitdrive('C:/dir') --> вернет ('C:', '/dir')
			\.
			path1 = 'C:/folder1/folder2/'
			path2 = 'D:/directory1/directory2/'
			\.
			seps = os.sep + os.altsep if os.<mark style="background: #BBFABBA6;">altsep</mark> else os.<mark style="background: #BBFABBA6;">sep</mark>
			path3 = os.path.join(path1, os.path.splitdrive(path2)\[1\].lstrip(seps))
			\.
			--> `C:/folder1/folder2/directory1/directory2/`
			\.
			os.<mark style="background: #BBFABBA6;">altsep</mark> & os.<mark style="background: #BBFABBA6;">sep</mark> - делят путь по "/"
	\.
	Pathlib
		\.
		Разница между os & pathlib:
			Как указать путь файла:
			- в pathlib: "output/output.xlsx"
			\.
			- в os:
			  import os
			  outpath = os.path.join(os.getcwd(), 'output')
			  outpath_file = os.path.join(outpath, 'out.xlsx')
			\.
			- from pathlib import Path
			   outpath = <mark style="background: #ABF7F7A6;">Path.cwd() / 'output' / 'output.xlsx'</mark>
			\.
			Таким образом, в Pathlib путь к файлу указывается проще и более читаемо.
			<mark style="background: #ADCCFFA6;">В Pathlib альтернативой os.path.join является "/"</mark>.
			\.
			Правило: Использовать pathlib, если нужно использовать пути как объекты, os если есть интерес в ресурсах, представленных этим путем
			\.
			pathlib <mark style="background: #BBFABBA6;">преимущества</mark> перед os:
			- pathlib делает код очевиднее
			- не такой перегруженный как os
			- не нужно беспокоиться о нормализации путей, `/` все сделает сам. Библиотека pathlib автоматически подстраивает формат пути под операционную систему
			- обратная совместимость: os.path умеет воспринимать объекты Path из pathlib
			\.
			pathlib <mark style="background: #FF5582A6;">недостатки</mark> перед os:
			- низкая скорость из-за создания кучи объектов Path. Работает как минимум в 2 раза медленее, чем os.path
		\.
		Создание и удаление папок и файлов
			- <mark style="background: #FFF3A3A6;">path.is_dir()</mark> - вернет True или False если папка существует
			- <mark style="background: #FFF3A3A6;">path.rmdir()</mark> - удалить папку
			- <mark style="background: #FFF3A3A6;">path.mkdir(path)</mark> - создает папку по  указанному пути
			- В модуле `os` сложновато найти утилиты, связанные с путем. Модуль Pathlib решает эту проблему, заменяя утилиты модуля `os` методами объектов пути
			- <mark style="background: #FFF3A3A6;">path.unlink(file)</mark> - удаляет один файл, Unix название метода remove в os (os.remove)
			- <mark style="background: #FFF3A3A6;">Path.touch()</mark> - создает пустой файл с заданным разрешением по указанном пути
		\.
		Открыть файл, созданный в пути
			- <mark style="background: #FFF3A3A6;">Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</mark> - вернет файловый дескриптор
			- <mark style="background: #FFF3A3A6;">Path.glob(pattern)</mark>: Получение всех файлов которые соответствую паттерну, например <mark style="background: #ABF7F7A6;">*.jpg</mark> (все картинки) или <mark style="background: #ABF7F7A6;">*.mp3</mark> (все песни) в текущей директории. 
			- <mark style="background: #FFF3A3A6;">Path.rglob(pattern)</mark> - работает так же, как и Path.glob(), будет искать файлы по некоторому паттерну, однако будет искать не только в текущей директории, но и <mark style="background: #FFB86CA6;">рекурсивно</mark> начнет искать во вложенных директориях. 
			- <mark style="background: #FFB86CA6;">glob & rglob в любом случае вернут объект генератора</mark>, который можно будет конвертировать например в список.
		\.
		Альтернатива pathlib.Path.joinpath
			Дандер метод `__file__` - cлужит для указания текущего пути где находится файл
			p = <mark style="background: #FFF3A3A6;">pathlib.Path(__file__)</mark>
			print(p)
			--> `/home/rochdikhalid/dev/src/package/example.py`
		\.
		Проитерировать директорию:
			- <mark style="background: #FFF3A3A6;">Path.iterdir()</mark> - вернет итератор объектов пути содержимого каталога
			p = Path('docs')
			for item in p.iterdir():
				. . .
		\.
		Сложить асболютный и относительный пути:
			path1 = Path('C:/folder1/folder2/')
			path2 = Path('D:/directory1/directory2/')
			path3 = path1 / path2.<mark style="background: #FFF3A3A6;">relative_to</mark>(path2.<mark style="background: #FFF3A3A6;">anchor</mark>)
			\.
			--> `C:\folder1\folder2\directory1\directory2`
		\.
		Получить текущий путь файла:
			- <mark style="background: #FFF3A3A6;">Path.cwd()</mark> - аналог os.getcwd(), вернет текущий путь к файлу
	\.
	Источники
		https://all-python.ru/osnovy/os.html - норм сайт
	\. 
22 - datetime
	Модуль для управления датой и временем.
	Universal Coordinated Time - UTC - международный стандарт регулирования времени в мире. В качестве точки отсчета используется Гринвичский меридиан — UTC 0.
	UTC такой же как и GMT (меридиан Гринвич), однако UTC не считается с вращением Земли, а потому является более точным.
	\.
	В Unix-системах точкой отсчета (`epoch`) является 1 января 1970 г.
	\.
	Сравнение можно проводить только с объектами, созданными из одного и того же класса:
		datetime.<mark style="background: #FF5582A6;">datetime</mark>.now() >= datetime.<mark style="background: #FF5582A6;">date</mark>.today() --> <mark style="background: #FF5582A6;">TypeError</mark>
		\.
		В остальных случаях сравнение происходит как с числами.
			date1 = date(1995, 3, 20)
			date2 = date(2020, 1, 1)
			date2 > date1 --> True
	\.
	Naive & Aware objects
		Наивный (Naive) объект - объект, содержащий неполное значение даты и времени
		\.
		Осведомленный (Aware) объект - объект, содержащий точные значения, часовой пояс, чтобы точно дать ответ, какое время сейчас.
		\.
		_If your `datetime` object knows what timezone the date and time it represents is in, then we call that an <mark style="background: #D2B3FFA6;">aware</mark> `datetime` object. If it doesn't have timezone information, we call that a <mark style="background: #ABF7F7A6;">naive</mark> object._
		\.
		<mark style="background: #FFB86CA6;">Чтобы проводить операции над датами, необходимо их привести к одному часовому поясу</mark>.
	\.
	Модуль состоит из объектов 3-ех типов:
	- time - время
	- date - дата
	- datetime - время и дата
	\.
	Timedelta - разница времени:
		delta = datetime.timedelta( days, seconds, microseconds, milliseconds, minutes, hours, weeks)
		\.
		Объекты timedelta представляют длительность между датами.
		Операции над timedelta objects:
		- сложение 
		- вычитание
		- умножение даты на число
		- деление одной даты на другую
	\.
	Получение данных
		- datetime.datetime.<mark style="background: #FFF3A3A6;">now()</mark> - текущая дата и время
		- datetime.<mark style="background: #FFF3A3A6;">date.now()</mark> - только текущая дата
		- datetime.datetime.<mark style="background: #FFF3A3A6;">now()</mark>.<mark style="background: #FFF3A3A6;">time()</mark> - только текущее время
		- datetime.datetime.<mark style="background: #FFF3A3A6;">utcnow()</mark> - текущая дата и время по гринвичу (UTC-0)
	\.
	Компоненты модуля datetime:
	- date - объекты даты
	- datetime - объекты даты и времени
	- time - объекты времени
	- timedelta - <mark style="background: #ADCCFFA6;">атрибут, который позволяет добавлять или вычитать разницу между датами, временем. Можно передать секунды, недели, дни и т.д.</mark>
	- Tzinfo - атрибут, отвечающий за часовые пояса.
	\.
	Форматирование даты:
		<mark style="background: #FFF3A3A6;">date.strftime( format )</mark> - конвертирует дату в строку
		Примеры форматов:
		%Y - год
		%A - день недели
		%d - календарное число
		%B - месяц
		%Z - часовой пояс
		\.
		Форматирование строки в дату:
		<mark style="background: #FFF3A3A6;">date.strptime( string )</mark> - конвертирует строку в дату
		Пример:
		string_date = '2022-12-31'
		date = datetime.strptime( string_date, "%Y-%m-%d")
		--> 2022-12-31 00:00:00
	\.
	Указать часовой пояс.
		Если хочется через datetime, то вот так:
		\.
		tz = datetime.timezone(<mark style="background: #FFF3A3A6;">datetime.timedelta(hours=3)</mark>, name='MOSKVA')
		zhopa = datetime.datetime(2024, 10, 1, <mark style="background: #FFF3A3A6;">tzinfo=tz</mark>)
		\.
		Через специальную библиотеку <mark style="background: #ABF7F7A6;">pytz</mark> можно вот так:
		\.
		tz = <mark style="background: #FFF3A3A6;">pytz.timezone</mark>('Europe/Berlin')
		zhopa = datetime.datetime.now(<mark style="background: #FFF3A3A6;">tz=</mark>tz)
	\.
	Как проводить операции над aware & naive объектами:
		datetime не проводит вычисления между часовыми поясами, так как это сложный процесс.
		Для работы с датами без часовых поясов и с ними необходимо все перевести в один тип часового пояса. 
		Пример функции:
		def function(past_time):
		    now = datetime.datetime.now()
		    <mark style="background: #FFF3A3A6;">now = now.replace(tzinfo=past_time.tzinfo)</mark> <--- благодаря этой строчке все работает
		    diff = now - past_time
		    return diff
		 \.

23 - I/O Objects | BytesIO | TextIO | open
	io
		Модуль io предоставляет инструменты для работы с различными типами ввода-вывода.
		Основное применение модуля: <mark style="background: #ADCCFFA6;">работа с оперативной памятью и файлами в ней вместо записи на диск.</mark> Хоть мы и можем работать со стандартными <mark style="background: #FFF3A3A6;">read( )</mark> и <mark style="background: #FFF3A3A6;">write( )</mark>, модуль io дает больше гибкости в отношении этих операций.
		\.
		Три типа ввода/вывода:
		- Текстовый I/O
		- Бинарный I/O
		- Необработанный I/O
		\.
		Объект, принадлежащий любой из категорий, называется файловым объектом.
		Вне зависимости от типа объекта он может быть доступен только:
		- для чтения
		- для записи
		- для чтения и записи
		\.
		В модуле существует 2 ключевых класса:
		- <mark style="background: #ABF7F7A6;">BytesIO</mark> -> операции ввода-вывода с байтовыми данными
		- <mark style="background: #FFB86CA6;">StringIO</mark> -> операции ввода-вывода для строковых данных
	    \.
	    Файловый дескриптор - это неотрицательное число, идентификатор потока ввода-ввывода, который автоматически присваеивается файлу при открытии или создании.
	    Файловые дескрипторы нужны для:
	    - Индексации таблицы файлов, открытых всеми процессами
	    - В дескриптор записывается режим открытия файла
	    - Дескрипторы хранят сведения об атрибутах переданного объекта и его расположения
	    \.
	    Класс <mark style="background: #ABF7F7A6;">BytesIO</mark>:
		    - bytes_stream = io.BytesIO(b"some text") 
		    \.
		    bytes_stream - здесь это будет дескриптор байтового потока
		    \.
		    Буфер - это оперативная память. 
		    Чтобы напечатать данные внутри буфера, необходимо использовать <mark style="background: #FFF3A3A6;">.getvalue( )</mark>:
		    - <mark style="background: #FFF3A3A6;">.getvalue()</mark> - возвращает строковое представление содержимого буфера. Берет значение байтовой строки из дескриптора.
		    bytes_stream = io.BytesIO(b"some text") 
		    print(bytes_stream.getvalue())
		    --> b'some text'
		    \.
		    Разница между <mark style="background: #FFF3A3A6;">.read()</mark> и <mark style="background: #FFF3A3A6;">.getvalue()</mark>:
			    - .getvalue() не требует переноса курсора буфера в нулевое положение, так как возвращает весь буфер
			    - .read() читает один раз и поэтому требуется перенос курсора в начало
			      <mark style="background: #FFB86CA6;">bytes_stream.seek(0)</mark>.
			\.
			Необходимо после работы с объектом BytesIO закрывать дескриптор буфера. Это разгружает память и предотвращает ошибки.
			- bytes_stream.<mark style="background: #FFF3A3A6;">close()</mark>
			\.
		Класс <mark style="background: #FFB86CA6;">StringIO</mark>:
			Запись в буфер:
				- string_stream = io.StringIO("some text")
				При использовании write() <mark style="background: #FF5582A6;">старый контент перезаписывается</mark>. Поэтому нужно быть внимательным:
				. . .
				string_stream = io.StringIO("old content")
				print(string_stream.getvalue()) --> old content
				string_stream.write("new content")
				print(string_stream.getvalue()) --> new content
				string_stream.close()
				. . .
			Чтение из буфера:
				- string_stream = io.StringIO("some text")
				- print( string_stream<mark style="background: #FFF3A3A6;">.read()</mark> ) - правда тогда курсор сдвинется и придется использовать <mark style="background: #FFF3A3A6;">.seek(0)</mark>
		\.
		Класс <mark style="background: #D2B3FFA6;">TextIO</mark>:
		\.
		Чтение файла с помощью io:
			Особенностью чтения файлов с помощью модуля io заключается в том, что мы можем читать файлы прямо из буфера.
			Допустим у нас есть `sample.txt`. Тогда прочесть мы его можем так:
			. . .
			file = io.open("sample.txt", "rb", buffering = 5)
			print(file.read())
			file.close()
			. . .
			buffering - размер буфера в байтах.
			\.
			Разница между os.open() & io.open():
				- os.open() - выполнит системный вызов open() и вернет дескриптор файла, который нельзя использовать как объект дескриптора io
				- io.open() - является оболочкой os.open() и обрабатывает многие ошибки под капотом.
		\.
		Разница между BytesIO.read() & .read1()
			- <mark style="background: #FFF3A3A6;">read()</mark> - позволяет читать файлоподобные объекты в памяти
			  принимает параметр \_\_<mark style="background: #ABF7F7A6;">size = int</mark> в котором можно указать количество байт для чтения
			- <mark style="background: #FFF3A3A6;">read1()</mark> - работает также, однако возвращает на 1 байт меньше. Это делает его полезным для постепенного чтения больших объемов данных.
			  \.
			  В общем, если нужно задать количество байт для чтения - используем <mark style="background: #FFF3A3A6;">read()</mark>, если нужно читать постепенно - используем <mark style="background: #FFF3A3A6;">read1()</mark>
		\.
		seek() & tell():
			- <mark style="background: #FFF3A3A6;">.seek(pos)</mark> - устанавливает курсор при чтении на позицию pos
			- <mark style="background: #FFF3A3A6;">.tell()</mark> - возвращает текущую позицию курсора
		\.
		.flush() & peek(n):
			- <mark style="background: #FFF3A3A6;">.flush()</mark> - перемещает данные из буфера в текущий файл. Гарантирует сохранность данных
			- <mark style="background: #FFF3A3A6;">.peek(n)</mark> - получение n байт из буфера <mark style="background: #FFB86CA6;">без сдвига курсора</mark> или все доступные данные, если n не указан.
		\.
		Источники
			https://timeweb.com/ru/community/articles/chto-takoe-faylovyy-deskriptor-prostymi-slovami - файловые дескрипторы
			https://runebook.dev/ru/docs/python/library/io - дока на русском
		\.
# Algorithms & Tasks
24 - Algorithms and data structures
	<mark style="background: #ABF7F7A6;">Big O, Time complexity</mark>:
		Big O показывает темп роста функции. Нужен для описания сложности алгоритмов через понятие времени.
		При вычислении:
		- не учитываем константы.
		- Последовательность действий - это сложение (N+M)
		- Вложенные действия - это умножение (N * N)
		- Для алгоритма, который берет половину элементов с каждым шагом - сложность 0(logN)
		- Сложность - это НЕ скорость. Это кол-во выполняемых действий.
	\.
	**Investigate dict in Python**
		\.
		Что произойдет если:
		\.
		**d = {1: "a", True: "b", 1.0: "c"}  
		print(d)**
		\.
		--> На экран выведется **{1:c}**. 
			   Так как 1 это посути и True, и 1.0. И мы как бы каждый раз переопределяем по ключу наше значение. Сначала "a", потом "b" и в конце это "c". И по сути остается только  "c" так как остальные значения были переопределены.
		\.
	Структуры данных:
		<mark style="background: #ABF7F7A6;">Линейные</mark>:
			Линейные структуры данных (или списки) – это упорядоченные структуры, в которых адрес данного элемента однозначно определяется его номером (индексом).
			\.
			<mark style="background: #ABF7F7A6;">Queue</mark> - очередь.
				Очередь в Python – это линейный тип структуры данных, используемый для последовательного хранения данных. Ее концепция основана на FIFO (“First in First Out”), что означает «первым пришел – первым обслужен». Или так: «первым пришел – первый вышел»
				\.
				Операции очереди, сложность O( 1 )
					Enqueue - постановка в очередь.
					Dequeue - удаление из очереди в том же порядке, в котором был поставлен. 
					Front - элемент вставлен в переднюю часть.
					Rear - элемент удален из задней части.
				Реализация очереди списком, сложность O ( N )
					que = list()
					que.append('Apple')
					que.append('Mango')
					que.append('Papaya')
					print(que)
					.
					print(que.pop(0))
				Реализация очереди через multiprocessing.Queue
					 from multiprocessing import Queue 
					 que = Queue()
					 que.put('Apple') 
					 que.put('Mango') 
					 que.put('Banana') 
					 .
					 print(que) 
					 print(que.get()) 
					 print(que.get()) 
					 print(que.get())
				Реализация разных очередей
					https://pythonpip.ru/examples/ochered-python 
				\.
			**<mark style="background: #ABF7F7A6;">Stack</mark>** - стэк (стопка)
				Стек в Python – это линейная структура данных, в которой данные расположены объектами друг над другом. Он хранит данные в режиме LIFO (Last in First Out). Данные хранятся в том же порядке, в каком на кухне тарелки располагаются одна над другой.
				Методы стека O ( 1 )
					empty() - возвращает True, если стек пуст.
					size() - возвращает длину
					top() - возвращает адрес последнего элемента
					push(g) - добавит элемент 'g' в конец стека
					pop() - удаляет верхний элемент
				Реализация стека списком O ( N )
					stack = list()
					\д\о\б\а\в\л\я\е\м\ \в\ \с\т\о\п\к\у
					stack.append('A')
					stack.append('B')
					stack.append('C')
					.
					print(stack)
					.
					\у\д\я\л\е\м \и\з\ \с\т\е\к\а
					.
					print('\nElements poped from stack:')  
					print(stack.pop())  
					print(stack.pop())  
					print(stack.pop())  
					print('\nstack after elements are poped:')  
					print(stack)
				Реализация стека через очередь модулем LifeQueue
					from queue import LifoQueue   
					stack = LifoQueue(maxsize = 5)  
					print(stack.qsize())   
					stack.put('x')  
					stack.put('y')  
					stack.put('z')  
					print("Stack is Full: ", stack.full())   \в\о\з\в\р\а\щ\а\е\т\ \T\r\u\e\ \е\с\л\и\ \о\ч\е\р\е\д\ь \з\а\п\о\л\н\е\н\а
					print("Size of Stack: ", stack.qsize())   \q\s\i\z\e\ \в\о\з\в\р\а\щ\а\е\т\ \р\а\з\м\е\р\ \о\ч\е\р\е\д\и
					print('\nElements poped from the my_stack')   
					print(stack.get())   
					print(stack.get())   
					print(stack.get())   
					print("\nStack is Empty: ", stack.empty())
				Реализация разных стеков
					https://pythonpip.ru/examples/stek-python
				\.
			**<mark style="background: #ABF7F7A6;">Deque</mark>** - дека (double ended queue) 
				Deque, также известный как двусторонняя очередь, имеет атрибут вставки и удаления элементов данных с любого конца. Модуль deque в Python – это сегмент библиотеки, известный как collections.
				\.
				Реализация деки, модуль Collections
					import collections 
					deque = collections.deque([10, 20, 30, 40, 50]) \с\о\з\д\а\н\и\е\ \д\е\к\и
					\. 
					deque.append(60) \д\о\б\а\в\л\е\н\и\е\ \с\п\р\а\в\а
					print( "The deque after appending at right: " ) 
					print( deque ) 
					\.
					deque.appendleft(70) \д\о\б\а\в\л\е\н\и\е\ \с\л\е\в\а
					print( "The deque after appending at left: " ) 
					print(deque )
					\.
					deque.pop() \у\д\а\л\е\н\и\е\ \с\п\р\а\в\а
					\.
					deque.popleft() \у\д\а\л\е\н\и\е\ \с\л\е\в\а
		\.
		<mark style="background: #D2B3FFA6;">Нелинейные</mark>:
			Нелинейные структуры данных — это структуры данных, у которых связи между элементами зависят от выполнения определенного условия. Пример нелинейных структур — деревья, графы
				 \.
			<mark style="background: #D2B3FFA6;">Г</mark><mark style="background: #D2B3FFA6;">раф </mark> 
				Граф - совокупность точек (элементов) и ребер между ними
				\.
				Пример графа - граф знаний. В нём узел представляет некую сущность, или понятие, а ребро указывает на взаимосвязь пары подобных сущностей. Таким образом, структура _узел-ребро-узел_ хранит конкретный факт знаний о мире или некой системе.
				Граф-знаний картинка:
						![[Pasted image 20221228153154.png]]
						\.
			\.
			<mark style="background: #D2B3FFA6;">Д</mark><mark style="background: #D2B3FFA6;">ерево</mark>
				Дерево - частный случай графа. 
				\.
				Разные древовидные структуры позволяют **быстрее** и легче получать доступ к данным, поскольку дерево — структура **нелинейная**.
				\.
				Чтобы выполнить какую-либо операцию с деревом, нужно добраться до определенного узла. Для этого и существуют алгоритмы обхода дерева.
				\.
				<mark style="background: #ABF7F7A6;">Способы обхода деревьев</mark>: 
					- Рекурсивно (в глубину)
					- Стек (в глубину)
					- Очередь (в ширину)
				\.
				Где используются деревья:
					- Модель DOM в HTML документах
					- Деревья двоичного поиска помогают быстро проверить наличие элемента в наборе.
					- Префиксные деревья используются в маршрутизаторах, они хранят информацию о маршруте.
					- Большинство популярных баз данных основаны на B-деревья и T-деревья.
					- Компиляторы используют абстрактное синтаксическое дерево, чтобы находить синтаксические ошибки в ваших программах
				\.
				Виды деревьев:
					Бинарное деревое
					АВЛ-дерево - сбалансированное по высоте двоичное дерево поиска. Различие по высоте не более чем на 1
					B-Tree - Сбалансированное дерево. Сбалансированность означает, что длины любых путей от корня до листьев различаются не более, чем на 1.
			\.
	Hash table / Hash functions / Hash Collision
		<mark style="background: #ADCCFFA6;">Хеш</mark><mark style="background: #ADCCFFA6;">-таблица — это абстрактная структура данных, которую используют, если хотят быстро выполнять операции вставки/удаления/нахождения O(1).</mark>  В Python это может быть либо DICT, либо SET
		\.
		<mark style="background: #FF5582A6;">Минус хеш таблиц</mark>: 
		Хеш-таблицы тяжеловесные, и, хоть они и быстро отвечают на вопросы основных операций, пользоваться ими все время очень затратно.
		\.
		<mark style="background: #ADCCFFA6;">Хеш</mark><mark style="background: #ADCCFFA6;">-функция представляет собой функцию, возвращающую значение по переданному в неё ключу. Это алгоритм, куда на вход подается ключ, а на выходе получается уникальный хеш, который после преобразуется в индекс в таблице.</mark>
		\.
		Хеширование - это преобразование данных <mark style="background: #FFF3A3A6;">ЛЮБОЙ</mark> длины в данные <mark style="background: #FFF3A3A6;">ЗАДАННОЙ</mark> длины 
		\.
		Главная задача хеш-функции - это возвращать один и тот же хеш для одного и того же ключа.
		\.
		При заполнении хеш-таблицы растет вероятность возникновения коллизии. Поэтому лучше заполнять таблицу только на 75%. И при достижении заполнения в 75% - расширять её путем по сути создания новой хеш таблицы просто с такими же данными и увеличенными слотами. Важно её именно пересоздать, чтобы хеш, который преобразуется в ключ, оставался актуальным.
		\.
		<mark style="background: #ABF7F7A6;">Коллизии</mark>:
			Коллизии возникают если двум ключам назначается один элемент массива.
			Один из вариантов решения коллизии – создание связанного списка.
			Однако хеш-функция, создающая неравномерно распределенный массив с огромным количеством связанных списков – плохая хеш-функция, ведущая к коллизиям.
			Для определения заполнения используется коэф. заполнения, равный отношению кол-ва элеметов в хеш-таблице к общему числу элементов.
			\.
		**Методы разрешения коллизий:**
			- **Разрешение коллизий с помощью цепочек** (когда находим коллизию, добавляем в конфликтную ячейку следующее значение, по сути создание связанного списка)
			- **Принцип пробирования** (переиспользование хеш-функции пока не получим уникальный хеш)
			- **Принцип рехеширования** (перенос удаленных ячеек в другую таблицу)
			- Использование таблицы с открытой адресацией. Вместо связанных списков каждая ячейка хранит один объект с ключом и значением. Суть заключается в том, что получая коллизию, хеш-функция продолжает искать свободную ячейку в массиве.
			\.
		<mark style="background: #ABF7F7A6;">Single/Double Linked List</mark> - односвязный и двусвязный списки
			Это динамическая структура данных, состоящая из узлов. 
			Узел включает в себя:
				- элемент списка
				- ссылку или ссылки на следующий узел и предыдущий узел
			Связный список обеспечивает возможность создать двунаправленную очередь из каких-либо элементов. Каждый объект такого списка считается узлом. 
			По факту в узле есть его значение, а также две ссылки – на предыдущий и на последующий узлы. То есть список «связывается» узлами, которые помогают двигаться вверх или вниз по списку. 
			\.
			Концом такого спизка является значение NONE. Началом HEAD. Последним узлом TAIL.
			\.
			Реализация связанного списка
				https://habr.com/ru/company/otus/blog/470828/
			\.
	<mark style="background: #ABF7F7A6;">Sorting Algorithms - алгоритмы сортировки</mark>:
		Сортировка - это последовательное расположение элементов, упорядочивание их по какому-то условию. 
		<mark style="background: #CACFD9A6;">Selection Sort - сортировка выборкой</mark>  O (n²)
			Первый элемент становится эталоном. Затем эталон сравнивается с элементами списка, пока не найдем реально наименьший элемент. Наименьший элемент двигается в начало списка. Далее сортируемый список уменьшается на 1. Так повторяется до тех пор, пока массив не отсортируется.
			\.
			Реализация алгоритма сортировки выборкой
				def selection_sort(nums):
			    for i in range(len(nums)): \З\н\а\ч\е\н\и\е\ \i\ \с\о\о\т\в\е\т\с\т\в\у\е\т\ \к\о\л\-\в\у\ \о\т\с\о\р\т\и\р\о\в\а\н\н\ы\х\ \з\н\а\ч\е\н\и\й
			        lowest_value_index = i \И\с\х\о\д\н\о\ \с\ч\и\т\а\е\м\ \н\а\и\м\е\н\ь\ш\и\м\ \п\е\р\в\ы\й\ \э\л\е\м\е\н\т
			        for j in range(i + 1, len(nums)): \Э\т\о\т\ \ц\и\к\л\ \п\е\р\е\б\и\р\а\е\т\ \н\е\с\о\р\т\и\р\о\в\а\н\н\ы\е\ \э\л\е\м\е\н\т\ы
			            if nums[j] < nums[lowest_value_index]:
			                lowest_value_index = j
			        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i] \С\а\м\ы\й\ \м\а\л\е\н\ь\к\и\й\ \э\л\е\м\е\н\т\ \м\е\н\я\е\м\ \с\ \п\е\р\в\ы\м\ \в\ \с\п\и\с\к\е
			\.
		<mark style="background: #CACFD9A6;">Insertion Sort - сортировка вставками</mark> O (n²)
			Первый элемент считаем отсортированным, далее в оставшемся списке начинаем сравнивать каждый элемент с отсортированным подмассивом. Ну и вставляем элементы в отсортированный массив. Так повторяем, попутно уже сравнивая массивы внутри отсортированного массива, пока не отсортируется.
			\.
			Реализация алгоритма сортировка вставками
				def insertion_sort(nums):
					for i in range(1, len(nums)): \С\о\р\т\и\р\о\в\к\у\ \н\а\ч\и\н\а\е\м\ \с\о\ \в\т\о\р\о\г\о\ \э\л\е\м\е\н\т\а\,\ \т\.\к\.\ \с\ч\и\т\а\е\т\с\я\,\ \ч\т\о\ \п\е\р\в\ы\й\ \э\л\е\м\е\н\т\ \у\ж\е\ \о\т\с\о\р\т\и\р\о\в\а\н
					    item_to_insert = nums[i]
					    j = i - 1 \С\о\х\р\а\н\я\е\м\ \с\с\ы\л\к\у\ \н\а\ \и\н\д\е\к\с\ \п\р\е\д\ы\д\у\щ\е\г\о\ \э\л\е\м\е\н\т\а
					    while j >= 0 and nums[j] > item_to_insert: \Э\л\е\м\е\н\т\ы\ \о\т\с\о\р\т\и\р\о\в\а\н\н\о\г\о\ \с\е\г\м\е\н\т\а\ \п\е\р\е\м\е\щ\а\е\м\ \в\п\е\р\ё\д\,\ \е\с\л\и\ \о\н\и\ \б\о\л\ь\ш\е\ \э\л\е\м\е\н\т\а\ \д\л\я\ \в\с\т\а\в\к\и
					        nums[j + 1] = nums[j]
					         j -= 1
					nums[j + 1] = item_to_insert \В\с\т\а\в\л\я\е\м\ \э\л\е\м\е\н\т
			\.
		<mark style="background: #CACFD9A6;">Timsort - стандартная сортировка метода .sort()</mark> O (N logN)
			Алгоритм построен на той идее, что в реальном мире сортируемый массив данных часто содержат в себе упорядоченные (не важно, по возрастанию или по убыванию) подмассивы. На таких данных Timsort работает максимально быстро. Изобретен был в 2002 году Тимом Петерсом.
			Timsort сначала анализирует список, который он пытается отсортировать, и на его основе выбирает наилучший подход. Это гибрид метода сортировки слияним и сортировкой вставками
			Принцип работы:
				1. Делит массив на подмассивы (run, раны)
				2. Сортируем каждый подмассив (run) вставками
				3. Отсортированные подмассивы слиянием собираемый в единый массив
			Размер подмассива run - от 32 до 64 - так Тим сказал
			\.
		<mark style="background: #CACFD9A6;">Merge Sort - сортировка слиянием</mark> O (N logN)
			Исходный массив делится на две примерно равные части. Если массив имеет нечетное количество элементов, одна из этих «половин» на один элемент больше, чем другая.
			Подмассивы делятся снова и снова на две половины, пока вы не получите массивы, которые имеют только один элемент каждый.
			Затем вы объединяете пары одноэлементных массивов в двухэлементные массивы, сохраняя их в процессе. Затем эти отсортированные пары объединяются в четырехэлементные массивы и так далее до тех пор, пока не будет получен исходный отсортированный массив.
			Тот факт, что массив не может быть разделен на равные половины, не является проблемой, 1 просто «ждет», пока не начнется сортировка.
			\.
			Реализация алгоритма Merge Sort 
				import operator
				def merge_sort(L, compare=operator.lt):
				    if len(L) < 2:
				        return L[:]
				    else:
				        middle = int(len(L) / 2)
				        left = merge_sort(L[:middle], compare)
				        right = merge_sort(L[middle:], compare)
				        return merge(left, right, compare)
				def merge(left, right, compare):
				    result = []
				    i, j = 0, 0
				    while i < len(left) and j < len(right):
				        if compare(left[i], right[j]):
				            result.append(left[i])
				            i += 1
				        else:
				            result.append(right[j])
				            j += 1
				    while i < len(left):
				        result.append(left[i])
				        i += 1
				    while j < len(right):
				        result.append(right[j])
				        j += 1
				    return result
			\.
		<mark style="background: #CACFD9A6;">Quick Sort - быстрая сортировка Хоара</mark> O (N logN)
			Суть работы алгоритмы
				1.  Выбрать опорный элемент из массива. Обычно опорным элементом является средний элемент.
				2.  Разделить массив на два подмассива: элементы меньше опорного и элементы больше опорного.
				3.  Рекурсивно применить сортировку к двум подмассивам. Рекурсия заканчивается, когда длина возвращаемого подмассива равна 0
			Реализация алгоритма Quick Sort
				def quicksort(nums)
				    if len(nums) < 2: 
				        return nums
				    else:
				        mirror = nums[0] 
				        less = [i for i in nums[1:] if i <= mirror] 
				        greater = [i for i in nums[1:] if i > mirror] 
				        return quicksort(less) + [mirror] +quicksort(greater)
		\.
	<mark style="background: #ABF7F7A6;">Searching Algorithms - алгоритмы поиска</mark>:
		<mark style="background: #CACFD9A6;">Линейный поиск</mark> O (N)
			Суть алгоритма заключается в том , чтобы перебрать массив и вернуть индекс первого вхождения элемента, когда он найден
			Реализация линейного поиска:
				def LinearSearch(lys, element):
					for i in range (len(lys)):
					if lys[i] == element:
						return i
					return -1
		<mark style="background: #CACFD9A6;">Бинарный поиск</mark> O (log n)
			Требует, <mark style="background: #FFB86CA6;">чтобы массив был отсортирован</mark> перед выполнением алгоритма. Суть алгоритма заключается в том, что диапазон поиска каждый раз делится на два при поиске нужного элемента. Если искомый элемент больше текущего разделенного диапазона, тогда диапазон двигается вправо. Если меньше - то влево. При этом к двигающейся границе прибавляется единица. И так пока не будет найден искомый элемент.
			Реализация бинарного поиска 
				def binarysearch(nums, target: int) -> int:
					    nums.sort()
					    low = 0
					    high = len(nums) - 1
					    while low <= high:
					        mid = (low + high) // 2
					        guess = nums[mid]
					        if guess == target:
					            return f'index of number is {mid} and = {guess}'
					        elif guess > target:
					            high = mid - 1
					        elif guess < target:
					            low = mid + 1
					    return 'not found'
			\.
		<mark style="background: #CACFD9A6;">Jump search</mark> O(√n)
			Требует, чтобы массив был отсортирован перед выполнением алгоритма. Это усовершенствованный алгоритм линейного поиска, поскольку он зависит от линейного поиска для выполнения фактического сравнения при поиске значения. Поиск по элементам массива происходит скачкообразно. Промежуток прыжка расчитывается как корень из длины массива. После быстрого нахождения промежутка (прыжка), где мог бы находиться искомый элемент, поиск начинается уже в длине корень из длины массива.
			Реализация Jump Search
				import math
				def JumpSearch (lys, val):
					length = len(lys)
					jump = int(math.sqrt(length))
					left, right = 0, 0
					while left < length and lys[left] <= val:
						right = min(length - 1, left + jump)
						if lys[left] <= val and lys[right] >= val:
							break
						left += jump;
					if left >= length or lys[left] > val:
							return -1
					right = min(length - 1, right)
					i = left
					while i <= right and lys[i] <= val:
						if lys[i] == val:
							return i
						i += 1
					return -1
			\.
		<mark style="background: #CACFD9A6;">Поиск Фибоначчи</mark>  O(log n)
			Требует, чтобы массив был отсортирован перед выполнением алгоритма. 
			Он получил свое название потому, что использует числа фибоначи для вычисления размера блока или диапазона поиска на каждом шаге. Работает как Jump Search, только длина прыжка это сумма предыдущих двух элементов.
			Реализация поиска Фибоначчи
				def FibonacciSearch(lys, val):
					fibM_minus_2 = 0
					fibM_minus_1 = 1
					fibM = fibM_minus_1 + fibM_minus_2
					while (fibM < len(lys)):
						fibM_minus_2 = fibM_minus_1
						fibM_minus_1 = fibM
						fibM = fibM_minus_1 + fibM_minus_2
					index = -1;
					while (fibM > 1):
						i = min(index + fibM_minus_2, (len(lys)-1))
						if (lys[i] < val):
							fibM = fibM_minus_1
							fibM_minus_1 = fibM_minus_2
							fibM_minus_2 = fibM - fibM_minus_1
							index = i
						elif (lys[i] > val):
							fibM = fibM_minus_2
							fibM_minus_1 = fibM_minus_1 - fibM_minus_2
							fibM_minus_2 = fibM - fibM_minus_1
						else :
							return i
					if(fibM_minus_1 and index < (len(lys)-1) and lys[index+1] == val):
						return index+1
					return -1
			 \.

25 - Python задачи
	Наследование в ООП:
		Наследование класса позволяет определить реализацию одного класса в терминах другого.
		Плюсы: 
			- избавляет от дублирования
			- ускоряет разработку
			- возможности расширения классов
		Минусы:
			- Считается, что наследование может нарушить инкапсуляцию, так как дочернему классу доступны для реализации методы родительского класса.
			- Если мы изменяем родительский класс, то придется изменить и все дочерние
			- перегруженность (цепочка из 20 наследований)
		Альтернатива ООП:
			==Композиция объектов== - это альтернатива наследованию класса. В этом случае новую, более сложную функциональность мы получаем путем объединения или композиции объектов. Для композиции требуется, чтобы объединяемые объекты имели четко определенные интерфейсы.
	Python.
		Высокоуровневый язык программирования общего назначения с неявной динамической строгой типизацией и автоматическим управлением памятью
	\.
	<mark style="background: #ABF7F7A6;">Задача 1</mark>:
		Постановка: обменяться строками произвольной длины между двумя переменными 
		Условие: без создания третьей переменной (буфера)
		Дано: 
		- first = "Первое предложение произвольной длины."
		- second = "Второе предложение произвольной длины."
		\.
		Решение 1:
			Через питонячий обмен
			first, second = second, first
		\.
		Решение 2:
			Через .replace()
			first = first + second
			second = first.replace(second, "")
			first = first.replace(second, "")
	\.
	<mark style="background: #ABF7F7A6;">Задача 2</mark>:
		Постановка: сделать так, чтобы когда в функцию подают число - она его сохраняла. И когда подают пустоту (вызывают функцию без аргументов) она возвращала сумму сохраненных чисел
		Условие: -
		Дано: 
		- chain_sum(2)(1)() #3
		- chain_sum(2)(-2)() #0
		\.
		Решение 1: замыкание
		def chain_sum(n):
	  	memory = n
			def inner(k: int | None = None):
		      nonlocal memory
		      if k is None:
		    	return memory
		      else:
		        memory += k
		        return inner
		    return inner
		\.
	<mark style="background: #ABF7F7A6;">Задача 3</mark>: рабоче-крестьянское умножение
		\.
		Решение: 
		def foo(x, y):
		  res = 0
		  while x > 0:
		    if x % 2 != 0:
		        res += y
		    y = y * 2
		    x  = x // 2
		  return res
		\.
	<mark style="background: #ABF7F7A6;">Задача 4</mark>: словари
		Дано: 
		есть словарь:
		d1 = {'a': 1, 'b': {'c': 2, 'd': {'e': 3}}, 'f': {'g': 4}}
		нужно привести к виду:
		d2 = {'a': 1, 'b.c': 2, 'b.d.e': 3, 'f.g': 4}
		\.
		Решение: рекурсия
			def foo(my_dict, previous_key=""):
			  res = {}
			  for key, value for my_dict.items():
			    if isinstance(value, int):
			      res[key] = value
			    else:
			      res.update(foo(value, previous_key=key))
			  return res
# DataBases
26 - SQL
	Реляционная БД - <mark style="background: #FFB86CA6;">это база данных, которая реализует констрейн внешнего ключа, связаывая записи одной таблицы с другой.</mark>
	\.
	<mark style="background: #ABF7F7A6;">Типы связей таблиц</mark>:
		OneToOne - тип связи между двумя таблицами, <mark style="background: #ADCCFFA6;">одна запись связана с одной записью другой таблицы.</mark>
		\.
		ManyToMany - несколько значений одной таблицы, может соответствовать нескольким значениям другой таблицы. <mark style="background: #ADCCFFA6;">И эта связь между двумя таблицами представлена в третьей, промежуточной.</mark>
		\.
		OneToMany - <mark style="background: #ADCCFFA6;">одна запись из одной таблицы может соответствовать нескольким записям из другой таблицы</mark>. Обычный foreign key.
	\.
	<mark style="background: #ABF7F7A6;">Основные команды в SQL</mark>:
		Все команды SQL --> ссылка:
			http://citforum.ru/programming/32less/les44.shtml
		\.
		DDL — язык определения данных (Data Definition Language)
		- CREATE \[TABLE\] - создать таблицу
		- ALTER \[TABLE\] - изменить существующую таблицу
		- DROP - удалить таблицу
		- TRUNCATE \[TABLE\] - полная очистка таблицы
		- DELETE FROM \[TABLE\] WHERE condition - удаление запсией соответствующих условию
		\.
		DML — язык изменения данных (Data Manipulation Language)
		- SELECT column FROM \[TABLE\] - извлечь данные из таблицы
		- INSERT INTO \[TABLE\] values- создать запись
		- UPDATE \[TABLE\] SET column_name = value WHERE condition - изменить запись
		- DELETE - удалить запись
		\.
		DCL  — язык управления данными (Data Control Language)
		- GRANT - наделяет пользователя правами
		- REVOKE - отменяет права пользователя
		\.
		TCL — язык управления транзакциями (Transaction Control Language)
		- BEGIN TRANSACTION - объявляет начало транзакции
		- COMMIT TRANSACTION - применяет транзакцию
		- ROLLBAK TRANSACTION - откат изменений текущей транзакции
		- SAVE TRANSACTION - установка промежуточной точки сохранения внутри транзакции
		\.
		SQL LIMIT & OFFSET
			Вовзращает ограниченное количество записей (LIMIT) но с каким-то смещением (OFFSET). Типа лимит 5 смещение 3, вернет не 1-5 записи, а 3 - 8 записи.
		\.
		SQL ORDER BY
			Изменяет порядок, в котором возвращаются элементы в запросе по какому то столбцу. Например сортировка в алфавитном порядке и тд. Пример запроса: 
			SELECT * FROM Customers ORDER BY City.
		\.
		SQL GROUP BY
			Собирает группы записей по какому-то объединяющему признаку
			SELECT COUNT(\*), City, Country
			FROM Customers
			GROUP BY Country, City
			--> в таком запросе получим просто объединения людей и стран/городов где они живут. Тело ответа будет не отсортированно.
		\.
		VACUUM - дефрагментация БД
			Рядом с файлом таблицы в PGDATA лежат файлы FSM (Free Space Map). И при всяком удалении или обновлении таблицы эти FSM файлы не обновляются и просто занимают память. VACUUM нужен для очистки таких файлов.
			\.
			VACUUM <mark style="background: #FFB86CA6;">не возвращает память операционной системе, а просто помечает конкретные отрезки памяти как такие, которые можно переписать.</mark>
			\.
			VACUUM - очищает "дохлые" версии строк.
			\.
			VACUUM \[FULL\] производит перезапись всей таблицы и по сути делает дефрагментацию памяти. Это долго и ресурсно затратно, поэтому такое делается редко.
			\.
			Если не обслуживать БД, то фрагментация данных будет нарастать. 
			\.
			<mark style="background: #BBFABBA6;">Советы для VACUUM</mark>:
			- необходим периодический запуск VACUUM, для часто обновляемых БД - каждую ночь
			- VACUUM FULL выполнять только если удалили много данных
			\.
			VACUUM ANALYZE - собирает статистику для выполнения наиболее качественного VACUUM. 
			\.
			Однако VACUUM может нарушать индексы. 
			\.
			<mark style="background: #BBFABBA6;">Преимущества VACUUM</mark>:
			- оптимизирует дисковое простанство базы данных
			- ускоряет работу БД за счет сжимания файлов
			\.
			<mark style="background: #FFB86CA6;">Autovacuum daemon - по дефолту работающий VACUUM, который работает для всех таблиц по умолчанию</mark>.
		\.
		SELECT DISTINCT column FROM \[TABLE\]
			Вернет все уникальные значения из указанных столбцов
		\.
		<mark style="background: #ABF7F7A6;">Пост-фильтрация HAVING</mark>:
			<mark style="background: #FFB86CA6;">WHERE & HAVING - одно и тоже. Только WHERE - первичный фильтр. HAVING - вторичный фильтр</mark>.
			\.
			Задача: 
				Хотим посчитать сумму товаров по одной из категорий и вывести те категории, где сумма больше 5000:
				\.
				SELECT category_id, SUM( unit_price \* unit_in_stock)
				FROM products
				WHERE discontinued <> 1
				GROUP BY category_id
				<mark style="background: #FFF3A3A6;">HAVING</mark> SUM( unit_price \* unit_in_stock) > 5000
				ORDER BY SUM( unit_price \* unit_in_stock)
	\.
	<mark style="background: #ABF7F7A6;">Объекты PostgreSQL </mark>| Сервера и базы данных
		Серверная служба
			Создание виртуального сервера Postgres с портами на физическом сервере
		\.
		Базы данных (БД)
			База данных - это контейнер для объектов типа таблиц, индексов. На сервере ограничений по созданию баз нет
		\.
		Таблицы
			Таблицы используются для хранения данных. В одной БД может быть много таблиц.  В PostgreSQL таблицы могут наследоваться друг от друга, поэтому дочерние таблицы при запросе также могут быть отображены.
		\.
		Схемы <mark style="background: #FF5582A6;">(! ! !)</mark>
			Схема — <mark style="background: #FFB86CA6;">это пространство имён для объектов внутри базы данных.</mark>. 
			\.
			Суть работы схемы можно представить так: мы все складываем не все в одну большую кучу, а по небольшим отдельным кучкам. Например, как в файловой системе, всё кладем не в один каталог, а раскладываем по подкаталогам.
			Вот пример работы со схемами! В одну схему поместим объекты для модуля “логистика”, а в другую для модуля “финансы” и так далее.
			\.
			В postgres по умолчанию создаются схемы:
			- <mark style="background: #FFF3A3A6;">pg_catalog</mark> -   служебная схема (**системный каталог**), присутствует во всех базах данных, например там находится представление **pg_tables**
			- <mark style="background: #FFF3A3A6;">public</mark> - общая схема, присутствует во всех базах данных и по умолчанию все объекты создаются в ней.
		\.
		Представления (<mark style="background: #FFB86CA6;">Views</mark>)
			Представление - это виртуальная таблица которая используется для упрощения сложных запросов и обеспечения безопасности для набора записей.
		\.
		Функции 
			Функция — это многократно используемый блок кода SQL, который возвращает скалярное значение списка записей. В PostgreSQL функции также могут возвращать составные объекты.
		\.
		Пакеты | Package <mark style="background: #FF5582A6;">(! ! !)</mark>
			Пакет - это по сути схема, которая помогает организовать взаимосвязанные именованные объекты, поэтому его можно создать как обычной командой <mark style="background: #FFF3A3A6;">CREATE SCHEMA</mark>, так и специальной командой <mark style="background: #FFF3A3A6;">CREATE PACKAGE</mark> 
			<mark style="background: #FFB86CA6;">Однако пакет может содержать только функции, процедуры и составные типы</mark>.
			 Он обеспечивает логическую структуру для организации программ и других элементов: курсоров, типов данных и переменных. 
		\.
		Window functions в SQL | Аналитическая функция <mark style="background: #FF5582A6;">(! ! !)</mark>
			Оконные функции - что-то вроде подгруппы записей или раздела. <mark style="background: #ADCCFFA6;">Это набор записей, на которые будет смотреть функция при вычислении. Оконные функции выполняют свои операции только над какими-то выделенными записями. </mark>
			\.
			Мы можем сначала сделать запрос, а уже потом как-то по результатам этого запроса сделать вторым шагом анализ. Однако благодаря оконным функциям мы можем сделать какие-то вычисления сразу по ходу выполнения запроса.
			\.
			Сначала сделаем обычный селект:
			<mark style="background: #CACFD9A6;">SELECT order_id, order_date, order_total</mark>\.
			SUM(order_total) OVER ( <-- добавляем оконную функцию, ключевое слово OVER
				\P\A\R\T\I\T\I\O\N\ \B\Y\ \-\-\>\ \д\л\я\ \р\а\с\ч\е\т\а\ \р\а\з\ \в\ \м\е\с\я\ц\ \н\а\п\р\и\м\е\р\. \Н\о\ \в\ \э\т\о\м\ \п\р\и\м\е\р\е\ \б\е\з\ 
				\н\е\е\ \б\у\д\е\м\. %% Но если надо, то указываем столбец в рамках уникальности которого будет производится вычисление. Уникальность даты например. 
				2023-04-03 - оконная функция все посчитает для этой даты, а потом при 2023-05-03 уже будет расчет вестись заново %%
				ORDER BY order_id ASC <-- тело оконной функции, считаем 
			) <mark style="background: #FFF3A3A6;">AS running_total </mark> <-- даем название столбцу нашей оконной функции
			FROM orders
			ORDER BY order_id ASC
			\.
			Результат: 
					![[Pasted image 20230212121325.png]]Теперь видно, что по мере выполнения запроса наш новый столбец, представленный оконной функцией, с каждым шагом суммирует стоимость предыдущего заказа.
	\.
	<mark style="background: #ABF7F7A6;">Индексы SQL</mark>:
		Индекс – <mark style="background: #ADCCFFA6;">это структура данных, ускоряющая выборку данных из таблицы за счет дополнительной записи и дополнительного пространства на диске</mark> для хранения структуры данных и поддержания её в актуальном состоянии.
		\.
		<mark style="background: #D2B3FFA6;">Индекс</mark> - <mark style="background: #FFB86CA6;">это структура данных, ускоряющая выборку данных</mark>
		\.
		<mark style="background: #FFF3A3A6;">Когда не стоит использовать индексы</mark><mark style="background: #FFF3A3A6;">?</mark>
			- Если БД с небольшим количеством строк в таблицах
			- В таблицах, где часто происходят операции UPDATE, INSERT
			- В таблицах, где много столбцов с NULL значениями
		\.
		Немного об устройстве хранения данных в БД:
			-> Database cluster - сервер, управляющий БДшками
			-> Файлы данных сервера (или кластера) хранятся в директории PGDATA
			-> в PGDATA хранятся различные низкоуровневые данные, в том числе и индексы.
			-> Для каждой таблицы или индекса выделяется новый файл до 1 гб.
		\.
		Основная суть индексов - <mark style="background: #ADCCFFA6;">возвращать нужные данные без полного перебора записей</mark>. Возвращать данные по некоторому ключу или информации об этом ключе, которая будет храниться в самом индексе.
		\.
		<mark style="background: #D2B3FFA6;">Индекс (метод доступа)</mark> – это объект БД, который можно создать и удалить. Индекс создает соответствие между ключом и строками таблицы, где этот ключ встречается.
		\.
		По **PRIMARY KEY** и **UNIQUE** столбцам индекс создается автоматически. Для построения такого индекса используется balanced tree (**B-TREE O(logN)** ).
		\.
		**Индексы не бесплатны и требуют ресурсов на свое содержание.** При любой операции над проиндексированными данными — будь то **вставка**, **удаление** или **обновление** строк таблицы, — индексы, созданные для этой таблицы, должны быть перестроены, причем в рамках **той же транзакции**.
		\.
		Однако обновление полей таблицы, по которым не создавались индексы, не приводит к перестроению индексов; этот механизм называется HOT (Heap-Only Tuples).
		\.
		<mark style="background: #ABF7F7A6;">Виды индексов</mark>:
		- Доступные индексы на сервере можно посмотреть через
		  <mark style="background: #FFF3A3A6;">SELECT amname FROM pg_am</mark>\.
		- B-tree (сбалансированное дерево)
		- Hash-index
		- GiST (обобщенное дерево поиска) 
		- GIN (обобщенный обратный индекс)
		- SP-GiST (GiST с двоичным разбиением пространства)
		- BRIN (блочно-диапазонный)
		\.
		<mark style="background: #ABF7F7A6;">Практическое использование индексов</mark>:
			1. B-tree O(logN) 
			    Создается по умолчанию. 
			    <mark style="background: #FFF3A3A6;">CREATE INDEX</mark> _index\_name_ <mark style="background: #FFF3A3A6;">ON</mark> _table\_name_ (_columns\_name_)
				\.
				- cоздается по умолчанию в UNIQUE & PRIMARY KEY 
				- Поддерживает сравнения: <, >, <=, >=, =
				- Поддерживает LIKE "abc%" (но не "%abc")
				- Индексирует NULL (можно проверить IS NULL)
				\.
			2. Hash-index O(1)
			    <mark style="background: #FFF3A3A6;">CREATE INDEX</mark> _index\_name_ <mark style="background: #FFF3A3A6;">ON</mark> _table\_name_ <mark style="background: #FFF3A3A6;">USING HASH</mark> (_columns\_name_)
			    \.
			    - Поддерживает только =
			    - Быстрее B-tree, однако сильно проигрывает из-за ограничений
			    - Не отображается в журнале предзаписи (WAL). При сбое придется делать REINDEX, ведь WAL нужен для бэкапа, а hash-index в этот бэкап не записывается.
				\.
			3. GiST - обобщенное дерево поиска
			   Применяется для индексации текстовых и геометрических типов данных для организации полнотекствого поиска.
			   <mark style="background: #FFB86CA6;">Полнотекстовый поиск — это поиск по всему содержимому документа, а не по определённым атрибутам</mark>.
			   \.
			   GiST - в отличие от B-tree индекса, который умеет сравнивать только строгие значения (цифры, строки и тд.), «generalized search tree» умеет сравнивать также и такие вещи как геоданные, картинки, документы. Если простыми словами, то:
			   GiST - <mark style="background: #ADCCFFA6;">это сбалансированное дерево, листья которого содержит некое логическое выражение и ссылку на строку таблицы (Tuple ID)</mark>, где проиндексированные данные должны следовать этому <mark style="background: #ADCCFFA6;">логическому выражению</mark>
			   \.
			   - занимает меньше места, чем GIN
			   \.
			4. GIN - обобщенный обратный
			   Применяется для индексации массивов или наборов значений. Нужен для построения сложного полнотекствого поиска.
			   \.
			   <mark style="background: #FFB86CA6;">Индекс GIN состоит из Balanced-дерева элементов, к листовым записям которого привязаны B-деревья или плоские списки Tuple ID</mark>.
			   \.
			5. SP-GiST - GiST с двоичным разбиением пространтсва
			  <mark style="background: #FFB86CA6;"> Используется для набора данных, которые представляют естественную упорядоченность, но не являются сбалансированными</mark>.
			  \.
			   Пример: телефонные номера, которые кластеризуются по странам. То есть стран условно 70, а телефонных номеров 8 миллиардов. Для таких случаев применяется этот индекс.
			  \.
			6. BRIN - блочно-диапазонный 
			  <mark style="background: #FFB86CA6;"> Полезен на ОГРОМНЫХ наборах данных, которые подразумевают естественную упорядоченность.</mark> Например почтовые индексы или timestamp\`ы, например котировки ценных бумаг.
		\.
		<mark style="background: #ABF7F7A6;">Методы сканирования</mark>:
			- За выбор методов сканирования отвечает <mark style="background: #FFF3A3A6;">ОПТИМИЗАТОР</mark>
			- <mark style="background: #FFF3A3A6;">Индексное сканирование (index scan)</mark> - просмотр проиндексированных данных
			- <mark style="background: #FFF3A3A6;">Исключительно индексное сканирование (index only scan)</mark> - если индекс хранит не только ключи, но и сами данные, то включится этот метод сканирования
			- <mark style="background: #FFF3A3A6;">Сканирование по битовой карте (bitmap scan)</mark> - алгоритм, позволяющий читать данные только <mark style="background: #FFB86CA6;">ОДИН РАЗ</mark>. Включается планировщиком, если нужно прочесть достаточно много данных, но не включая обычное и медленное последовательное сканирование.
			- <mark style="background: #FFF3A3A6;">Последовательное сканирование (sequential scan)</mark> - чем меньше строк удовлетворяет запросу, тем эффективнее данных метод сканирования. Обычный перебор.
			\.
			В связи с тем, что мы не можем строить индексы просто так и без причины, так как нам надо сначала понять, какой индекс строить, существует EXPLAIN \[ANALYZE\]
			\.
			<mark style="background: #FFF3A3A6;">EXPLAIN</mark> _query_ - где _query_ какой-то запрос на SQL.
			EXPLAIN позволяет посмотреть на предположительный план выполнения запроса 
			<mark style="background: #FFF3A3A6;">EXPLAIN ANALYZE</mark> _query_ - прогоняет запрос, показывает план и реальность
			\.
	\.
	<mark style="background: #ABF7F7A6;">Конструкция WITH . . . AS </mark>| Обощенное табличное выражение CTE
		CTE (Common Table Expression) - это временный результирующий набор данных, к которому можно обращаться при последующих запросах. <mark style="background: #FFB86CA6;">Это что-то типа labmda функции, которую вызывают единожды.</mark>
		\.
		Пример SQL запроса:
		WITH <mark style="background: #FFF3A3A6;">Aeroflot_trips</mark> AS
		    (SELECT TRIP.* FROM Company
		        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
		\.
		SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;
		\.
		Результатом будут все самолеты компании Аэрофлот, которые удовлетворяют <mark style="background: #FFF3A3A6;">Aeroflot_trips</mark>
	\.
	<mark style="background: #ABF7F7A6;">Нормализация баз данных</mark>:
		Нормализация - <mark style="background: #FFB86CA6;">это процесс удаления избыточных данных</mark>
		\.
		<mark style="background: #FF5582A6;">Избыточность данных приводит к</mark>:
		 - Медленной работе БД
		 - Возникновению ошибок
		 - Делает управление данными БД неудобным
		 \.
		Избыточность данных - <mark style="background: #FFB86CA6;">это когда одни и те же данные хранятся в нескольких местах базы.</mark>
		\.
		<mark style="background: #BBFABBA6;">Нормализация нужня для</mark>:
			- Устранения аномалий
			- Повышения производительности
			- Повышения удобства управления данными
		\.
		На практике обычно достаточно привести БД <mark style="background: #FFB86CA6;">к третьей нормальной форме</mark>, так как она обеспечивает достаточную производительность и обеспечивает достаточно строгую нормализацию, устраняя аномалии
		\.
		Декомпозиция - процесс разбиения одного отношения (таблицы) на несколько. По сути делигирование данных 
		\.
		<mark style="background: #ABF7F7A6;">Первая нормальная форма</mark>:
			Таблицы должны соответствовать реляционной модели данных и соблюдать принципы такие как:
			- Без дублирующих строк
			- В каждой ячейке хранится одно значение (атомарное, не составное)
			- В одном столбце один тип данных
			- Отсутствуют массивы и списки в любом виде
			\.
			Вывод: <mark style="background: #FFB86CA6;">данные должны быть простыми, не составными, в одном столбце один тип данных</mark>
		\.
		<mark style="background: #ABF7F7A6;">Вторая нормальная форма</mark>:
			Таблица должна находиться в первой форме.
			Таблица должна иметь правильный ключ, по которому можно идентифицировать каждую строку. 
			\.
			- Таблица должна иметь ключ
			- Все неключевые столбцы должны зависеть от полного ключа
			\.
			Ключ - это столбец, по которому можно гарантированно отличить строки друг от друга. 
			\.
			Вывод: <mark style="background: #FFB86CA6;">должен быть PRIMARY KEY</mark>
		\.
		<mark style="background: #ABF7F7A6;">Третья нормальная форма</mark>:
			Таблица должна находиться во второй форме.
			В таблицах должна отсутствовать <mark style="background: #FF5582A6;">транзитивная зависимость.</mark>
			\.
			<mark style="background: #FF5582A6;">Транзитивная зависимость</mark> - <mark style="background: #FFB86CA6;">это зависимость между неключевыми столбцами.
			Неключевые столбцы не должны пытаться играть роль ключа в таблице.</mark>
			\.
			Вывод: <mark style="background: #FFB86CA6;">данные должны быть привязаны не друг к другу, а к PRIMARY KEY</mark>
			\.
			Также разделяют еще третью усиленную форму (Бойса-Кодда), которая заключается в выносе зависимостей в отдельную таблицу. Например есть зависимость ID ПОЛЬЗОВАТЕЛЯ - ТЕЛЕФОН  - СТРАНА КОДА НОМЕРА (+7, +1 и тд). Так вот. Можно вынести в отдельную таблицу ТЕЛЕФОН и ID СТРАНЫ КОДА НОМЕРА. 
		\.
		<mark style="background: #CACFD9A6;">Четвертная нормальная форма</mark>:
			В таблице не должно быть ==многозначных зависимсотей.== (OneToMany прям в одной таблице, так быть не должно)
			Многозначная зависимость возникает, когда наличие одной или нескольких строк в таблице подразумевает наличие одной или нескольких других строк в этой же таблице. Другими словами, два атрибута (или столбца) в таблице не зависят друг от друга, но оба зависят от третьего атрибута.
		\.
		<mark style="background: #CACFD9A6;">Пятая нормальная форма</mark>:
			Проекционно-соединительная нормальная форма. Отношения находятся в пятой форме, если нет ==сложных зависимостей.== Типа Атрибут_1 зависит от Атрибута_2, а Атрибут_2 зависит от Атрибиут_3, а Атрибут_3 зависит от Атрибут_1. Это неправильно. Нужна декомпозиция без потерь.
			Например, есть 2 таблицы, при декомпозиции которых мы можем потерять некоторые данные. Но при декомпозиции на 3 таблица потери данных можно избежать. 
			Чтобы привести таблицу к пятой форме необходимо проводить декомпозиции без потерь при устранении нетривиальных зависимостей.
		\.
		<mark style="background: #CACFD9A6;">Доменно-ключевая нормальная форма</mark>:
			Ограничение домена - короче есть некоторый домен (набор значений). И вот этот набор значений (домен) мы должны использовать для назначения значений определенному атрибуту. 
			Ограничение ключа - некоторая комбинация атрибутов представляет из себя ключ
			\.
			Каждое наложенное ограничение на таблицу должно являться логическим следствием ограниченний доменов и ограничений ключей, которые накладываются на эту таблицу.
		\.
		<mark style="background: #CACFD9A6;">Шестая нормальная форма</mark>:
			Была введена при работа с хронологическими БД.
			\.
			Хронологическая БД - это база, которая может хранить не только текущие данные, но и исторические данные прошлого. А может хранить и данные, относящиеся к будущим периодам времени. 
			\.
			Таблица должна удовлетворять всем нетривиальным зависимостям соединения.
	\.
	<mark style="background: #ABF7F7A6;">ACID</mark> - **Atomacity, Consistency, Isolation, Durability**
		\.
		Следование требованиям ACID обеспечивает надежную и предсказуемую работу транзакционных систем.
		==A - Atomacity (Атомарность)==
			Атомарность гарантирует, что каждая **транзакция** будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.
			\.
			<mark style="background: #FFB86CA6;">Транзакция — это архив для запросов к базе.</mark> Суть транзакции: данные либо будут доставлены успешно, либо не будут доставлены вовсе, будет rollback в первичное состояние.
			\.
		==C - Consistency (Согласованность)==
			Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных.
			\.
			<mark style="background: #FFB86CA6;">Не должно быть висящих, не прикрепленных в никуда данных</mark>.
			\.
		==I - Isolation (Изолированность)==
			Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
			\.
			<mark style="background: #FF5582A6;">Аномалии при нарушении изоляции транзакций</mark>:
			- **к потери записи**
			- **к грязному чтению**
			- **к повторимому чтению**
			- **к появлению фантомов**
			\.
		==D - Durability (Надежность)==
			Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.
	\.
	<mark style="background: #ABF7F7A6;">Уровни изоляции транзакций</mark>:
		Изолированность нужна, чтобы избежать появления аномалий.
		\.
		Это уровни изоляции от самого неизолированного и производительного, до самого изолированного и наименее производительного. При проектировке БД следует учитывать этот баланс. 
		\.
		<mark style="background: #FFF3A3A6;">Read uncommitted</mark>:
		Каждая <mark style="background: #FFB86CA6;">транзакция видит незафиксированные изменения другой транзакции</mark> (феномен **грязного чтения**). 
		\.
		<mark style="background: #FFF3A3A6;">Read committed</mark>:
		<mark style="background: #FFB86CA6;">по дефолту стоит в PostgreSQL.</mark> Для этого уровня параллельно исполняющиеся <mark style="background: #FFB86CA6;">транзакции видят только зафиксированные изменения из других транзакций</mark>. Таким образом, данный уровень обеспечивает защиту от **грязного чтения**. 
		\.
		<mark style="background: #FFF3A3A6;">Repeatable read</mark>:
		Уровень, позволяющий предотвратить феномен **неповторяющегося чтения**. <mark style="background: #FFB86CA6;">Видим вставленные записи другой транзакции, но измененные или удаленные не видим.</mark>  **Чтение фантомов** никуда не уходит.
		\.
		<mark style="background: #FFF3A3A6;">Serializable</mark>:
		Уровень, при котором транзакции ведут себя как будто ничего более не существует, <mark style="background: #FFB86CA6;">никакого влияния друг на друга нет.</mark> В классическом представлении этот уровень избавляет от эффекта **чтения фантомов**.
	\.
	<mark style="background: #ABF7F7A6;">Виды соединений</mark> <mark style="background: #FFB86CA6;">(JOINS)</mark>:
			![[Pasted image 20230212124227.png]]\.
			1. RIGHT/LEFT JOIN - возвращает <mark style="background: #ADCCFFA6;">все строки из таблицы куда присоединяет</mark>, и возвращает только те строки из другой таблицы, в которых выполняется условие.
				\.
				SELECT columns  
				FROM table1  
				LEFT JOIN table2  
				ON table1.column = table2.column;
			2. FULL JOIN - вернет все строки из таблицы куда присоединяет и откуда присоединяет. Если условие присоединения не выполняется, то поставит _NULL_
				\.
				SELECT columns  
				FROM table1  
				FULL JOIN table2  
				ON table1.column = table2.column;
				\.
			3. SELF JOIN -  полезен в тех случаях, когда необходимо выполнить фильтрацию контента внутри одной таблицы. Например, у вас есть список товаров в базе данных. У каждого из них указан свой бренд, но есть и те, что поставляются одним производителем. Self Join можно использовать для объединения двух стеков информации из одной таблицы.
				\.
				SELECT *
				FROM products JOIN products ON table.product=table.brand
				\.
			4. INNER JOIN -  возвращает все строки из нескольких таблиц, где выполняется условие соединения. Короче возвращает, что найдет по заданному условию
				\.
				SELECT columns  
				FROM table1  
				INNER JOIN table2  
				ON table1.column = table2.column;
				\.
			5. NATURAL JOIN - соединяет таблицы с одинаковыми названиями в них.
				\.
				SELECT a.pid, a.lname, a.fname, b.name 
				FROM person a NATURAL JOIN gruppa b;
				\.
			6. CROSS JOIN - Результатом такого соединения будет объединение каждой строки первой таблицы с каждой строкой второй таблицы.
			   \. 
				SELECT поля_таблиц
				FROM таблица_1
				CROSS JOIN таблица_2;
				\.
	\.
	<mark style="background: #ABF7F7A6;">Тригеры в SQL</mark>:
		Триггер - хранимая в памяти БД инструкция, выполняющая часть кода при наступлении события <mark style="background: #FFF3A3A6;">UPDATE</mark>, <mark style="background: #FFF3A3A6;">DELETE</mark> или <mark style="background: #FFF3A3A6;">INSERT</mark>.
		\.
		Нужны для:
		- Отслеживания тарнзакций, регистрируя сведения о событии
		- Проверка ограничений перед преминением тарнзакции
		- Автоматическое заполнение полей
		\.
		Триггеры могут быть вызваны <mark style="background: #FFF3A3A6;">BEFORE</mark>, <mark style="background: #FFF3A3A6;">AFTER</mark> или <mark style="background: #FFF3A3A6;">INSTEAD</mark> события. 
		\.
		Ссылки в триггере:
		- INSERT - <mark style="background: #FFF3A3A6;">NEW</mark>.fieldname
		- UPDATE - <mark style="background: #FFF3A3A6;">NEW</mark>.fieldname & <mark style="background: #FFF3A3A6;">OLD</mark>.fieldname
		- DELETE - <mark style="background: #FFF3A3A6;">OLD</mark>.fieldname
		\.
		Пояснение: 
		Если триггер реагирует на <mark style="background: #FFF3A3A6;">INSERT</mark>, то обращаться к значению записи можно обраться только через <mark style="background: #FFF3A3A6;">NEW</mark>. При <mark style="background: #FFF3A3A6;">UPDATE</mark> можно обратиться и к <mark style="background: #FFF3A3A6;">NEW</mark>, и к <mark style="background: #FFF3A3A6;">OLD</mark>. Ну и при <mark style="background: #FFF3A3A6;">DELETE</mark> только к <mark style="background: #FFF3A3A6;">OLD</mark>. 
		\.
		Пример триггера в PostgreSQL:
		<mark style="background: #FFF3A3A6;">CREATE TRIGGER</mark> _trigger_name_ <mark style="background: #FFF3A3A6;">AFTER INSERT ON</mark> _table_name_ 
		<mark style="background: #FFF3A3A6;">FOR EACH ROW EXECUTE PROCEDURE</mark> _function_name()_ 
		\.
		_function_name()_ - функция типа триггер, которая будет запущена при наступлении события
		\.
		Создание функции:
			CREATE OR REPLACE FUNCTION _function_name()_ 
			RETURN TRIGGER
			AS \$\$
			BEGIN
				INSERT INTO _other_table(field)_ VALUES (NEW.other_field);
				RETURN NEW;
			END;
			\$\$ LANGUAGE plpgsql;
		\.
		<mark style="background: #BBFABBA6;">Или можно сразу напрямую без функции</mark>: <--  удачный вариант создания тригера
			CREATE TRIGGER _trigger_name_ AFTER INSERT ON _table_name_
			FOR EACH ROW
			BEGIN
				INSERT INTO _other_table(field)_ VALUES (NEW.other_field);
			END;
			\.
			Этот тригер будет создавать запись _other_table(field)_ после добавления данных в _table_name_ 
	\.
	<mark style="background: #ABF7F7A6;">Репликация и шардинг</mark>:
		\.
		Репликация - копирование действующей БД и распределение её на другой сервер. 
			Пример -> Сделать одну копию БД для изменения, другую копию только для чтения.
			\.
			Master-Slave-репликация:
				**Slave** сервер постоянно копирует все изменения с **Master**. С приложения на **Slave**- сервер отправляются запросы чтения данных (запросы `SELECT`). Таким образом **Master**-сервер отвечает за изменения данных, а **Slave** за чтение.
			\.
			Виды репликации:
			- <mark style="background: #FFF3A3A6;">Блочная репликация</mark>
			  Каждая операция записи выполняется не только на основном диске, но и на резервном. Таким образом тому на одном массиве соответствует зеркальный том на другом массиве, с точностью до байта повторяющий основной том
			- <mark style="background: #FFF3A3A6;">Физическая репликация</mark>
			  Изменения из WAL (write-ahead log), журнала, куда добавляются все сведения (кроме индексов) для бэкапа, автоматически применяются в другой базе (реплике), таким образом данные в реплике повторяют данные в основной базе байт-в-байт.
			- <mark style="background: #FFF3A3A6;">Логическая репликация</mark>
			  Все изменения в базе данных происходят в результате вызовов её API – например, в результате выполнения SQL-запросов.
			- <mark style="background: #FFF3A3A6;">Репликация триггерами</mark>
			  По сути резервное копирование через тригеры, так как триггеру, который вызывается при изменении каждой записи, доступны ключ этой записи, а также старые и новые значения полей.
		\.
		Шардинг - тоже самое, что и репликация, однако <mark style="background: #FFB86CA6;">взаимосвязи между копиями нет</mark>. Шардинг бывает горизонтальный и вертикальный. Шардинг нужен для распределение нагрузки на Базы Данных.
			Пример -> Есть две копии БД. Одна копия используется для регистрации новых пользователей из США, другая для пользователей из России.
		\.
		Партицирование - разбиение больших таблиц на логические части по выбранным критерием с целью повысить производительность БД. 
			Пример -> Имеется таблица с данными кодов операций и сумм, где ключевой столбец — «Дата». Представим, что данная таблица содержит много данных, и количество строк подходит к пороговому ограничению 2 млрд. при постоянном увеличении данных. Чтобы избежать переполнения таблицы, разобьем ее на партиции по ключевому полю «Дата», а именно по году
		\.
	Источники
		https://oracle-patches.com/db/sql/пакеты-в-pl-sql-предназначение-и-применение-на-практике - пакеты
		https://www.youtube.com/watch?v=xFeOVIIRyvQ - оконные функции лучшее объяснение
		https://sql-academy.org/ru/guide/operator-with - конструкция WITH . . . AS
		https://habr.com/ru/post/514500/ - про репликацию
		https://timeweb.cloud/tutorials/postgresql/postgresql-triggery-sozdanie-udalenie-primery - про триггеры
	\.
# Testing
27 - Уровни тестирования и теория
	Зачем тестировать ПО?
	- Для проверки соответствия требованиям.
	- Для обнаружение проблем на более ранних этапах разработки и предотвращение повышения стоимости продукта.
	- Повышение лояльности к компании и продукту, т.к. любой обнаруженный дефект негативно влияет на доверие пользователей.
	\.
	Методы тестирования:
	- Черный ящик
		о тестируемой системе ничего неизвестно: тестирование электронной почты, тестировщик проверяет данные на вход и проверяет доставку этих данных. Как устроена почта он не знает.
	- Серый ящик
		внутреннее устройство системы известно лишь частично: тестирование веб-сервиса, тестировщик делает запросы веб-сервису и убеждается, что он возвращает правильные ответы. Тестировщик знает как внешне выглядит система, но не знает, как это работает внутри.
	- Белый ящик
		внутренняя структура или реализация системы известна тестировщику: Тестирование ПО, тестировщик знает всю структуру проекта, даже имеет доступ исходному коду. Тестировщик может разрабатывать тесты для проверки точности и эффективности отдельных функций и того, как они интегрируются друг с другом.
	\.
	1. Компонентное тестирование | unit testing
		Этот вид тестирования выполняется на самой ранней стадии разработки программы — во время написания кода. Тест пишет программист. Тестирование без интеграции с другими компонентами/модулями.
		\.
		<mark style="background: #ABF7F7A6;">Юнит-тестирование</mark> используется для тестирования одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде.
		На уровне компонентного тестирования проще всего уловить ошибки.
		\.
		Цель unit тестирования:
		- проверка компонента (куска кода) на соответствие требованиям
		- обнаружение ошибок в коде
		- предотвращение пропуска ошибок на более высоких уровнях тестирования
		\.
		Для поддержки правильной структуры компонентных тестов есть лайфхак:
		- <mark style="background: #FFF3A3A6;">Дано</mark> - <mark style="background: #FFF3A3A6;">Когда?</mark> - <mark style="background: #FFF3A3A6;">Тогда</mark> -
	\.
	2. Интеграционное тестирование | Integration Testing
		Это тестирование, проверяющие работоспособность несколько модулей системы в целом. В тестах взаимодействия тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.
		\.
		Разница между unit & integrationg testing:
		- интеграционное тестирование проверяет взаимодействие сервисов и модулей как целых блоков
		- интеграционное тестирование - <mark style="background: #FFB86CA6;">это количественное продолжение unit тестирования</mark>
		\.
		Различают два вида интеграционного тестирования:
		- Компонентное - модули тестируются в связке, проверяется совместная работа
		- Системное - проверка целых систем. Например взаимодействие мобильного приложения и сайта.
		\.
		Цели интеграционного тестирования:
		- Проверка интерфейсов на соответствие требованиям.
		- Обнаружение ошибок в интерфейсах.
		- Предотвращение пропуска ошибок на более высокие уровни тестирования.
	\.
	3. Системное тестирование | System testing
		Это тестирование всей системы продукта. На данном этапе программа должна быть максимально приближена к конечному результату. Проверяется поведение системы с точки зрения конечного пользователя. Данный уровень тестирования включает в себя тестирование интеграции, наладки и совместной работы компонентов системы.
		\.
		Цели системного тестирования:
		- Поверка системы на соответствие требованиям
		- Обнаружение ошибок в системе
		- Убедиться, что все компоненты работают вместе корректно
	\.
	4. Приемочное тестирование | Acceptance Testing
		Приемочный уровень тестирования - это уровень тестирования программного обеспечения, который проверяет, удовлетворяет ли программное обеспечение требованиям и ожиданиям заказчика или пользователя
		\.
		Этот уровень тестирования выполняется после того, как система была выпущена и готова к выдаче заказчику или пользователю.
		\.
		Цель приемочного тестирования:
			- Убедиться, что ПО предоставляет необходимый функционал согласно требованиям заказчика
		\.
		Приемочное тестирование делится на:
		- пользовательское - проверка производится так, как будто продуктом пользуется пользователь.
		- эксплуатационное - проверка производится не с позиции пользователя, а с позиции тех, кто будет поддерживать работу программы. 
		- контрактное - если разработка ведется сторонней компанией, то различные тест-кейсы прописываются в контракте
		- бета и альфа тестирование -  тестирование используется, когда есть необходимость в получении обратной связи от пользователей. Поэтому именно они участвуют в таких проверках. <mark style="background: #ADCCFFA6;">Отличие альфа-тестирования от бета-тестирования заключается в том, что альфа-тестирование проводится внутри компании на потенциальных пользователях, а бета-тестирование проводится в ограниченном кругу конечных пользователей программы.</mark>
	\.
	Источники:
		https://github.com/VladislavEremeev/QA_bible/blob/master/vidy-metody-urovni-testirovaniya/modulnoe-yunit-komponentnoe-testirovanie-module-unit-component-testing.md - норм
		https://sedtest-school.ru/types-of-testing/osnovy-testirovaniya-vidy-testirovaniya-po-kriteriyu-urovnya/ - сойдет
		https://habr.com/ru/post/549054/ - фул инфа про тестирование, тут тупа все
	\.
28 - unittest | pytest
	Если необходимо много объектов для тестов, например 1000 пользователей - библиотека FactoryBoy
	\.
	Для дебагинга:
		Создаст точку останова и позволит дебажить
		import pdb  
		pdb.set_trace()
	\.
	unittest:
		\.
		Запуск тестов: <mark style="background: #FFF3A3A6;">py -m unittest {test}</mark>
		\.
		Unit test Имеет следующую структуру:
			Test Case - наследуется от TestCase
			- <mark style="background: #BBFABBA6;">setUP</mark> - подготовка данных для теста
			- <mark style="background: #FFF3A3A6;">test1, test2, test3</mark>... - запуск тестов, проверяющих поведение кода
			- <mark style="background: #FFB86CA6;">tearDown</mark> - очистка, возврат к исходному состоянию
		\.
		Организация тестового кода
			<mark style="background: #FFF3A3A6;">setUp()</mark> и <mark style="background: #FFF3A3A6;">tearDown()</mark> - стандартные методы класса unittest.TestCase, которые мы можем переопределить, чтобы предоставить информацию для проведения теста. В паре они реализуют ФИКСТУРУ.
			\.
			<mark style="background: #FFF3A3A6;">setUp()</mark> - запускается ДО теста
			<mark style="background: #FFF3A3A6;">tearDown()</mark> - запускается ПОСЛЕ теста
			\.
			Если в <mark style="background: #FFF3A3A6;">setUp()</mark> были обнаружены ошибки, то тест даже не запустится и будет ERROR
			Если <mark style="background: #FFF3A3A6;">setUp()</mark> выполнится успешно, то тест выполнится так или иначе и будет либо PASS, либо FAILURE. Ну и потом запустится <mark style="background: #FFF3A3A6;">tearDown()</mark>, где будет происходить уборка после тестов.
			\.
			Некоторые виды assert\`ов:
			- <mark style="background: #FFF3A3A6;">assertEqual</mark>( value, expected_value )
			- <mark style="background: #FFF3A3A6;">assertTrue</mark>( expr )
			- <mark style="background: #FFF3A3A6;">assertIsInstance</mark>( obj, cls )
			- with self.<mark style="background: #FFF3A3A6;">assertRaises(Exception)</mark>: -> тест пройден, если будет ошибка Exception
				  . . .
			\.
			Таким образом, <mark style="background: #FFF3A3A6;">setUp()</mark>, <mark style="background: #FFF3A3A6;">tearDown()</mark> и `__init__()` <mark style="background: #FFB86CA6;">будут вызываться один раз за тест</mark>.
			\.
			Для реализации TestCase рекомендуется использовать ТЕСТОВЫЙ КОМПЛЕКТ.
			Для этого используется метод <mark style="background: #FFF3A3A6;">suite()</mark>, который помогает настроить сборку набора теста.
			Хоть и при запуске тестов они сами упорядочиваются, мы можем сделать это вручную, определив <mark style="background: #FFF3A3A6;">def suite()</mark>:
			\.
			def suite():
			    suite = unittest.TestSuite()
			    suite.addTest(WidgetTestCase('test_default_widget_size'))
			    suite.addTest(WidgetTestCase('test_widget_resize'))
			    return suite
		\.
		Дублирование тестовго кода:
			Чтобы не дублировать код, можно сделать краткую запись тестового случая, используя 
			<mark style="background: #FFF3A3A6;">unittest.FunctionTestCase</mark>(<mark style="background: #ABF7F7A6;">testFunc</mark>, <mark style="background: #ABF7F7A6;">setUp</mark>=None, <mark style="background: #ABF7F7A6;">tearDown</mark>=None, <mark style="background: #ABF7F7A6;">description</mark>=None )
			\.
			Где:
			- <mark style="background: #ABF7F7A6;">testFunc</mark> - функция тест
			- <mark style="background: #ABF7F7A6;">setUp</mark> & <mark style="background: #ABF7F7A6;">tearDown</mark> - фикстура
			- <mark style="background: #ABF7F7A6;">description</mark> - описание теста
		\.
		Основные декораторы @unittest:
			Пропуск TestCase:
			<mark style="background: #FFF3A3A6;">@unittest.skip</mark>("showing class skipping")
			class MySkippedTestCase(unittest.TestCase):
			    def test_not_run(self):
			        . . .
			\.
			Ожидание ошибки:
			class ExpectedFailureTestCase(unittest.TestCase):
				<mark style="background: #FFF3A3A6;">@unittest.expectedFailure</mark>\.
				def test_fail(self):
				. . .
			\.
			Пропуск теста при условии ЕСЛИ:
			<mark style="background: #FFF3A3A6;">@unittest.skipIf( condition, reason )</mark>\.
			\.
			Пропуск теста при условии ДО ТЕХ ПОР ПОКА:
			<mark style="background: #FFF3A3A6;">@unittest.skipUnless( condition, reason )</mark>\.
		\.
		<mark style="background: #FFB8EBA6;">Mock</mark> объекты:
			Mock\`и -  это объекты, которые заменяют реальный объект в условиях теста и позволяют проверять вызовы своих методов. Содержат заранее подготовленные описания вызовов, которые они ожидают получить.
			Моки помогают заменить межсервисное взаимодействие при тестировании кода. 
			Также могут помочь если мы хотим протестировать какую-то функцию без ожидания ответа от сервиса. Тогда просто ответ от сервиса мокается.
			Мокать можно что угодно.
			\.
			Синтаксис:
			Класс, который будем мокать:
				class Worker:
					. . .
					def <mark style="background: #FFF3A3A6;">eat(self)</mark>:
						time.sleep(30\*60) <-- какая-то долгая работа
						result = self.food()
						return result
					. . .
					def work(self): <-- тестируемая функция, которую мокаем
						if self.<mark style="background: #FFF3A3A6;">eat()</mark>:
							print("Dinner")
						else:
							return "Working"
					. . .
			\.
			Мок-тест:
				import worker 
				from unittest import patch, Mock
				. . .
				@patch.object(worker.Worker, "eat") <-- <mark style="background: #ABF7F7A6;">worker</mark> - <mark style="background: #ABF7F7A6;">это тестируемый модуль</mark>, <mark style="background: #ADCCFFA6;">.Worker</mark> - <mark style="background: #ADCCFFA6;">это класс</mark>, <mark style="background: #FFF3A3A6;">"eat" - метод</mark>
				def test_work(self, mock_eat): <-- пробрасываем мок объект
					mock_eat.return_value = True <-- теперь будет возвращаться True
					new_worker = worker.Worker('Bob')
					result = new_worker.work()
					self.assertEqueal("Working", result)
					mock_eat.assert_called() 
				. . .
			\.
			Через MagicMock вот так создается мок объект:
				from unittest.mock import MagicMock
				thing = ProductionClass()
				thing.<mark style="background: #FFF3A3A6;">method</mark> = MagicMock(<mark style="background: #FFF3A3A6;">return_value=3</mark>)
				thing.method(3, 4, 5, key='value')
				thing.method.assert_called_with(3, 4, 5, key='value')
			\.
			Mock(<mark style="background: #FFF3A3A6;">side_effect=</mark> . . .) - сайд эффект, это побочный эффект. То есть если в тестируемой функции вызывается какая-то другая функция, то мы можем заменить её, поместив подмену в side_effect
			\.
			 У объекта Mock есть несколько атрибутов с информацией о вызовах:
				-   called — вызывался ли объект вообще
				-   call_count — количество вызовов
				-   call_args — аргументы последнего вызова
				-   call_args_list — список всех аргументов
				-   method_calls — аргументы обращений к вложенным методам и атрибутам (о них — ниже)
				-   mock_calls — то же самое, но вместе и для самого объекта, и для вложенных
		\.
		Файлы тестировки должны начинаться с "test_".
		\.
		При запуске тестов создается временная база данных, это позволяет не трогать данные в существующей БД. При этом временная база данных после каждого проведенного теста самоочищается. В юниттестировании нужно сравнивать expected data и фактический результат data.
		\.
		Модуль coverage.
			Помогает отследить степень покрытия приложения тестами, где тесты запускались.
			\.
			Команда для запуска тестов: <mark style="background: #FFF3A3A6;">coverage run --source='.' manage.py test</mark>
			Команда для создания отчета покрытия: <mark style="background: #FFF3A3A6;">coverage report</mark>
			Команда для создания визуального отчета: <mark style="background: #FFF3A3A6;">coverage html</mark>
		\.
		Источники:
			https://digitology.tech/docs/python_3/library/unittest.html#organizing-tests дока на русском
			https://kavo-main.ru/articles/python-testirovanie-unittest/ - про юниттест
		\.
	pytest
		**Pytest** — **это** фреймворк тестирования на Python. Его используют для написания и выполнения тестового кода.
		\.
		<mark style="background: #BBFABBA6;">Преимущества pytest</mark>:
			- Независимость от API. Ненужно наследоваться от TestCase.
			- assert vs self.assertEquel. Один assert на все случаи жизни
			- Параметризованные тесты. Быстрое добавление тест кейсов
			- Плагины, широкая фан база
			- Совместимость с unittest 
		\.
		<mark style="background: #BBFABBA6;">Полезные опции в Pytest</mark>:
			--collect-only - вывод списка найденных тестов
			-v - повышает детализацию процесса заспуска тестов
			-k - фильтрация по имени теста
			-s - включает вывод принтов в stdout (по умолчанию принтится только при падении тестов)
			--maxfail=n - останавливает выполн ение после того, как n тестов упало
			-x - запускает упавшие тесты сначала
		\.
		Метки-декораторы в Pytest:
			@<mark style="background: #FFF3A3A6;">pytest.mark.skip</mark> - скипает тест
			@<mark style="background: #FFF3A3A6;">pytest.mark.skipif</mark> - скипает тест при каком-то условии
			@<mark style="background: #FFF3A3A6;">pytest.mark.xfail</mark> - ожидаемо падающий тест
			@<mark style="background: #FFF3A3A6;">pytest.mark.parametrize</mark> - параметризация
			@<mark style="background: #FFF3A3A6;">pytest.mark.usefixtures</mark> - можно передать список используемых в тесте фикстур. Однако тест не может использовать возвращаемое значение фикстуры
			список всех меток pytest --markers
		\.
		Fixture (@pytest.fixture()) - это:
			то функции, выполняемые pytest до (а иногда и после) фактических тестовых функций. Фикстуры это функции и методы, которые запускаются для создания соответствующего окружения для теста.
			\.
			Фикстуры можно расположить в <mark style="background: #FFB86CA6;">conftest.py</mark>, откуда они будут автоматически без импорта вызываться
			\.
			@<mark style="background: #FFF3A3A6;">pytest.fixture</mark>(<mark style="background: #ABF7F7A6;">autouse=True</mark>) - стоит использовать аккуратно. Такая фикстура автоматически будет пременена <mark style="background: #FFB86CA6;">ко всем тестам</mark> в директории.
			\.
			Передав в @<mark style="background: #FFF3A3A6;">pytest.fixture</mark>() параметр scope можно задать уровень фисктуры: 
			- function – фикстура запускается для каждого теста
			- cls – фикстура запускается для каждого класса
			- module – фикстура запускается для каждого модуля
			- session – фикстура запускается для каждой сессии (то есть фактически один раз) 
			- Значение по умолчанию = “function”.
			\.
			Как выглядит запуск фикстуры:
				@pytest.fixture
				def <mark style="background: #FFF3A3A6;">fixture_1</mark>:
					. . .
				\.
				def test_func(<mark style="background: #FFF3A3A6;">fixture_1</mark>):
					. . .
				\.
				Запуск под капотом:
				SETUP fixture_1
				-> test_func <-
				TEARDOWN fixture_1
		\.
		<mark style="background: #ABF7F7A6;">Параметризация</mark>:
			Параметризация — это способ запустить один и тот же тест с разным набором входных параметров. Например, у нас есть функция, которая добавляет знак вопроса к строке, если она длиннее 5 символов, восклицательный знак — менее 5 символов и точку, если в строке ровно 5 символов. Соответственно вместо того, чтобы писать три теста, мы можем написать один, но вызываемый с разными параметрами.
			\.
			Задать параметры для теста можно двумя способами:
				1. Через значение параметра <mark style="background: #FFF3A3A6;">params</mark> фикстуры, в который нужно передать массив значений. То есть фактически фикстура в данном случае представляет собой обертку, передающую параметры. А в сам тест они передаются через атрибут param объекта request
					Пример кода:
						import pytest
						\.
						def strange_string_func(str): 
						if len(str) > 5: 
							return str + "?" 
						elif len(str) < 5: 
							return str + "!" 
						else: 
							return str + "." 
							\.
							@<mark style="background: #FFF3A3A6;">pytest.fixture(scope="function", params=[ ("abcdefg", "abcdefg?"), ("abc", "abc!"), ("abcde", "abcde.") ])</mark> 
							def param_test(request): 
								return request.param 
							\.
							def test_strange_string_func(param_test): 
								(input, expected_output) = param_test 
								result = strange_string_func(input)
								print "input: {0}, output: {1}, expected: {2}".format(input, result, expected_output) assert result == expected_output 
								\.
				2. Через декоратор (метку) @pytest.mark.parametrize, в который передается список названий переменных и массив их значений.
					Пример кода:
						import pytest 
						\.
						@pytest.mark.parametrize("x", \[1,2\]) 
						@pytest.mark.parametrize("y", \[10,11\]) 
						def test_cross_params(x, y): 
							print "x: {0}, y: {1}".format(x, y) 
							assert True
		\.
		Моки в pytest такие же, как и в unittest. Советую использовать моки from unittest import mock
		\.

# Async Python
29 - GIL | Global Interpreter Lock
	GIL -
		**Python Global Interpreter Lock (GIL)** — это блокировка, позволяющая только одному потоку управлять интерпретатором Python. Это означает, что будет выполняться только один поток в рамках главного процесса.
		\.
		GIL добавляет правило: любое выполнение байткода в CPython требует блокировки интерпретатора.
		\.
		<mark style="background: #FF5582A6;">RaceCondition</mark> - <mark style="background: #ADCCFFA6;">ошибка проектирования многопоточного приложения, при которой работа приложения зависит от того, в каком порядке выполняются части кода</mark>. Например, два потока работают с одной переменной: один к ней что-то прибавляет, а другой обнуляет счетчик ссылок переменной. 
		\.
		<mark style="background: #FF5582A6;">DeadLock</mark> - ситуация в многопоточном приложении, <mark style="background: #ADCCFFA6;">при которой несколько процессов находятся в состоянии ожидания ресурсов друг от друга</mark> и ни один из них не может продолжить свое выполнение
		\.
		<mark style="background: #BBFABBA6;">Плюсы</mark>:
		- Решения проблемы <mark style="background: #FF5582A6;">RaceCondition</mark>
		- Решение проблемы <mark style="background: #FF5582A6;">DeadLock</mark>, т.к. единственной блокировкой будет GIL
		- Обратной совместисомсти с библотеками на С, которым нужна потокобезопасного управления памятью 
		- <mark style="background: #FFB86CA6;">Защищает память</mark>
		<mark style="background: #FF5582A6;">Минусы</mark>:
		- При разделении потоков получаем замедление работы, так как нельзя распределить вычислительную нагрузку по нескольким потокам.
		- GIL создает доп. нагрузку на систему, замедляя даже потоки, производительность которых ограничена подсистемой ввода/вывода.
		- Многоядерные системы не используют весь свой потенциал
		- Попеременное переключение между потоками (эффект конкуренции) вызывают замедление работы в случае CPU bound задач
	    \.
	    Альтернатива GIL:
		    В рамках проекта PyPy ведется разработка реализации транзакционной памяти (Software Transactional Memory, STM), однако интерпетатор с STM работает медленней, чем с GIL. Но за счет динамической JIT (Just-in-Time) компиляции STM может работать быстрее, чем CPython.
		    \.
		    Интерператоры без GIL: IronPython, Jython
		    \.
		    В стандартной библиотеке Python (stdlib) предлагается три способа для конкурентного выполнения задач в программе — это модуль multiprocessing для конкурентности на уровне процессов, модуль threading для конкурентности на уровне потоков, а также модуль asyncio для конкурентности на основе корутин
		    \.
		    В Python существуют три основных API для конкуренции, вот они:
			-   <mark style="background: #FFB86CA6;">Корутиновый</mark>, предоставляемый в модуле asyncio.
			-   <mark style="background: #BBFABBA6;">Поточный</mark>, предоставляемый в модуле threading.
			-   <mark style="background: #D2B3FFA6;">Процессный</mark>, предоставляемый в модуле multiprocessing.
			\.
30 - Threading | Многопоточность | asyncio | Асинхронность
	Поток - это подпрограмма основной программы. Задача программы.
	Многопоточность — <mark style="background: #ADCCFFA6;">это выполнение программы сразу в нескольких потоках, которые выполняют её функции одновременно</mark>.
	\.
	Библиотека threading нужна для реализации конкрутеной работы на уровне потоков, а asyncio на уровне корутин. \Б\о\л\е\е\ \г\л\у\б\о\к\а\я\ \р\а\з\н\и\ц\а\ \б\у\д\е\т\ \д\а\л\ь\ш\е
	\.
	При запуске программы всегда создается главный поток в рамках главного процесса. 
	\.
	CPU-bound:
		Это вычислительные задачи: перемножение матриц, поиск, обработка изображений.
		<mark style="background: #FFB86CA6;">Не связаны с вводом/выводом</mark>. 
		\.
		<mark style="background: #ADCCFFA6;">В этих операциях участвуют только данные, находящиеся в основной памяти</mark>, и над этими данными (или с их применением) выполняются вычисления.
		\.
		В принципе, единственным <mark style="background: #ADCCFFA6;">ограничивающим фактором этих операций является скорость процессора</mark>. Вот почему их называют CPU-Bound. Они очень быстрые.
		\.
		Пример задач вычисления:
		- Обработка текста
		- Синтаксический разбор HTML, JSON и т. д.
		- Вычисление точек во фрактале
		\.
		Вывод: <mark style="background: #ADCCFFA6;">Для математических операций вычисления потоки не нужны, они лишь замедлят работу. Поэтому лучше создавать новый процесс, либо тонко настраивать конкуретную работу через asyncio</mark>
	I/O - bound:
		Задачи, ориентированные на ввод/вывод, предполагают считывание данных или запись их на устройство, в файл или в сокет.
		\.
		Пример задач ввода и вывода:
		- Запрос к серверу
		- Запрос к базе данных
		- Считывание или запись в стандартный ввод, стандартный вывод или стандартный канал ошибки (stdin, stdout, stderr).
		\.
		<mark style="background: #ADCCFFA6;">Это операции над входящими и исходящими данными</mark>, и скорость этих операций ограничена возможностями устройства, скоростью чтения/записи с жесткого диска или скоростью сетевого соединения.
		\.
		Выполнение ввода/вывода — очень медленная операция по сравнению со скоростью процессора.
		\.
		Процессор обрабатывает запросы очень быстро. Однако большая часть времени тратится на ожидание завершения каких-то предшествующих программ.
		<mark style="background: #FFB86CA6;">Так теряется время, за которое потенциально можно было бы выполнить миллиарды операций</mark>.
		\.
		Вывод: <mark style="background: #ADCCFFA6;">потоки нужны для решения проблемы ожидания ответа. То есть для I/O Bound задач</mark>.
	\.
	Разница между потоками и процессами:
		- потоки имеют общую память, поэтому в одном потоке видно другие
		- процессы используют разные области памяти, запуск процесса по сути запуск второго интерпретатора
	\.
	Работа с <mark style="background: #FF5582A6;">threading</mark>
		GIL снимается только при выполнении блокирующих операций, например ввода/вывода, либо при работе со специфическими сторонними библиотеками, написанными на C, например с NumPy. Поэтому для I/O Bound задач используем threading
		\.
		Для начала надо создать экземпляр класса Thread. 
		Чтобы создать отдельный поток, нужно создать экземпляр класса и применить к нему метод <mark style="background: #FFF3A3A6;">start()</mark>
		my_thread = Thread(<mark style="background: #FFF3A3A6;">group</mark>=None, <mark style="background: #FFF3A3A6;">target</mark>=None, <mark style="background: #FFF3A3A6;">name</mark>=None, <mark style="background: #FFF3A3A6;">args</mark>=(), <mark style="background: #FFF3A3A6;">kwargs</mark>=None, \*, <mark style="background: #FFF3A3A6;">daemon</mark>=None))
		Где:
		- <mark style="background: #FFF3A3A6;">group</mark> - Имеет значение None, зарезервирована для будущего расширения при реализации класса ThreadGroup.
		- <mark style="background: #FFF3A3A6;">target</mark> - Это функция, которая выполняется в потоке с помощью метода run(), если передано значение None, ничего не вызывается.
		- <mark style="background: #FFF3A3A6;">name</mark> - имя потока
		- <mark style="background: #FFF3A3A6;">args</mark>=(arg, ) - кортеж, в котором передаем аргументы
		- <mark style="background: #FFF3A3A6;">kwargs</mark> - словарь, в котором хранятся аргументы
		- <mark style="background: #FFF3A3A6;">daemon</mark> - параметр, который делает поток демоническим. Обычно Python-приложение не завершается, пока работает хоть один его поток. Но есть особые потоки, которые не мешают закрытию программы и останавливается вместе с ней. Их называют демонами (daemons). Проверить, является ли поток демоном, можно методом **isDaemon()**. Если является, метод вернёт истину.
		  <mark style="background: #ADCCFFA6;">Демонами называют процессы, которые работают в фоновом режиме</mark>.
		\.
		Методы Thread:
		- <mark style="background: #FFF3A3A6;">start( )</mark> - Он используется для запуска созданного потока. 
		- <mark style="background: #FFF3A3A6;">join( timeout= None)</mark> - Этот метод блокирует выполнение потока, который его вызвал, до тех пор пока не завершится поток, метод которого был вызван. Если этого не сделать, то тогда будет выполняться все подряд. timeout= указать время жизни потока.
		- <mark style="background: #FFF3A3A6;">def run( self )</mark> - используется при создании класса потока. Это метод, который выполняется при старте потока. То есть при создании экземпляра класса и после применения start( ) сработает run( )
		- <mark style="background: #FFF3A3A6;">is_alive()</mark> - Метод возвращает True или False, проверяет выполняется ли поток в данный момент. 
		  Его часто используют в связке с методом join(). Кроме того, с его помощью можно грамотно управлять выполнением потоков демонов, не позволяя им неожиданно завершить работу при закрытии программы
	    \.
		Остановка потока:
			Можно в функции для потока определить некое терминирующее условие stop=False при котором будет останавливаться выполнения функции если сделать stop=True
		\.
		Доступ к общим ресурсам (Lock)
		Для того чтобы предотвратить состояние гонки, нужно использовать блокировку threading.Lock(), которая не позволяет сразу нескольким потокам работать с одними и теми же данными. <mark style="background: #FFF3A3A6;">Lock защищает данные от одновременного доступа</mark>.
		\.
		<mark style="background: #FFF3A3A6;">Lock( )</mark> возвращает объект, который является воротами, которые закрываются, если за воротами кто-то находится. 
		\.
		У полученного объекта есть два метода:
		- <mark style="background: #FFF3A3A6;">acquire( blocking=True, timeout=-1 )</mark> - позволяет потоку получить блокировку. blocking=True стоит по умолчанию и блокирует Lock пока не будет разблокирован.
		  timoueout=-1 стоит по умолчанию. Можно изменить только если blocking=True. Предоставляет время ожидания блокировки
		- <mark style="background: #FFF3A3A6;">release( )</mark> - разблокирует объект Lock(). Вернет ошибку, если разблокировать разблокированный поток.
		\.
		<mark style="background: #FF5582A6;">Важно! Сколько раз вызвал acquire(), столько надо вызвать release()</mark>.
		При каждом вызове acquire() уровень рекурсии увеличивается на единицу, соответственно при каждом вызове release() он уменьшается на единицу.
		\.
		RLock():
			Если объект Lock()\`а заблокирован, то любой поток попытавшийся заблокировать его заблокируется сам. Это <mark style="background: #FF5582A6;">deadlock</mark>.
			\.
			RLock блокирует поток только в том случае, если объект заблокирован другим потоком. <mark style="background: #FFB86CA6;">Используя RLock, поток никогда не сможет заблокировать сам себя</mark>.
		\.
		Коротко про Barrier, Semaphore, Timer, Event:
			- <mark style="background: #FFF3A3A6;">Semaphore()</mark> - семафор использует внутренний счетчик, который уменьшается при каждом вызове acquire() и увеличивается при release().  Счётчик не может стать меньше нуля, когда он становится равным нулём, acquire() блокирует поток. Ограничивает количество запросов.
			- <mark style="background: #FFF3A3A6;">Timer()</mark> - Этот класс позволяет контролировать время запуска какого-либо действия. Timer является подклассом Thread. 
			  `threading.Timer(interval, function, args=None, kwargs=None)`
			- <mark style="background: #FFF3A3A6;">Barrier()</mark> - Этот класс позволяет реализовать простой механизм синхронизации потоков. Его можно использовать для фиксированного числа потоков, когда необходимо, чтобы каждый поток ждал выполнения какого-либо действия всеми.
			  <mark style="background: #ADCCFFA6;">Для того чтобы продолжить выполнения, все потоки должны вызвать метод wait()</mark>.
			  `hreading.Barrier(parties, action=None, timeout=None)`
			- <mark style="background: #FFF3A3A6;">Event()</mark> - это простой механизм реализации связи между потоками: один поток даёт сигнал о событии, другие ожидают этого сигнала. Объект события управляет внутренним флагом, который может быть установлен в True или False с помощью методов <mark style="background: #FFF3A3A6;">event.set()</mark> и <mark style="background: #FFF3A3A6;">event.clear()</mark>
		\.
		Источник по потокам:
			https://all-python.ru/osnovy/threading.html - все про threading
			https://habr.com/ru/company/skillbox/blog/685682/ - выбор между threading, asyncio, multiprocessing
	\.
	Работа с <mark style="background: #FF5582A6;">asyncio</mark>:
		Асинхронный вызов функции - это запрос на вызов функции в фоновом режиме.
		\.
		Отличия от threading
			- Все задачи решаются в одном потоке, а именно в объекте EventLoop
			- в threading операционная система переключает GIL среди потоков за 5мс, а в asyncio ты сам выбираешь когда переключиться через синтаксис async await
		\.
		Раньше асинхронность в питоне реализовывали бесконечные генераторы. Это были первые корутины. В python 3.5 появился `async def` и вместо `yiled` используется `await`
		\.
		Пример корутины (со-программы):
		<mark style="background: #FFF3A3A6;">async def</mark>  async_func( num ):
			while True:
				<mark style="background: #FFF3A3A6;">await</mark> num
				num = num + 1
		\.
		При этом если мы посмотрим методы этой функции <mark style="background: #FFF3A3A6;">dir(async_func)</mark>, то увидим, что она реализует методы генератора + добавляется метод \_\_await\_\_ который превращает объект в корутину. <mark style="background: #ADCCFFA6;">Корутина похожа на объект генератора</mark>
		\.
		<mark style="background: #FFB86CA6;">await словно yield передает управление асинхронным кодом дальше</mark>.
		\.
		После создания корутин для асинхронного кода и попеременного переключения <mark style="background: #ADCCFFA6;">необходимо корутины превратить в таски (задачи), то есть запланировать их</mark>.
		<mark style="background: #FFB86CA6;">Для конкуретного запуска программы корутины надо планировать</mark>!
		\.
		Регистрация задач:
			- <mark style="background: #FFF3A3A6;">asyncio.create_task( coroutine )</mark> и после запуск через <mark style="background: #FFF3A3A6;">await coroutine</mark>
			  Пример:
				  . . .
				  asyncio.create_task( coroutine1 )
				  await coroutine2
				  . . .
			- Чтобы не делать трехэтажный код можно поместить все корутины в список и вызвать метод <mark style="background: #FFF3A3A6;">.gather()</mark>
			  Пример:
				    . . .
				    tasks = \[
					  coroutine_1( ),
					  coroutine_2( ),
					  coroutine_3( ),
					  \]
					\.
				    <mark style="background: #FFF3A3A6;">await asyncio.gather</mark>(\*tasks) <---- необходимо расскрыть через \*
		\. 
		Запуск корутин:
			- <mark style="background: #FFF3A3A6;">asyncio.run( main )</mark>
			  Где main - это async def функция, которая руководит запуском всех корутин
		\.
		Event loop - цикл событий:
			Цикл событий - это поток, который запускает асинхронные задачи.
			- <mark style="background: #FFF3A3A6;">asyncio.get_event_loop()</mark> - получение цикла событий
			- <mark style="background: #FFF3A3A6;">.run_until_complete( coroutines )</mark> - активировать до завершения корутины
			- <mark style="background: #FFF3A3A6;">asyncio.get_event_loop()</mark>.<mark style="background: #FFF3A3A6;">close()</mark> - закрыть цикл событий
		\.
		Shield | защита таски от отмены:
			<mark style="background: #FFF3A3A6;">await asyncio.shield(aw, *)</mark> - эта функция защищает объект задачи от отмены методом Task.cancel(). <mark style="background: #FFF3A3A6;">aw</mark> - объект задачи (корутина)
		\.
		Блокирующие функции:
			Мы можем встраивать в асинхронный код синхронный код. Но это считается bad practice. Почему?
			Так, например, <mark style="background: #FFB86CA6;">sleep() from time</mark> заморозит весь поток и по сути остановит программу. В то время как <mark style="background: #FFF3A3A6;">asyncio.sleep() </mark> заморозит только конкретную корутину. 
			\.
			<mark style="background: #ADCCFFA6;">Применяя синхронный код в асинхронном програмировании смысл асинхронности теряется</mark>.
			\.
			Еще типичным блокером является библиотека request, которая делает запросы синхронно. Поэтому есть библиотека aiohttp для асихнронный запросов.
			\.
			Источники по asyncio:
				https://docs.python.org/3/library/contextvars.html#contextvars.Context - офф дока
			\.
31 - Multiprocessing | Параллелизм
	Для реализации паралелльной работы компонентов программы используется библиотека multiprocessing. <mark style="background: #ADCCFFA6;">Модуль multiprocessing предоставляет работу с конкурентностью на уровне процессов</mark>
	\.
	Следует использовать конкурентность на уровне процессов, если в решаемой задаче активно задействуется процессор, и конкурентность на уровне потоков, если ожидается много операций, связанных с вводом/выводом.
	\.
	<mark style="background: #FFB86CA6;">Многопроцессная обработка не подходит для решения задач, при которых одни процессы активно обмениваются информацией с другими</mark>.
	\.
	Работа с multiprocessing:
		Объект <mark style="background: #FFF3A3A6;">Pool(processes_amount)</mark> - предоставляет средства распараллеливания выполнения функции по нескольким входным значениям.
		\.
		Работа с пулом обязательно проводится через точку входа if name \=\= main , иначе будет бесконечная рекурсия.
		\.
		Лайфхак по грамотному распределению нагрузки:
			def get_value( value ):
				. . .
			def end_func( response ):
				print('Задание заверщено!')
				print(response)
			. . .
			<mark style="background: #CACFD9A6;">if __name__ == "__main__" </mark>:
				<mark style="background: #CACFD9A6;">with multiprocessing.Pool</mark>(<mark style="background: #FFF3A3A6;">multiprocessing.cpu_count()</mark> * 3) as p:
					p.<mark style="background: #FFF3A3A6;">map_async</mark>(get_value, list(range(1, 1000), callback = end_func) 
		\.
		<mark style="background: #FFF3A3A6;">cpu_count()</mark> выдаст количество ядер и это позволит не перенагружать систему. Таким образом мы запустим разумное количество процессов.
		\.
		<mark style="background: #FFF3A3A6;">map_async()</mark> - как обычная функция map() работает, однако еще <mark style="background: #ADCCFFA6;">в завершении вызывает указанную вручную callback функцию с объектом response о результате работы</mark>. И вернет список значений.
		\.
		<mark style="background: #FF5582A6;">Важно!</mark> Hеобходимо не забывать <mark style="background: #FFB86CA6;">закрыть</mark> пул и <mark style="background: #FFB86CA6;">дождаться</mark> выполнения всех процессов:
		\.
		p.<mark style="background: #FFF3A3A6;">close()</mark> - закрывает пул
		p.<mark style="background: #FFF3A3A6;">join()</mark> - дожидается завершения всех процессов
		 \.
		 <mark style="background: #FFF3A3A6;">apply_async( func , args=( arg, ), c allback=end_func)</mark> - позволяет вызвать функцию отдельно. <mark style="background: #ADCCFFA6;">Как выполняется одна функция, то сразу возвращается callback</mark>. Это отличается от map_async(), где сначала выполняются ВСЕ функции, а потом только возвращается callback
		 \.
		 Разница между kill() и terminate():
		 - <mark style="background: #FFF3A3A6;">kill()</mark> завершит процесс принудительно и отправит сигнал unix сигнал STGKILL
		 - <mark style="background: #FFF3A3A6;">terminate()</mark> сохранит данные перед завершением процесса.
		 - kill больше как отключить компьютер от питания, а terminate как нажать кнопку выключить
		\.
		Создание процесса, аналогично созданию потока:
		process = <mark style="background: #FFF3A3A6;">Process(group=None, target=func, args=( arg, ))</mark>
		\.
		SharedMemory | Обмен данными между процессами:
			Так как процессы не могут обмениваться данными, существуют некоторые методы общения:
			\.
			1 - Класс `SharedMemory` предоставляет для выделения и управления общей памятью, к которой обращается один или несколько процессов на многоядерном компе. 
				\.
				Для общения между процессами используют "трубы" <mark style="background: #FFF3A3A6;">Pipe( )</mark>
					`enter, exit = Pipe( )`
				\.
				Теперь enter принимает данные, а exit получает:
					enter.send(\[1, 'some data'\])
					exit.recv()
					--> output: \[1, 'some data'\]
				\.
				Также используя <mark style="background: #FFF3A3A6;">send()</mark> и <mark style="background: #FFF3A3A6;">recv()</mark> можно обмениваться данными и наоборот из exit в enter переменную. 
			\.
			2 - Очереди. Используются для обмена данными между потоками. 
				<mark style="background: #FFF3A3A6;">multiprocessing.Queue</mark> это полная копия очереди.
				Данные из одного процесса записываются в очередь, а потом оттуда извлекаются. Реализация:
				from multiprocessing import Process, Queue
				def foo(q):
				    q.put(\[42, None, 'hello'\])
				\.
				if \_\_name\_\_ == '\_\_main\_\_':
				    q = Queue()
				    process = Process(target=foo, args=(q, ))
				    process.start()
				    print(q.get())    # распечатает "\[42, None, 'hello'\]"
				    process.join()
			\.
			3 - <mark style="background: #FFF3A3A6;">Value()</mark>, <mark style="background: #FFF3A3A6;">Array()</mark> позволяют хранить общую память.
				Реализация:
				from multiprocessing import Process, Value, Array
				\.
				def f(n, a):
				    n.value = 3.1415927
				    for i in range(len(a)):
				        a[i] = -a[i]
				\.
				if \_\_name\_\_ == '\_\_main\_\_':
				    num = Value('d', 0.0)
				    arr = Array('i', range(10))
				    p = Process(target=f, args=(num, arr))
				    p.start()
				    p.join()
				    print(num.value)
				    print(arr[:])
			\.
			Однако <mark style="background: #FFB86CA6;">при параллельном программировании обычно лучше избегать использования общего состояния, насколько это возможно</mark>!
			\.
		Блокировка процесса:
			`Lock.acquire(block=True, timeout=None)`:
			Метод `Lock.acquire()` ставит блокирующую или неблокирующую блокировку.
			Если `block=False`, то вызов метода не блокируется.
			\.
			Разблокировка
			Метод `Lock.release()` снимает блокировку. Может быть вызван из любого процесса или потока, а не только из процесса или потока, который изначально получил блокировку.
		\.
# Technologies
32 - Docker
	<mark style="background: #ABF7F7A6;">Docker</mark>:
		Docker - технология для создания и управления контейренами, развертывания приложений в среде виртуализации на уровне операционной системы. Позволяет упаковать приложение со всем его окружением и зависимостями в контейнер.
		\.
		<mark style="background: #ABF7F7A6;">Виртуализация & Контейнеризация</mark>:
			Средство запуска на одном физическом сервере виртуальные серверы для максимально плотного использования различных окружений называется виртуализацией.
			\.
			Виртуализация - это запуск отдельной операционной системы на одном компьютере.
			\.
			Контейнеризация - запуск образов с использованием ядра операционной системы той машины, где открывается контейнер.
			\.
			Ядро операционной системы - центральная часть системы, обеспечивающая приложениям координированный доступ к ресурсам компьютера, памяти, файлам и тд.
			\.
			<mark style="background: #FFF3A3A6;">Отличия</mark>:
			- Контейнеры запускаются быстрее и меньше памяти потребляют
			- Контейнеры используют ядро ОС там, где контейнер открывается
		\.
		<mark style="background: #ABF7F7A6;">Термины Docker</mark>: 
			Контейнер - это:
				Пространство виртуализации уровня операционной системы, в котором могут быть развернуты приложения. Это исполняемый экземпляр образа. Файлы в нем существуют, пока существует сам контейнер. Для сохранения данные выносятся в постоянную структуру - volume
			\.
			Образ:
				Схема приложения, на основе которой построится контейнер.
			\.
			Docker Daemon:
				Демон докера - это фоновый сервис, запущенный на хост-машине, который отвечает за создание, запуск и уничтожение докер-контейнеров.
			\.
			Docker Client:
				Утилита командной строки, позволяющая общаться с демоном.
			\.
			Docker Hub:
				Публичный регистр докер-образов. Архив всех доступных образов.
			\.
			DockerFile:
				Текстовый файл, в котором содержится список команд Докер-клиента. Это способ автоматизации процесса создания образа.
		\.
		Команды Docker:
			- <mark style="background: #FFF3A3A6;">docker run (name)</mark> - запустить контейр 
			- <mark style="background: #FFF3A3A6;">docker pull (name)</mark> - скачать образ 
			- <mark style="background: #FFF3A3A6;">docker ps</mark> - вывести работающие контейнеры
			- <mark style="background: #FFF3A3A6;">docker ps -a</mark> - показать все контейнеры
			- <mark style="background: #FFF3A3A6;">docker images</mark> - показать все образы
			- <mark style="background: #FFF3A3A6;">docker rm (name)</mark> - удалить контейнер
			- <mark style="background: #FFF3A3A6;">docker rmi (name)</mark> - удалить образ
			- <mark style="background: #FFB86CA6;">docker run -it (name) sh</mark> - открывает интерактивное окно для ввода и запуска команд в контейнере
			- <mark style="background: #FFF3A3A6;">docker run -d -P --name (name) (image_name)</mark> - запустить контейнер в фоновом (-d) режиме, с открытыми портами (-P) с определенным удобным именем (name) по образу (image_name)
			- <mark style="background: #FFF3A3A6;">docker build -t (username)/(image_name) .</mark> - находясь в одной директории с dockerfile создать образ на DockerHub
			- <mark style="background: #FFF3A3A6;">docker logs (name)</mark> - посмотреть логи контейнера
			- <mark style="background: #FFF3A3A6;">docker inspect (name)</mark> - вернет подробную информацию о контейнере
		\.
		<mark style="background: #ABF7F7A6;">Структура Dockefile</mark>:
			- <mark style="background: #FFF3A3A6;">FROM (technology:version)</mark> - импорт базового образа
			- <mark style="background: #FFF3A3A6;">LABEL</mark> - добавляет мета-данные, например имя автора
			- <mark style="background: #FFF3A3A6;">ENV (ENV_NAME=VALUE)</mark> - создает переменную окружения, которая станет доступна во время запуска контейнера.
			- <mark style="background: #FFF3A3A6;">RUN apk update && apk upgrade</mark> - запускает команды обновления пакетов базового образа. Используется для установки библиотек внутри контейнера. запуск консольных команд.
			- <mark style="background: #FFF3A3A6;">COPY (directory)</mark> - копирует файлы из локальной директории в контейнер
			- <mark style="background: #FFF3A3A6;">ADD (git link)</mark> - как COPY, только еще умеет распаковывать локальные файлы .tar
			- <mark style="background: #FFF3A3A6;">CMD ["commands"]</mark> - команды для выполнения внутри контейнера. CMD может быть только один. переопределение параметров в контейнере
			- <mark style="background: #FFF3A3A6;">WORKDIR (directory)</mark> - Меняет текущую рабочую директорию в контейнере для инструкций: `COPY`, `ADD`, `RUN` и `ENTRYPOINT`. 
			- <mark style="background: #FFF3A3A6;">ARG (VAR_NAME=VALUE)</mark> - переменные для Docker во время сборки
			- <mark style="background: #FFF3A3A6;">ENTRYPOINT ["commands"]</mark> - похож на CMD, но ENTRYPOINT можно много раз использовать. исполняемые файлы для старта контейнера
			- <mark style="background: #FFF3A3A6;">EXPOSE (ports)</mark> - показывает, какой порт пробрасывать из контейнера. Использовать в связке с docker run -P
			- <mark style="background: #FFF3A3A6;">VOLUME (local directory)</mark> - определяет, где контейнер будет хранить данные и получать к ним доступ
	\.
	<mark style="background: #ABF7F7A6;">Docker Compose</mark>:
		Инструмент для определения и запуска многоконтейнерных приложений.
		\.
		Volume - параметр, в котором мы указываем путь локально на хост-машине, куда из временной структуры контейнера будут сохраняться данные. 
		\.
		<mark style="background: #ABF7F7A6;">Структура Docker-compose.yml</mark>:
			 <mark style="background: #D2B3FFA6;">version "3.7"</mark> - просто версия docker-compose файла, смысла нет
			 <mark style="background: #D2B3FFA6;">services:</mark> - здесь описываются контейнеры которые мы запустим
				<mark style="background: #FFB86CA6;">example_container</mark>: - так задается служебное имя контейнеру
					<mark style="background: #D2B3FFA6;">build:</mark> - задается директория, откуда будет сборка. Где лежит Dockerfile
						<mark style="background: #D2B3FFA6;">context:  ./where_dockerfile</mark> - путь к Dockerfile
						<mark style="background: #D2B3FFA6;">args</mark>:
							<mark style="background: #D2B3FFA6;">buildno: 1488</mark> - номер сборки
					<mark style="background: #D2B3FFA6;">image: (name)</mark> - может быть написан вместо build. Это образ контейнера
					<mark style="background: #D2B3FFA6;">container_name: (name)</mark> - имя контейнера
					<mark style="background: #D2B3FFA6;">restart: unless-stopped</mark> - здесь задается поведение контейнера при падении
					<mark style="background: #D2B3FFA6;">environment:</mark> - тут задаются переменные окружения
						<mark style="background: #D2B3FFA6;">ENV_NAME: "value"</mark>\.
					<mark style="background: #D2B3FFA6;">ports</mark>: - проброска портов наружу из контейра. 
						<mark style="background: #D2B3FFA6;">- "8080:80"</mark>  - по 8080 слушает запросы, по 80 передает внутрь контейнера
					<mark style="background: #D2B3FFA6;">volumes</mark>: 
						<mark style="background: #D2B3FFA6;">- ./project</mark> - подключаем рабочий каталог где лежит код сайта
					<mark style="background: #D2B3FFA6;">networks:</mark> - подсеть задается для общение контейнеров внутри сети
						<mark style="background: #D2B3FFA6;">- default</mark> - все привязанные к этой сети контейнеры смогут общаться между собой
					<mark style="background: #D2B3FFA6;">depends_on: </mark> - устанавливаем последовательность запуска контейнеров
						<mark style="background: #FFB86CA6;">another_container</mark>:
							<mark style="background: #D2B3FFA6;">condition: (condition)</mark> - <mark style="background: #FFB86CA6;">example_container</mark> не запустится, пока <mark style="background: #FFB86CA6;">another_container</mark> не поднимется при заданном условии.
					<mark style="background: #D2B3FFA6;">healthchek</mark>: - проверка состояния контейнера при запуске
						<mark style="background: #D2B3FFA6;">test</mark>: curl -s \h\t\t\p\:\/\/\1\2\7\.\0\.\0\.\1 | grep works
						<mark style="background: #D2B3FFA6;">interval</mark>: 30s
						<mark style="background: #D2B3FFA6;">timeout</mark>: 2s
						<mark style="background: #D2B3FFA6;">retries</mark>: 10
		\.
		<mark style="background: #ABF7F7A6;">Команды Docker-compose</mark>:
			<mark style="background: #FFF3A3A6;">docker-compose up -d</mark> - запуск контейнеров в фоновом режиме (-d)
			<mark style="background: #FFF3A3A6;">docker-compose down</mark> - остановить контейнеры
			<mark style="background: #FFF3A3A6;">docker-compose down --volumes</mark> - остановить контейнеры и удалить данные в volumes
		\.
		Источники:
			https://www.dmosk.ru/miniinstruktions.php?mini=docker-compose-examples
			https://ivan-shamaev.ru/docker-compose-tutorial-container-image-install/
		\.

33 - CI/CD
	CI/CD - continues integration, continues delivery, continues deployment
		CI/CD - это одна из DevOps практик, подразумевающая непрерывную интеграцию и развертывание проекта. <mark style="background: #ADCCFFA6;">Этот набор принципов, предназначенных для повышения удобства, частоты и надежности развертывания изменений</mark> ПО.
		Состоит из следующих шагов (цикл разработки) pipeline:
			- <mark style="background: #FFF3A3A6;">Code</mark> - написание кода + тестировка в ручном режиме, мерж к основной ветке
			- <mark style="background: #FFF3A3A6;">Build</mark> - сборка через систему контроля версий, автоматически через Jenkins или gitlab
			- <mark style="background: #FFF3A3A6;">Test</mark> - после проверки CI системой работоспособности тестовой версии код передается для ручного исследования
			- <mark style="background: #FFF3A3A6;">Release</mark> - после исправлений передается на релиз для клиентов
			- <mark style="background: #FFF3A3A6;">Deploy</mark> - развертка проекта на боевом сервере
			- <mark style="background: #FFF3A3A6;">Operate & monitore</mark> - проект используется клиентами, непрерывная поддержка и анализ работы программы
			- <mark style="background: #FFF3A3A6;">Plan</mark> - планирование нового функционала и доработок в код
		continues integration, continues delivery, continues deployment - 
			дополняют друг друга, у каждого этапа есть своя зона ответственности, т.е.
			CI - Continues integration - 
				написание кода в локальной ветке, после мерж его в основную
				процесс сборки и тестирования запускается автоматически. Для того, чтобы CI имел смысл - тестирование должно быть быстрым, остальное развёртывание выполняется вручную. 
			CD - continues delivery - 
				CI выполняется автоматически,
				автоматизирован выход сборки в релиз
				!выход в продакшн выполняется вручную
			CD - continues deployment - 
				всё предыдущее автоматизированно,
				выход в продакшн также автоматизирован.
			Инструменты CI/CD:
				Jenkins
				Gitlab

34 - HTML & CSS
	Hyper Text Markup Language - язык гипертекстовой рамезтки. Веб-браузеры получают HTML документы от сервера по протоколу HTTP и интерпретируют код в интерфейс.
	\.
	HTML5 - последняя и самая мощная версия стандарта HTML. В HTML5 есть программные интерфейсы (API) для передачи видео и звука, для чатов, в том числе видеочатов через браузер, и многих других интересных интерактивных штук. На HTML5 даже создают браузерные игры. Flash не требуется.
	\.
	Заголовок HTML5 документа:
		<!DOCTYPE html>
	\.
	HTML теги - это имена элементов, заключенные в угловые скобки
	\.
	Атрибут - дополнительные свойства, прописываемые внутри тега, чтобы присвоить элементу (тексту, картинке и т.д.) какую-либо информацию.
	Например атрибуты тега body:
		background = "URL"
		bgcolor = "color"
		text = "color"
	\.
	block & inline теги:
		- Блочные теги определяются целыми блоками, например "div"
			Всегда берется полная ширина
			Могут содержать внутри вложенные блоки
		- Строчные теги определяются в одну строку, например "span"
			Занимают столько места, сколько нужно
			Отображаются рядом друг с другом
			Могут содержать вложенные строчные элементы
	\.
	В CSS display отвечает за расположение объектов:
		- display: inline-block - разместит блочные структуры на одной строке
		- display: block - сделает все блоками
		- diplay: inline - разместит все в строчке 
		- display: None - удалит объект
		- visibiliti: hidden - скроет объект, но он будет существовать
	\.
	Теги верхнего уровня head:
		Является обязательным в веб-странице как и тег body, позволяют организовать структуру страницы.
		\.
		<mark style="background: #FFB86CA6;">Информация внутри head не видна пользователю</mark>.
		\.
		Внутри head можно расположить:
		- tittle - заголовок вкладки 
		- meta - метаинформация для браузера
		- link - позволяет подключать СSS стили извне
		- style - для того, чтобы внутри html документа определять CSS стили
		- noscript - тег для браузеров без поддержки JS. 
		- base - указывает базовую ссылку перенаправления
	\.
	Отличия span от div:
		div блочный, span строчный
		div размечает всегда с новой строки
		span не переносит элементы и пишет их подряд
		div для разметки блоков, span для разметки отрывков текста.
	\.
	Можно ли присваивать значения не всем атрибутам тега?
		Да, в этом случае браузер будет использовать значения по умолчанию. Является bad practice
	\.
	Комментарий в HTML
		< ! - - Это **комментарий**--> < !
	\.
    Можем ли мы группировать различные селекторы с разными именами классов?
		Да, мы можем сгруппировать различные селекторы с разными именами классов и одинаковым определением стиля, используя запятые.
	\.
	Какая связь между SGML, HTML, XML и XHTML?
		SGML (Standard generalized markup language - стандартный обобщённый язык разметки) – это стандарт, который определяет разметку документа.
		\.
		HTML – это язык разметки, который описывается с помощью SGML, необходимый для просмотра веб-страниц.
		\.
		Разбор кода по стандарту SGML был связан с определёнными трудностями, поэтому был создан XML, чтобы облегчить эту процедуру. XML использует SGML.
		\.
		XML - расширяемый язык разметки. Используется для хранения представлений данных и обмена структурированными данными.
		\.
	\.
	Спецификация W3C 
		— список стандартов и требований (называемых «рекомендациями») для Интернета, которые затем внедряются производителями программ и оборудования, что делает Всемирную сеть более совершенной, универсальной и удобной. Среди стандартов утвержденных организацией W3C (World Wide Web Consortium — Консорциум Всемирной паутины)
	\.
	Тег canvas
		Необходим при отрисовке изображений прямо на странице в браузере с помощью языка JS.
		Это контейнер для рисования. В теге canvas указываем тег, по которому дальше будет находиться контейнер
		\.
		Сама отрисовка будет производится в теге script где уже на JS будет написан код, который отвечает за отрисовку.
	\.
	Способы применения стилей:
		1. переопределение стиля в элементе разметки через атрибут style
		2. размещение описания стиля в заголовке документа в элементе STYLE
		3. через ссылку на внешний CSS файл через элемент LINK
		4. импорт описания стиля в документ
	\.

35 - ОС - потоки, процессы
	Процесс — это любое отдельно запущенное приложение.
	Поток — это «канал» исполнения потока процесса.
	\.
	Каждый отдельный процесс способен существовать отдельно друг от друга
	\.
	Главная задача любой операционной системы — контроль потребляемых ресурсов компьютера, а также их ограничение и распределение между всеми процессами, которые на них претендуют.
	\.
	Запущенный процесс не исполняет код приложения, поэтому он не потребляет время процессора. Код программы выполняют потоки, поэтому операционная система выделяет время процессора потокам.
	\.
	Любой поток связан с каким-то процессом, а у любого запущенного процесса может быть несколько потоков.
	\.
	<mark style="background: #ABF7F7A6;">Как работает ОС? </mark>\.
		Основные характеристики процесса:
			- Процесс располагает определнными ресурсами
			- Размещен в некотором виртуальном пространстве
			- Процесс подвержен диспетчерезации. Каждый процесс имеет состояние и приоритет.
		\.
		Основные характеристики потока:
			- Состояние выполнения
			- Доступ к простнатству памяти и ресурсам своего процесса
		\.
		Процесс запускается при запуске программы. Загруженная в память программа делится на 4 части.
			- <mark style="background: #FFF3A3A6;">Stack</mark> - стек процесса содержит временные данные, адрес возврата и локальные переменные
			- <mark style="background: #FFF3A3A6;">Heap</mark> - динамически распределяемая память процесса
			- <mark style="background: #FFF3A3A6;">Text</mark> - хранит состояние регистров, программного счетчика и режим работы процесса.
			- <mark style="background: #FFF3A3A6;">Data</mark> - раздел содержит глобальные и статические переменные
		\.
		Стадии, которые проходит процесс:
			- <mark style="background: #FFF3A3A6;">Start</mark> - создание процесса
			- <mark style="background: #FFF3A3A6;">Ready</mark> - процесс ожидает исполнения на процессоре. В течение работы процессор может переключаться между процессами, переводя одни в режим готовности, другие в режим исполнения.
			- <mark style="background: #FFF3A3A6;">Running</mark> - выполнение инструкций
			- <mark style="background: #FFF3A3A6;">Wait</mark> - процесс переходит в состояние ожидания
			- <mark style="background: #FFF3A3A6;">Terminated</mark> - процесс встает на очередь удаления
		\.
		Процессами управляет Process Control Block (P.C.B.)
		P.C.B. - это структура данных, поддерживаемая ОС для каждого процесса.
		\.
		P.C.B. содержит следующие данные:
			- Process ID - идентификатор процесса
			- State - состояние процесса
			- Privileges - права доступа к ресурсам системы
			- Pointer - указатель на родительский процесс
			- Priority - приоритет процесса
			- Program Counter - какая следующая команда должна быть выполнена
			- CPU registres - регистры процессора, необходимые для исполнения
			- Accounting Information - данные статистики по процессу (загруженность CPU и так далее)
			- I/O - список ресурсов, использующих чтение и запись
		\.
		Источники:
			https://proglib.io/p/how-os-work - топ 1 ресурс о том, как работает ОС
		\.

36 - GIT
	GIT - Распределенная система контроля версий. Распределенная, потому что на каждом локальном компьютере находится полная версия репозитория. Это позволяет работать с локальными репозиториями GIT даже без интернета.
	\.
	Историческая справка:
		Гит был написан на языке C в 2005 году разработчиками ядра Linux как решение для быстрого, удобного, децентрализованного обмена данными между разработчиками
	\.
	GIT — система контроля версий
	GitHub — сервис хостинга удаленных репозиториев
	GitLab — это **сайт и система управления репозиториями кода для Git**.
	\.
	Основная задача GIT — помочь разработчику создавать разные версии проекта локально на компьюьтере и затем с помощью сервисов хостинга репозиториев обмениваться версиями проекта с другими разработчиками.
	\.
	Области GIT в которых могут находиться файлы:
		1 - <mark style="background: #D2B3FFA6;">Рабочая директория</mark> — там, где содержится .git 
		2 - <mark style="background: #BBFABBA6;">Индекс</mark> (Staging Area) — файлы до коммита. (git add .). <mark style="background: #FFF3A3A6;">Это промежуточная область между рабочей дерикторией и репозиторием git.</mark> Находится в папке .git/
		3 - <mark style="background: #ABF7F7A6;">Репозиторий</mark> — запись изменений в репозиторий (то что содержится в .git/objects). 
	\.
	Все объекты git хранятся в папке .git/objects, где каждому git объекту присваивается уникальный хеш. Алгоритм хеш-фукнции - SHA1
	\.
	Статусы отслеживания файлов:
		- <mark style="background: #FF5582A6;">Untracked</mark> — неотслеживаемые. Файлы, добавленные в Рабочую директорию
		- <mark style="background: #BBFABBA6;">Staged</mark> — подготовленные. Файлы, подготовленные для коммита (сохранения изменения) git add
		- <mark style="background: #D2B3FFA6;">Unmodified</mark> — немодифицированные. Файлы, сохраненные в последнем коммите, но не тронутые после. 
		- <mark style="background: #ABF7F7A6;">Modified</mark> — модифицированные. Файлы, существующие файлы, в которые внесли изменения, но еще не подготовили для коммита
	\.
	Объекты в GIT
		<mark style="background: #FFF3A3A6;">Blob</mark> - файл
		<mark style="background: #FFF3A3A6;">Tree</mark> - папка
		<mark style="background: #FFF3A3A6;">Commit</mark> - коммит, точки сохранения версий проекта.
		<mark style="background: #FFF3A3A6;">Annotated tag</mark> - аннотированный тег, метки, предназначенные для обозначения важных коммитов. 
	\.
	Что такое commit?
		<mark style="background: #FFF3A3A6;">Commit</mark> - <mark style="background: #ADCCFFA6;">это указатель на Tree (папку)</mark>
		\.
		Содержит в себе:
		- Метаданные автора коммита, почта и имя
		- Описание коммита
		- Родительские коммиты (SHA1)
		- Дерево (Tree) (SHA1)
	\.
	<mark style="background: #ADCCFFA6;">HEAD </mark><mark style="background: #ADCCFFA6;">- это указатель, ссылающийся на конкретный commit. В Рабочей директории видно ту версию проекта, на которую указывает HEAD </mark> <mark style="background: #FF5582A6;">ВАЖНО! HEAD можно заменить на @</mark>
	\.
	<mark style="background: #ADCCFFA6;">Pull</mark><mark style="background: #ADCCFFA6;"> request - это запрос на внесение изменений</mark> 
	\.
	Ветки в git
		<mark style="background: #ADCCFFA6;">В</mark><mark style="background: #ADCCFFA6;">етка - это организованная система ссылок на коммиты.</mark>
		\.
		Ветка всегда ссылается на самый последний, актуальный коммит
	\.
	Отличия merge и rebase:
		В GIT есть два способа включить изменения из одной ветки в другую:
		1) <mark style="background: #FFF3A3A6;">git merge</mark> <mark style="background: #FFB86CA6;">branch_name</mark> , где <mark style="background: #FFB86CA6;">branch_name</mark> - ветка feature, откуда будет взят коммит, а текущая ветка master - куда будет слит коммит.                                                                                                Git создаёт новый снимок состояния, который является результатом трёх ходового слияния, и автоматически создаёт новый коммит, который указывает на этот новый снимок состояния. Такой коммит называют коммит-слияние, так как он является особенным из-за того, что имеет больше одного предка.
		\.
		2) <mark style="background: #FFF3A3A6;">git rebase</mark> <mark style="background: #FFB86CA6;">branch_name or SHA1</mark> , где <mark style="background: #FFB86CA6;">branch_name or SHA1</mark> - ветка master откуда будет взят последний коммит, затем будет на основе последнего коммита из master перестроена текущая ветка feature                                                                                         <mark style="background: #FFF3A3A6;">git rebase -i</mark> <mark style="background: #FFB86CA6;">main_branch</mark> - позволит выборочно добавить только нужные коммиты к основной истории проекта. Пишем обязательно комментарий к изменению. Следуем внутренним инструкциям. Нажимаем <mark style="background: #FFF3A3A6;">ESC</mark> и для выхода вводим <mark style="background: #FFF3A3A6;">:wq </mark>                                            <mark style="background: #ADCCFFA6;">Главное правило rebase: не перемещать коммиты, отправленные в публичный репозиторий.</mark>                                                                                                                            <mark style="background: #FFF3A3A6;">git rebase -i</mark> - просто открывает редактор на текущем коммите
		   \.
		   Редактор содержит команды:
		   - drop
		   - pick  
		   - reword
		   - squash
		\.
	Варианты отмены изменений: git revert, reset:
		1) <mark style="background: #FFF3A3A6;">git revert</mark> <mark style="background: #FFB86CA6;">SHA1</mark>                                                                                                          Безопасно отменяет коммит, историю проекта не меняет. Создает противоположный коммит, отменяя тем самым изменения. <mark style="background: #ADCCFFA6;">Внутри устроен так же, как и git cherry-pick, только создает не копию коммита, а ему противоположный, удаляя изменения.</mark>
		2) <mark style="background: #FFF3A3A6;">git reset</mark> <mark style="background: #FFB86CA6;">type</mark> <mark style="background: #FFB86CA6;">branch_name or SHA1</mark>, где type может быть:                                                                                           <mark style="background: #CACFD9A6;">--mixed</mark> стандартное удаление последнего коммита, изменения становится Untracked и их нужно заново подготавливать для коммита.                                                                                                                                        <mark style="background: #CACFD9A6;">--soft</mark> HEAD переключается на предыдущий коммит, изменения остаются в индексе Staging Area. Подготавливать для коммита не надо.  Последний коммит как бы отменяется.                                                                                                                                                                                 <mark style="background: #CACFD9A6;">--hard</mark> удаляет все коммиты и изменения до такого коммита, который указали в  <mark style="background: #FFB86CA6;">branch_name or SHA1</mark>                                                                                                                                                                                                                                   Различия: ![[Pasted image 20230107172117.png]] 
	\.
	git cherry-pick - подводные камни:
		Описание проблемы: Нередко возникает ситуация, когда срочно требуется выполнить небольшую задачу. Разработчик быстро пробегается глазами по ТЗ и старается максимально оперативно вникнуть в суть задачи. При этом можно попросту забыть создать новую ветку, и понять об ошибке уже после финального коммита.
		\.
		<mark style="background: #FFF3A3A6;">git cherry-pick</mark> <mark style="background: #FFB86CA6;">SHA1_0</mark> ,где <mark style="background: #FFB86CA6;">SHA1_0</mark> - хеш коммита, который мы хотим добавить к той ветке, на которой сейчас находимся.
	\.
	git pull против git fetch:
		- git pull - загружает данные с удаленного репозитория и сливает их с текущей локальной веткой
		- git fetch - только получает данные, но не сливает их
	\.
	Что такое SSH ключ:
		SSH-ключи используются для облегчённой авторизации на различных сервисах.
		Состоит из 2-ух частей: 
		- id_rsa - приватный ключ
		- id_rsa.pub - публичный ключ
	\.
	gitflow - ветвление в гит: Trunk Based Development
		 Весь GitHub Flow основан на ветвлении. Единое правило: всё, что находится в master-ветке — гарантированно стабильно и готово к деплою в любой момент. Поэтому чрезвычайно важно, чтобы любая ваша новая ветвь создавалась именно от mastera.
	\.
	Конфликты в git:
		- Конфликт слияния: в ветке master файл удален, в ветке feature этот файл редактируется
		- Конфликт веток: две разные ветки вносят изменения в одну и ту же строку в одном файле
	\.
	Какие команды объединяет git init?
		#доделать
	\.
	Команды git:
	<mark style="background: #FFF3A3A6;">git rm</mark> <mark style="background: #FFB86CA6;">.env</mark> <mark style="background: #FFF3A3A6;">--cached</mark> - удалить .env из отслеживания (полезно когда добавил в коммит .env)
	<mark style="background: #FFF3A3A6;">git config --list</mark> - посмотреть все настройки гита.
	<mark style="background: #FFF3A3A6;">git status</mark> - посмотреть состояние индекса, показывает текущее состояние git репозитория
	<mark style="background: #FFF3A3A6;">git add</mark> - подготовка файлов к коммиту (перенос в Индекс)
	<mark style="background: #FFF3A3A6;">git commit -m</mark> - создание коммита, сохраняет добавленные изменения (перенос в Репозиторий из Staging area)
	<mark style="background: #FFF3A3A6;">git log</mark> - просмотр истории изменений
	<mark style="background: #FFF3A3A6;">git checkout</mark> <mark style="background: #FFB86CA6;">commit</mark> перенос указателя HEAD к определенной версии (перенос из Репозитория в Рабочую директорию)
	<mark style="background: #FFF3A3A6;">git show</mark> <mark style="background: #FFB86CA6;">SHA1</mark> - показывает файлы, которые были изменены в конкретном коммите
	<mark style="background: #FFF3A3A6;">git checkout -b</mark> <mark style="background: #FFB86CA6;">branch_name</mark> - создать ветку и переключиться на нее
	<mark style="background: #FF5582A6;">git branch -d</mark> <mark style="background: #FFB86CA6;">branch_name</mark> - безопасное удаление ветки. Git не даст удалить ветку, если есть неслитые изменения. Нельзя удалить ветку, на которой находишься.
	<mark style="background: #FF5582A6;">git branch -d origin</mark> <mark style="background: #FFB86CA6;">branch_name</mark> - удалить ветку с удаленного репозитория
	<mark style="background: #FFF3A3A6;">git branch -m</mark> <mark style="background: #FFB86CA6;">branch_name</mark> - переименовать <mark style="background: #CACFD9A6;">текущую</mark> ветку на branch
	<mark style="background: #FFF3A3A6;">git branch -a</mark> - показать все удаленные ветки
	<mark style="background: #FFF3A3A6;">git branch</mark> - посмотреть все ветки
	<mark style="background: #FFF3A3A6;">git clone</mark> - клонирование репозитория
	<mark style="background: #FFF3A3A6;">git push</mark> - отправка коммита на удаленный репозиторий
	<mark style="background: #FFF3A3A6;">git pull</mark> - выполняет выборку, а затем слияние или повторную базу для интеграции фиксаций в текущую локальную ветвь
	<mark style="background: #FFF3A3A6;">git merge</mark> <mark style="background: #FFB86CA6;">branch_name</mark>- объединяет ветки
	<mark style="background: #FFF3A3A6;">git commit --amend</mark> - добавить изменения в уже созданный, последний коммит
	\.
	<mark style="background: #FF5582A6;">git reset HEAD~</mark> - удалить последний коммит, изменения не удалять 
	<mark style="background: #FF5582A6;">git reset --hard HEAD~1</mark> - удалить полностью. HEAD~[N] где N число коммитов от верхнего
	(ВАЖНО! Если коммит уже запушен, то лучше так не делать. Лучше git revert)
	\.
	<mark style="background: #FFF3A3A6;">git rebase</mark> <mark style="background: #FFB86CA6;">branch_name or SHA1</mark> - перемещение ветки с одного коммита на другой
	<mark style="background: #FFF3A3A6;">git checkout</mark> - выбор ветки
	<mark style="background: #FFF3A3A6;">git cherry-pick</mark> <mark style="background: #FFB86CA6;">SHA1</mark> — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой.
	<mark style="background: #FFF3A3A6;">git stash</mark> - предназначена для того, чтобы поместить текущие изменения, которые вы выполнили в файлах, в отдельное хранилище, и вернуть файлы к исходному состоянию
	<mark style="background: #FFF3A3A6;">git stash</mark> <mark style="background: #FFB86CA6;">pop</mark> - вытащить данные из временного хранилища
	ветки в Git представляют собой указатель на снимок изменений.
	<mark style="background: #FFF3A3A6;">git pull --rebase</mark> - загрузить последние изменения с определнной ветки
	<mark style="background: #FFF3A3A6;">git bisect start</mark> - поиск проблемных коммитов. Затем вводим bad, good и смотрим результат.
	<mark style="background: #FFF3A3A6;">git tag -a</mark> <mark style="background: #CACFD9A6;">ver-2.5</mark> <mark style="background: #FFF3A3A6;">-m</mark> <mark style="background: #CACFD9A6;">"beta version 2.5"</mark> - создать тег к текущему коммиту
	Коммиты - это снимки состояния, контрольные точки на временной шкале проекта **Git**
	\.
	Хуки - аналоги тригеров в БД. Срабатывают по какому-то условию. Самое простое: мы выполняем git push, а сервер на своей стороне принимает эти данные по тригеру.
	\.

37 - Bash-скрипты
	Bash-скрипт - это сценарий для командной строки, набор команд в оболочке bash
	\.
	В оболочку bash попадаем когда авторизуемся на сервере (в ОС линкус).
	\.
	Bash-скрипты удобно писать в текстовом редакторе vim.
	\.
	bash-переменные:
		variable=value - создать переменную (без пробелов)
		\.
		$variable или ${variable} - чтение переменной
		\.
		\#`комментарий` - в bash комментарий - решетка
		\.
		$0 - выдать имя скрипта
		$# - выдать количество переданных аргументов
	\.
	<mark style="background: #ABF7F7A6;">Linux commands</mark>:
		- <mark style="background: #FFF3A3A6;">grep</mark> - утилита командной строки Linux, которая дает пользователям возможность вести поиск строки. Это некий фильтр.
		  Для примера возьмем команду `ls` которая выводит содержимое директории
		  \.
		  Однако если нам нужно вывести на экран конкретную папку из директории, то:
		  `$ ls | grep Documents` 
		  \.
		  На экран выведет `Documents`
		  \.
		  Поиск строк работает аналогично:
		  `$ ls | grep 'Искомая строчка'`
		  \.
		- <mark style="background: #FFF3A3A6;">awk</mark> - скриптовый язык для поиска текста в файлах.
		  Пример использования:
		  `awk '{action} file_name.txt'`
		  \.
		  Принт всего содержимого файла с нумерацией строк:
		  `awk '{print NR,$0}' information.txt`
		  \.
		- <mark style="background: #FFF3A3A6;">touch</mark> - создание файла в директории
		  `touch file_name.txt`
		  \.
		- <mark style="background: #FFF3A3A6;">sed</mark> - редактор текста. Используется для поиска и изменения текста в файле не открывая его.
		  Основные опции:
		  -n, --quiet - не выводить содержимое буфера в конце каждой итерации
		  -i - сделать резервную копию перед редактированием
		  -l - указать длину строки
		  -s - если передано несколько файлов разбить редактирование по потокам, а не в одном длинном потоке.
		  -e - команды, которые надо выполнить для редактирования 
		  \.
		  Команды редактирования:
		  q - завершить работу сценария
		  d - удалить буфер шаблона и перейти к следующей итерации
		  p - вывести содержимое буфера шаблона
		  w - записать содержимое буфера в файл
		  \.
		  `$ sed (опция) -e (команды) file_name.txt`
		  \.
		- <mark style="background: #FFF3A3A6;">lsof</mark> - выводит список открытых файлов. Можно использовать дял того, чтобы посмотреть какое сетевое подключение использует процесс.
		  \.
		  `lsof -i` - покажет все интернет соединения
		  `lsof -iTCP` - покажет все TCP соединения
		  `lsof -i | grep -i LISTEN` - показать все прослушиваемые портыэ
		  `kill -9 lsof -t -u daniel` - убить все процессы пользователя daniel
		  `lsof -u daniel` - показать всю информацию о пользователе daniel
		  \.
		- <mark style="background: #FFF3A3A6;">curl</mark> - инструмент для передачи данных с сервера на сервер при помощи различных протоколов.
		  `curl www.nigga.com` - спарсит данные как при обычном GET
		  \.
# Computer science & network
38 - OSI | HTTPs
	<mark style="background: #ABF7F7A6;">OSI - сетевая модель</mark>:
		\. ![[Pasted image 20230215112247.png]]
		\.
		<mark style="background: #FFF3A3A6;">Физический уровень L1</mark>\.
			Обмен физическими сигналами на уровне железа. Железо общается единицами и нулями, то есть битами.
			Передача происходит через Wi-Fi, Ethernet и так далее
			\.
		<mark style="background: #FFF3A3A6;">Канальный уровень L2</mark>\.
			Канальный уровень получает биты и преобразует их в фреймы с адресом отправителя и получателя, после чего отправляет их по сети. 
			\.
			У канального уровня есть два инструмента для организации отправки данных.
			MAC-адрессация и LLC.MAC-контроль логической связи. 
			MAC-адрес физический номер сетевой карты, физический адрес устройства.
			LLC.MAC - управляет доступом к передаваемым данным
			\.
		<mark style="background: #FFF3A3A6;">Сетевой уровень L3</mark>\.
			Маршрутизация. Роутеры. 
			Маршрутизаторы получают MAC-адрес от коммутаторов с канального уровня и строят маршрут от одного устройства к другому.
			\.
		<mark style="background: #FFF3A3A6;">Транспортный уровень L4</mark>\.
			Если уровни L1-L3 занимаются передачей информации по кабелю или wi-fi, то уровни L4-L7 используются непосредственно на хосте, то есть непосредственно на компьютерах или телефонах. 
			\.
			Транспортный уровень занимается передачей пакетов данных. Очевидно, что при транспортировки возможны потери пакетов. Различают два основных протокола передачи пакетов данных:
			TCP - Transport Control Protocol - <mark style="background: #ADCCFFA6;">надежный протокол для чувствительных данных. Всегда в конце передачи данных проверяет целостность.</mark> Работает по верх IP.
			TCP гарантирует полную доставку данных в таком же порядке.
			TCP обеспеивает сквозную связь, работает в режиме Client/Server
			\.
			UDP - User Datagram Protocol  - для мультимедийных файлов, таких как видео, потери не так страшны, но важна скорость. <mark style="background: #ADCCFFA6;">Для чувствительных к задержкам данных используется UDP.</mark> Смысл в том, что пакет бьется на датаграммы. Датаграммы самостоятельны и имеют все заголовки, чтобы дойти до адресата. Они не зависят от сети и могут приходить в разном порядке.
			\.
		<mark style="background: #FFF3A3A6;">Сессионный уровень L5</mark>\.
			Последние три уровня это уровни данных.
			\.
			Отвечает за поддержку сессии связи. Управляет взаимодействием между приложениями, завершает сеанс обмена информацией. 
			\.
			Пример: видеозвонок по сети. Во время званка необходимо, чтобы аудио и видео потоки шли синхронно. За эту синхронность отвечает сессионный уровень.
			\.
		<mark style="background: #FFF3A3A6;">Репрезентация данных L6</mark>\.
			Отвечает за декодирование/кодирование данных. Предоставляет JPEG, GIF, MP3 и так далее.
			\.
		<mark style="background: #FFF3A3A6;">Прикладной API L7</mark>\.
			То, с чем взаимодействуют юзвери. Графический интерфейс. Задача уровня показать данные, полученные со всех предудщих уровней так, чтобы это понял юзверь.
	\.
	<mark style="background: #ABF7F7A6;">HTTP & HTTPS</mark>:
		Разница в том, что S означает шифрование соединение по сертификату TSL 1.3 (раньше был SSL)
		\.
		Порты:
		- для HTTP - 80
		- для HTTPS - 443
	\.	
	<mark style="background: #ABF7F7A6;">HTTP методы</mark>:
		Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера
		\.
		Идемпотентность - это такое понятие, которое означает, что при многократном обращении на ресурс результат возврата не изменится и никак не поменяет работу сервера.
		\.
		<mark style="background: #FFF3A3A6;">GET</mark>:
			POST-параметры: нет
			Идемпотентность: да
			Предназначение: получение информации о ресурсе 
		<mark style="background: #FFF3A3A6;">POST</mark>:
			 POST-параметры: да
			 Идемпотентность: нет
			 Предназначение: создание нового ресурса
		<mark style="background: #FFF3A3A6;">PUT</mark>:
			POST-параметры: да
			Идемпотентность: да
			Предназначение: полное обновление ресурса
		<mark style="background: #FFF3A3A6;">PATCH</mark>:
			POST-параметры: да
			Идемпотентность: да
			Предназначение: редактирование ресурса
		<mark style="background: #FFF3A3A6;">DELETE</mark>:
			POST-параметры: нет
			Идемпотентность: да
			Предназначение: удаляет ресурс
		<mark style="background: #FFF3A3A6;">HEAD</mark>:
			POST-параметры: нет
			Идемпотентность: да
			Предназначение: не получает body, а только отправляет и получает HTTP заголовки. Служит для проверки существования ресурса. Такой же GET, только без тела ответа. Отвечает просто заголовком, отсюда и название HEAD
		<mark style="background: #FFF3A3A6;">OPTIONS</mark>:
			POST-параметры: нет
			Идемпотентность: да
			Предназначение: возвращает доступные методы для ресурса и никак сам ресурс не трогает. 
		\. 
		<mark style="background: #ABF7F7A6;">HEADERS - Заголовки</mark>: 
			Передают и в запросе, и в ответе.
			\.
			<mark style="background: #FFF3A3A6;">Заголовки запроса</mark>:
				Host - домен, по которому мы переходим
				Cookie - файлы куки, отдаваемые браузером серверу
				User-Agent - браузер, которым делаем запрос
				Accept-Language & Accept-Encoding - какую кодировку хотим получить от сервера
				Referer - предыдущая страница
				Authorization - реквизиты для базовой авториации (логин + пароль)
			<mark style="background: #FFF3A3A6;">Заголовки ответа</mark>:
				Cache-control - сервер говорит браузеру как кэшировать данные
				Content-type - тип содержимого, кодировка
				Content-Disposition - говорит браузеру скачивать или открывать документ как веб страницу
				Location - заголовок для редиректа (на какую страницу перекинуть дальше)
				Set-Cookie - сервер передает браузеру куки
				WWW-Authenticate - сервер выдаст окно с базовой аутентификацией
				Content-Encoding - сервер говорит, какая кодировка страницы
				Server & X-Powered-by - технологии, на которых работает сайт
		\.
39 - websocket
	<mark style="background: #ABF7F7A6;">Модуль socket</mark> \.
		Библиотека для создания серверных и клиентских сокетов.
		\.
		<mark style="background: #FFF3A3A6;">Сокет</mark> - <mark style="background: #ADCCFFA6;">конечная точка соединения</mark>.
		\.
		Может работать совместно с asyncio.
		\.
		Web-socket ссылки начинаются с `ws` --> "ws://localhost:8765"
		\.
		<mark style="background: #FFF3A3A6;">Web-socket</mark> - <mark style="background: #ADCCFFA6;">протокол связи поверх TCP, предназначенный для обмена данными между сервером и клиентом</mark><mark style="background: #FFB86CA6;"> в реальном времени</mark>.
		\.
		Проверка состояния реального времени проверяется через ping-pong (hand shake)
		\.
		Зачем нужен Web-socket?
			Так как HTTP протокол не может возвращать данные в реальном времени, при большом количестве клиентов подключенных к серверу обмен информацией будет очень медленным, поскольку чтобы получить данные каждый клиент должен отправить запрос на сервер и дождаться ответа. 
			\.
			Web-socket\`ы решают эту проблему и позволяют серверу обмениваться с клиентами данными моментально и эффективно, <mark style="background: #FFB86CA6;">так как между клиентом и сервером устанавливается постоянное двунаправленное соединение TCP</mark>
		\.
		<mark style="background: #BBFABBA6;">Преимущества Web-socket</mark>:
			- Высокая производительность из-за низких расходов мощности
			- Асинхронная передача данных для Web 
	\.
	<mark style="background: #ABF7F7A6;">Работа с socket</mark>:
		imposrt socket 
		\.
		2 способа создать сервер:
			- Ручной:
			  server = socket<mark style="background: #FFF3A3A6;">.socket(socket.AF_INET, socket.SOCK_STREAM)</mark>
			  server<mark style="background: #FFF3A3A6;">.bind(('127.0.0.1', 2000))</mark>
			  \.
			- Автоматический:
			  server = socket<mark style="background: #FFF3A3A6;">.create_server(('127.0.0.1', 2000))</mark>
		 \.
		Слушать порт на предмет запросов:
			<mark style="background: #FFF3A3A6;">server.listen(N)</mark>, 
			Где N количество входящих запросов, которые будут приняти операционной системой и которые будут поставлены в режим ожидания.
		\.
		Принятие запросов сервером:
			client_socket, adress = <mark style="background: #FFF3A3A6;">server.accept()</mark>
			Сервер будет ждать, пока придет запрос
			\.
			request_data = <mark style="background: #FFF3A3A6;">client_socket.recv(N)</mark>.decode('utf-8'), где N - размер пакета данных в байтах
			Полученние данных запроса
		\.
		Web-socket + asyncio:
			server:
				async def hello(websocket):
					name = await websocket.recv()
					print(f"<<< {name}")
					greeting = f"Hellom {name}"
					await websocket.send(greeting)
					print(f">>> {greeting}")
				\.
				async def main():
					async with <mark style="background: #FFF3A3A6;">websockets.serve(hello, "localhost", 8765):</mark> %%подключение функции hello к каждому сокету%%
						await asyncio.Future() %%вечный запуск%%
				\.
				if \_\_name\_\_ == "\_\_main\_\_":
					asyncio.run(main())
				\.
			client:
				async def hello():
					uri = "ws://localhost:8765"
					async with websockets<mark style="background: #FFF3A3A6;">.connect(uri)</mark> as websocket: %%асинхронный контекстный менеджер соединения для того, чтобы его потом закрыть%%
						name = input("Как вас зовут?")
						await websocket.send(name)
						print(f">>>{name}")
						greeting = await websocket.recv()
						print(f"<<<{greeting}")
					\.
					if \_\_name\_\_ == "\_\_main\_\_":
						asyncio.run(main())
	\.
40 - web api  REST | SOAP
	<mark style="background: #ABF7F7A6;">API in general</mark>:
		API - Application Program Interface - предоставляет интерфейс, по которому будут общаться между собой например backend & frontend или backend & backend.
	\.
	<mark style="background: #ABF7F7A6;">REST API</mark>:
		**Representational State Transfer** — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. 
			\.
			Принципы REST
				1.  ==Клиент-серверная архитектура== -  заключается в разделении зон ответственности: в разделении функций клиента и сервера.
				2.  ==Stateless== - Сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки. информация в хедерах передается
				3.  ==Кэширование== - Каждый ответ сервера должен иметь пометку, можно ли его кэшировать.
				4.  ==Единообразие интерфейса== - одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.
				5.  ==Layered system== - Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.
				6. ==Code on demand== - Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту. 
	\.
	<mark style="background: #ABF7F7A6;">RPC API </mark>:
		Remote Procedure Call - удаленный вызов функций подразумевает вызов исполнения кода как будто локально, но на удаленном сервере, получая результат выполнения. Протокол запрос-ответ.
		\.
		Правила RPC:
		- Эндпоинты содержат имя выполняемой операции
		- GET метод только для чтения, а все остальные методы заменяет POST
		- в URL указан метод запроса 
		- в URL указаны аргументы для функции на удаленном сервере в определенном формате
	\.
	<mark style="background: #ABF7F7A6;">gRPC API</mark>:
		Созданный гуглом альтернативный стиль.
		\.
		Отличия от RPC:
		- Собственный формат обмена данными вместо JSON & XML: Protobuf
		  <mark style="background: #FFF3A3A6;">Protobuf</mark> - <mark style="background: #ADCCFFA6;">быстрый формат, который в загловоках содержит минимум необходимой информации</mark>
		- Построен на протоколе HTTP 2 вместо HTTP 1.1
		- Высокая скорость передачи данных, в 7-10 раз быстрее RPC, но медленнее REST API.
	\.
	<mark style="background: #ABF7F7A6;">SOAP</mark>:
		Формат обмена данными. 
		Если REST это JSON поверх HTTP, то SOAP это XML поверх SOAP через HTTP.
		\.
		SOAP - простой протокол доступа к объектам (Simple Object Access Protocol)
		\.
		Подразумевает использование XML формата при обмене данными, вместо JSON.
		XML менее удобный и более тяжеловесный формат.
		\.
		Но есть и плюсы по сравнению с REST стилем у SOAP протокола:
			- Очень безопасный за счет XML
			- Асинхронная обработка запросов
			- Сохраняет состояния от одного запроса к другому
		\.
# Django
37 - Django Rest Framework | ASGI | WSGI
	Web framework - это скелет сайта, соединяющий различные модули, дающие инструменты для обработки http протоколов, например ORM
	\.
	<mark style="background: #ABF7F7A6;">Паттерн MVC (MTV в Django)</mark>:
		<mark style="background: #FFF3A3A6;">Model</mark> - содержит явные бизнес правила: регистрация пользователей, сохранение паролей. Доступ к данным.
		<mark style="background: #FFF3A3A6;">View</mark> (Template) - графическое отображение данных
		<mark style="background: #FFF3A3A6;">Controller</mark> - контроллер должен содержать минимум логики, максимум различные проверки, он связующуее звено между графическим интерфейсом и моделью. 
		\.
		В Django (особенно в REST) <mark style="background: #FFB86CA6;">нет выделенного слоя controller</mark>. Роль контроллера берет фреймворк сам по себе: 
		- <mark style="background: #ADCCFFA6;">механизм отправки реквеста по маршруту из urls.py во views.py и есть контроллер</mark>.
		Пруфы:
			https://docs.djangoproject.com/en/3.1/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names
			Where does the “controller” fit in, then? In Django’s case, it’s probably the framework itself.
		\.
		Про каждый Django слой отдельно:
		- <mark style="background: #FFF3A3A6;">front-end/templates</mark> - отображение данных, графическая репрезентация
		- <mark style="background: #FFF3A3A6;">serializers/forms</mark> - валидация данных, конвертация request в Python код.
		  serializer\`ы также дополнительно обладают методами create & update
		- <mark style="background: #FFF3A3A6;">views</mark> - отвечает за обработку пользовательских данных и их представление
		- <mark style="background: #FFF3A3A6;">models</mark> - размещение бизнес логики и правил
	\.
	<mark style="background: #ABF7F7A6;">Жизненный цикл resuest -> response</mark>:
		1. От клиента запрос поступает на web-server (NGINX)
		2. Запрос (Request) обрабатывает WSGI и передает в django
		3. Request обрабатывается Middleware: проверяются токен, сессии и тд. 
		4. Срабатывает URL (urls.py), он указывает на контроллер (view)
		5. Контроллер (view) обращается к модели
		6. Формируется ответ базы данных 
		7. Сформированный ответ от БД возвращается в контроллер (view)
		8. Результат отправляется в template (графическое отображение)
		9. Готовый html документ отдается в класс Response и формируется ответ. Добавляются заголовки, различная служебная информация
		10. Response отдается в WSGI
		11. Web-server возвращает Response клиенту, страница отображается.
		\.
		<mark style="background: #ABF7F7A6;">Архитектура DRF</mark>:
		1 - От клиента поступает некий API запрос (https://ozon.ru/products - это API запрос)
		2 - Маршрутизатор обрабатывает запрос (ссылку)
		3 - Маршрутизатор передает запрос тому представлению, с которым связан этот запрос. Представления (вьюха или класс) создаются средствами DRF. Задача представлений: обработка запроса и передача результата пользователю
		4 - Так как для обработки требуется сформировать данные в формате JSON, XML, то для этого управление передается в сериалайзеры. Сериалайзеры формируют данные для ответа на API запрос. А также выполняют парсинг входной информации. 
		5 - База данных, в которой могут происходят какие-то изменения или наоборот можно получить что-то
	\.
	<mark style="background: #ABF7F7A6;">WSGI</mark> & <mark style="background: #ABF7F7A6;">ASGI</mark>:
		Web-server - это ПО, установленное на ОС, которая установлена на устройство, куда это ПО будет передавать пакеты данных по определенному порту. 
		\.
		Пример web-server: NGINX, Apache
		\.
		WSGI - протокол, связывающий web-server (NGINX) с Python кодом.
		ASGI тоже самое, только асинхронно выполняется.
		\.
		gunicorn - одна из реализаций WSGI для linux и unix, не работает в windows
		\.
		uvicorn - реализация ASGI-сервера, использующая uvloop и httptools.
	\.
	<mark style="background: #ABF7F7A6;">Django Middleware</mark>:
		Промежуточный слой между Resuest & Response. Низкоуровневая система плагинов для изменения входных или выходных данных
		\.
		Для каждого request middleware запускаются заново
		\.
		Например, **Django** включает компонент промежуточного ПО, AuthenticationMiddleware, который связывает пользователей с запросами с помощью сессий.
		\.
		Кастомный middleware:
			class TestMiddleware():
				def \_\_init\_\_(self, <mark style="background: #FFF3A3A6;">get_response</mark>: callable): <-- необходимо передать функцию get_response
					pass
				def \_\_call\_\_(self, request, \*args, \*\*kwargs):
					%% before response %%
					self.<mark style="background: #FFF3A3A6;">get_response()</mark> <-- вызов view (представления)
					%% after response %%
	\.
	<mark style="background: #ABF7F7A6;">Миграции</mark>:
		Миграции - это способ, которым Django распространяет изменения, которые вы вносите в модели в схеме БД.
		\.
		Автоматическая генерация миграции:
			- py manage.py makemigrations
			- py manage.py migrate
		\.
		Файл миграций:
			<mark style="background: #D2B3FFA6;">dependencies</mark> - список миграций, от которых зависит текущая миграция
			<mark style="background: #FFB8EBA6;">operations</mark> - список классов типа Operation, которые определяют, что делает миграция
			\.
			Все данные по миграции содержатся в классе <mark style="background: #FFF3A3A6;">Migration( migrations.Migration )</mark>
			\.
			Начальная миграция
				Это миграция, которая не зависит от других, такие миграции, которые создают первую версию таблиц приложения.
				\.
				initial = True - атрибут, означающий начальную миграци.
			\.
			Отмена миграции:
				Для отмены миграции нужно вызвать команду migrate и указать имя и номер предыдущей миграции:
				<mark style="background: #FFF3A3A6;">python manage.py migrate books 0002</mark> \.
				\.
				Чтобы отменить все миграции нужно написать:
				<mark style="background: #FFF3A3A6;">python manage.py migrate books zero</mark> \.
			\.
			<mark style="background: #ADCCFFA6;">Миграции можно использовать не только для изменения схем в БД, но и для изменения самих данных</mark>. Правда такое возможно только в ручном режиме.	
			\.
			Для этого есть migrations.RunPython
			\.
			Создать пустую миграцию:
				<mark style="background: #FFF3A3A6;">py manage.py makemigrations --empty (name)</mark> \.
			\.
			Объединение миграций:
				<mark style="background: #FFF3A3A6;">py manage.py squashmigrations app_name 0004</mark> \.
			\.
	\.
	manage.py:
		- это программный файл, помогающий работать с проектом. запустить сервер, создать суперпользователя, сделать миграцию после создания моделей.
	\.
	Сериалайзер:
		- Выполняет конвертацию объектов языка Python в формат JSON & XML и наоборот. Также можно задавать различные сценарии поведения в сериалайзере. 
	     \.
		  _Хорошая практика: выносить все методы в сериалайзер. Однако может быть и плохой практикой, ломая бизнес логику._
		  \.
		Методы сериалазйера:
		- create(self, validated_data)
		- update(self, instance, validated_data)
		\.
		ModelSerializer:
			- упрощенный сериализатор по готовой модели
	\.
	Какие операции поддерживает DRF?
		- CRUD
		- проверку корректности передаваемых данных от клиента и защиту от хакерских атак
		- авторизация и регистрация пользователей
		- разделение прав доступа к данным через API (permissions)
		- сериализация
	\.
	APIView
		- предоставляет базовый функционал для работы различных классов представлений в рамках ДРФ, от которого наследуется, например, generics.ListAPIView
	\.
	Response
		- возвращает клиенту JSON строку
	\.
	В settings.py:
		REST_RAMEWORK = { 
		- Можем настраивать BrowsableAPIRender, включить сайт-панель DRF или отключить
		- Можем настроить пермишены например AllowAny или IsAuthenticated
		}
	\.
	ViewSets:
		- ModelViewSet:
			- Используется для объединения стандартных вьюх (create, update, retrieve, destroy) для написание в **urls.py ModelViewSet.as_view( {'put':'update'} )** в один некий сет.
		- ReadOnlyModelViewSet:
			- Используется только для чтения записей. Так как содержит миксины выделить запись (RetrieveModelMixin), выдать список (ListModelMixin)
	\.
	Router:
		Сущность необходимая для объединения всех возможных вызовов стандартных вьюх в ModelViewSet в один объект (переменная router = routers.SimpleRouter( )) в urls.py. 
		Отличия между SImple и Default router:
			Default Router хранит в себе список всех роутеров по методам на основе которых пишутся Simple Router\`ы
	\.
	Permissions:
		AllowAny - полный доступ
		IsAuthenticated - только для авторизованных пользователей
		IsAdminUser - только для админа
		IsAuthenticatedOrReadOnly - для авторизованных пользователей или всем, но только чтение
		Можно написать свой кастомный пермишен наследуясь от BasePermission
	\.
	<mark style="background: #ABF7F7A6;">Авторизация, аутентификация, идентификация</mark>:
		\.
		Три этапа:
		\.
		<mark style="background: #FFF3A3A6;">Идентификация</mark> - процесс определения личности по определенному ID
		\.
		<mark style="background: #FFF3A3A6;">Аутентификация</mark> - процесс подтверждения личности, например через JWT токен
		\.
		<mark style="background: #FFF3A3A6;">Авторизация</mark> - процесс принятия решения определения прав аутентифицированной личности.
		\.
		Session-based auth - аутентификация на основе сессий и куки
		Token-based auth - аутентификация на основе токенов, django токен
		JSON Web Token (JWT) - аутентификация на основе JWT
		Django REST framework OAuth - авторизация через соц сети
	\.
	<mark style="background: #ABF7F7A6;">JWT токен</mark>:
		JSON Web Token - это стандарт, определяющий способ передачи данных о пользователе в формате JSON в зашифрованном виде.
		\.
		Токен состоит из трех частей:
			1. Header - JSON объект содержащий данные о типе токена и алгоритме шифрования
			   {"alg":"HS256", "type":"JWT"} 
			2. Payload - объект JSON, который содержит данные для авторизации
			3. Signature - фингерпринт, подпись к токену. Служит для верификации валидности токена.
		\.
		JWT использует два токена:
			- Access token: многоразовый, короткоживущий. Нужен для получения доступа к системе.
			- Refresh token: одноразовый, долгоживущий. Нужен для обновления Access Token.
	\.
	Источники
		https://django.fun/ru/docs/django-rest-framework/3.12/api-guide/generic-views/
	\.
	DRF:
		– это инструмент для создания API сайта с целью удаленного взаимодействия с ним.
	API:
		– **Application Programming Interface**, что значит программный интерфейс приложения. В контексте API слово «приложение» относится к любому ПО с определенной функцией. Интерфейс можно рассматривать как сервисный контракт между двумя приложениями. Этот контракт определяет, как они взаимодействуют друг с другом, используя запросы и ответы.
	\.
	С различных устройств, например с телефона, с приложения, написанного на JAVA отправляется GET запрос на сервер с целью предоставить, например, список категорий товаров (https://ozon.ru/products - это API запрос). Сервер по этому API запросу формирует данные и возвращает ответ клиенту как правило в JSON или XML. Затем эти данные обрабатываются в JAVA приложении на телефоне и как-то дальше отображаются.
	\.
38 - Django ORM
	Object Realtion Mapping - позволяет с помощью языка Python работать с любыми БД одинаково.
	\.
	Примеры ORM:
		- Django ORM
		- SQL Alchemy
	\.
	Плюсы ORM по сравнению с чистым SQL:
		- на основе языка Python формируется SQL запрос. Это выглядит более читаемым
		- ускорение написание проекта
		- Вне зависимости от БД (Postgre, Oracle, SQLite) ORM сработает одинаково
	\.
	<mark style="background: #ABF7F7A6;">Django ORM фишки</mark>:
		- Просмотр последнего обращения к БД
		   `from django.db import connection`
		   `connection.queries`
		   \.
		- <mark style="background: #FFF3A3A6;">related_name</mark> - отвечает за название вторичной модели джанго для обращения к связанным записям. 
		  \*джанго всегда создает вторичные модели по формуле <mark style="background: #CACFD9A6;">(model_name)_set</mark>
		  \.
		- фильтры полей (lookup) - позволяет устанавливать некоторую фильтрацию, например
		  SomeModel.objects.filter(<mark style="background: #FFF3A3A6;">pk__gt=2</mark>) - означает "больше или равно".
		  \.
		  Примеры других lookups:
		  (attr_name)\_\_<mark style="background: #FFF3A3A6;">lte</mark> - меньше или равно
		  (attr_name)\_\_<mark style="background: #FFF3A3A6;">exact</mark>=14 - найдет какой-то атрибут равный точно 14
		  (attr_name)\_\_<mark style="background: #FFF3A3A6;">contains</mark>="Nigger" - найдет в атрибуте содержание Nigger с учетом регистра
		  \.
		  под капотом будет это: SELECT SomeModel WHERE attr_name LIKE %Nigger%
		  \.
		- <mark style="background: #FFF3A3A6;">.first()</mark> & <mark style="background: #FFF3A3A6;">.last()</mark> - применив данную конструкцию к query запросу мы получим первую запись или последнюю запись:
		  `SomeModel.objects.order_by('pk').first()` --> получим запись с pk=1
		 \.
		- <mark style="background: #FFF3A3A6;">.latest()</mark> - применим для полей типа datetime. Выводит самую свежую запись:
		  `SomeModel.objects.latest('time_create')` 
		  \.
		  или <mark style="background: #FFF3A3A6;">.earliset()</mark> - сработает наоборот.
		 \.
		- <mark style="background: #FFF3A3A6;">get_previous_by</mark> & <mark style="background: #FFF3A3A6;">get_next_by</mark> - специальная конструкция, позволяющая брать предыдущую запись если поле связано с типом datetime.
		  Формат: <mark style="background: #CACFD9A6;">(object).get_previous_by_(field_name)()</mark>
		  Пример:
		  `m = SomeModel.objects.get(pk=1)`
		  `m.get_previous_by_time_create()`
		  \.
		- <mark style="background: #FFF3A3A6;">exists()</mark> & <mark style="background: #FFF3A3A6;">count()</mark> - нужны для простых проверок. На существование и на количество.
		  exist() - возращает True или False
		  Пример: 
		  `m = SomeCategory.objects.get(pk__gt=1)`
		  `m.SomeModel_set.exists()` - существуют ли связанные записи? 
		  \.
		  count() - посчитает количество записей
		  Пример:
		  `m.SomeModel_set.count()` --> вернет число
		  \.
		- <mark style="background: #FFF3A3A6;">обращение к полям таблицы</mark>.
		  Используя такой синтаксис `table__fieldName` мы можем легко обращаться к определенным полям таблиц модели. 
		  Пример:
		  `SomeModel.objects.filter(slaves__name='Черные')` - получить имена всех черных рабов из таблицы slaves
	\.
	<mark style="background: #ABF7F7A6;">Класс Q</mark>:
		Нужен для того, чтобы делать не только классические джанговские "И", но и "ИЛИ", "НЕ".
		\.
		Классическое джанговское "И" выглядит так:
		`SomeModel.objects.filter(id__in=[1, 2, 3], is_nigger=True)` - это пример логического "И"
		\.
		В классе Q логические операторы выглядят так:
			& - "И"
			| - "ИЛИ"
			~ - "НЕ"
		\.
		Пример "ИЛИ":
		`SomeModel.objects.filter(Q(id__in=[1, 2, 3]) | Q(is_nigger=True))`
		\.
	\.
	<mark style="background: #ABF7F7A6;">Lazy evaluation</mark>:
		query запрос происходит тогда, когда происходит непосредственное обращение к записям в БД. В момент определения queryset - нет.
		\.
		Запрос на чтение в Django не исполняется сразу же. 
		В Django ORM строчка <mark style="background: #FFB86CA6;">Post.objects.all( ) не шлёт никакие запросы в БД.</mark>
		\.
		Однако запросы на CREATE или DELETE запускаются сразу.
	\.
	queryset это -
		<mark style="background: #ADCCFFA6;">набор запросов, который должен использоваться для возврата объектов из view</mark>.
		\.
		<mark style="background: #FFF3A3A6;">get_queryset()</mark>:
			Метод, который необходимо переопределить
		\.
		ORM методы оптимизации запрoсов:
			from django.db import connection, reset_queries
			\.
			В [Django](https://django.fun/docs/django/ru/stable/) `select_related` и `prefetch_related` предназначены для остановки потока запросов к базе данных, вызванных доступом к связанным объектам.
			\.
			- **select_related** - помогает заранее указать, какие связанные модели нужны, чтобы Django мог выполнить JOIN при работе с каким-то одним объектом отношения OneToOne, ForeignKey. `select_related` работает путем создания соединения SQL и включения полей связанного объекта в `SELECT`. По этой причине `select_related` получает связанные объекты в том же запросе к базе данных. Под капотом это JOINы.
			- **prefetch_related** - Это означает обработку `ManyToMany` и обратных `ManyToMany`, `ForeignKey`. `prefetch_related` выполняет отдельный поиск для каждой связи и выполняет «объединение» в Python. Он отличается от `select_related`. `prefetch_related` выполнял `JOIN` с использованием Python, а не в базе данных.
			- values() - для выбора определнных полей
	\.
	<mark style="background: #ABF7F7A6;">Проблема N+1 операции</mark>:
		это выполнение лишних SQL запросов.  Повторением запросов внутри конструирования ORM запросов к базе данных. Возникает, если не оптимизировать запросы. Допустим для получения всех объектов нужно 3 запроса, однако создастся всего 4, так как будут повторяться одни и те же действия
	\.
	Источники:
		https://habr.com/ru/post/503526/ орм джанго
		https://dvmn.org/encyclopedia/django_orm/lazy-querysets/ - ленивые запросы к БД
	\.
# Machine Learning
41 - NumPy
	 <mark style="background: #ABF7F7A6;">NumPy</mark>:
		 NumPy написан на C и FortRun за счет чего он очень быстрый.
		 \.
		 Работает с объектами <mark style="background: #FFF3A3A6;">ndarray</mark>, которые используются для представления N-мерного массива.
		 \.
		 Array (<mark style="background: #FFF3A3A6;">ndarray</mark>):
			 \.
			 <mark style="background: #FFF3A3A6;">ndarray</mark> - это контейнер (массив) для хранения больших наборов данных. 
			 \.
			 Отличия <mark style="background: #FFF3A3A6;">ndarray</mark> от list:
				 - ndarray расходует меньше памяти, чем список
				 - ndarray обладает большим функционалом
				 - ndarray требует однородность данных, так как является массивом
			\.
			Атрибуты массивов:
				- <mark style="background: #FFF3A3A6;">shape</mark> - это кортеж, который описывает размер по каждому измерению.
				- <mark style="background: #FFF3A3A6;">dtype</mark> - тип данных массива
				- <mark style="background: #FFF3A3A6;">ndim</mark> - количество измерений (одномерный, двумерный и тд)
				- <mark style="background: #FFF3A3A6;">tolist()</mark> - конвертирует Array в List
			\.
			Массивы больше трехмерного (четырехмерный, пятимерный и тд) называют <mark style="background: #ADCCFFA6;">Тензорами</mark>.
			\.
			Создание массива из списка:
				import numpy as np
				data = \[1, 2, 3, 4 , 5\]
				array = <mark style="background: #FFF3A3A6;">np.array(data)</mark> <-- cоздание массива
				\.
				print(array.dtype) --> int64
			\.
			Агрегирующие функции:
				- array<mark style="background: #FFF3A3A6;">.max()</mark> - вернет самое большое число из массива
				- array<mark style="background: #FFF3A3A6;">.min()</mark> - вернет минимальное число
				- array<mark style="background: #FFF3A3A6;">.mean()</mark> - среднее арифметическое
				- array<mark style="background: #FFF3A3A6;">.sum()</mark> - сумма чисел массива
				- array<mark style="background: #FFF3A3A6;">.std()</mark> - стандартное отклонение.  Показатель, представляющий величину, в которой  значения статистического ряда имеют тенденцию колебаться от его среднего или медианы.
				- np<mark style="background: #FFF3A3A6;">.median(array)</mark> - вернет медиану массива. Такое число, что половина элементов из набора меньше его, а половина больше
			\.
42 - Pandas
	Библиотека для анализа данных. Извлечение, объединение данных, срезы данных и тд.
	Позволяет обрабатывать данные в виде таблицы. Pandas загружает данные в оперативную память.
	\.
	Работает с двумя основными структурами данных:
		<mark style="background: #FFB86CA6;">Series</mark> - таблица из одной колонки (одномерный список)
		<mark style="background: #FFB86CA6;">Dataframe</mark> - таблица из нескольких колонок (вложенный список)
	\.
	<mark style="background: #BBFABBA6;">Преимущества Pandas</mark>:
		- может получать данные из разных источников: exel, csv, txt, веб-страницы, json
		- быстро работает с большими данными (Big Data)
		- может объединять данные из различных источников в единый массив
		- может конвертировать и читать различные типы данных
		- решает задачи: аггрегация данных, группировка данных, сортировка данных, условия, фильтры и так далее.
	\.
	<mark style="background: #ABF7F7A6;">Методы</mark>:
		- <mark style="background: #FFF3A3A6;">pd.read_(format)('путь к файлу')</mark> - чтение какого-то формата
		- <mark style="background: #FFF3A3A6;">df.head & pd.tail</mark> - получение начальных или последних данных датафрейма df
		- <mark style="background: #FFF3A3A6;">df.(Имя колонки)</mark> или <mark style="background: #FFF3A3A6;">df['Имя колонки']</mark> - вернет серию
		- <mark style="background: #FFF3A3A6;">df[['Колонка_1', 'Колонка_2', 'Колонка_3']]</mark> - получить данные по нескольким сериям
		- <mark style="background: #FFF3A3A6;">df.shape</mark> - вернет кортеж с размерностью датафрейма (строки, колонки)
		\.
		- <mark style="background: #FFF3A3A6;">df.rename</mark>({
			  'Старое название столбца': 'Новое название',
			  'Старое название столбца': 'Новое название' - позволяет переименовать столбцы
		  }, <mark style="background: #BBFABBA6;">inplace=True</mark>) - позволяет переопределить датафрейм df с новыми названиями
		\.
		- <mark style="background: #FFF3A3A6;">df.read_html('URL')</mark> - установив заранее lxml позволяет спарсить табличные данные с веб-страницы
		- <mark style="background: #FFF3A3A6;">df.to_(format)('путь к файлу')</mark> - сохраняет датафрейм в файл в определенном формате в указанный путь
		- <mark style="background: #FFF3A3A6;">df.info()</mark> - показывает статистику по датафрейму, типы данных в сериях и тд.
		- <mark style="background: #FFF3A3A6;">df.['Order_date'] = pd.to_datetime(df.Order_date, format="%M-%Y-%D")</mark> - если Order_date - это строка, то pd.to_datetime() сделает из неё тип даты и время по определенному формату.
		- <mark style="background: #FFF3A3A6;">df.</mark><mark style="background: #FFB86CA6;">groupby('Day_name').</mark><mark style="background: #FFF3A3A6;">sum()['Total']</mark> - groupby() позволяет объединить данные по какому-то столбцу и к ним уже применить аггрегирующие функции, например sum()
		- <mark style="background: #FFF3A3A6;">df.to_sql(</mark><mark style="background: #FFB86CA6;">table_name._meta.db_table</mark><mark style="background: #FFF3A3A6;">, con=engine)</mark> - перевод данных в sql базу данных. con - это engine подключения к базе, например из SQLAlchemy
		  Пример engine = create_engine("postgres://localhost/data_api")
	\.
	Добавить новую серию в датафрейм:
		<mark style="background: #FFF3A3A6;">df['Сумма']</mark> = <mark style="background: #FFF3A3A6;">df['Кол-во']</mark> \* <mark style="background: #FFF3A3A6;">df['Цена']</mark>
		Сумма - новый с толбец который создаем умножая два уже существующих
	\.
	<mark style="background: #ABF7F7A6;">Фильтрация данных</mark>:
		- <mark style="background: #FFF3A3A6;">df[ df.Total > 1000 ]</mark> - пример фильтрации по числовому столбцу Total где больше 1000.
		- <mark style="background: #FFF3A3A6;">df[ df.Product.str.contains('LG') ]</mark> - поиск по строковому столбцу, где названия содержат 'LG'. 
		  Пандас предоставляет целый набор различных методов со строками str. 
		- <mark style="background: #FFF3A3A6;">df.loc[ df['Total'] == 70 ]</mark> - .loc() позволяет получать группы строк и столбцов по соответствующему условию.
		- <mark style="background: #CACFD9A6;">options = ['Total', 'Summary', 'Unless']</mark>
		  <mark style="background: #FFF3A3A6;">df.[ df['Total'].isin(options) ]</mark> - .isin() возвращает те строки датафрейма, значение которых присутствует в переданном списке (options)
		  \.
	    Комбинирование фильтров:
		    Логическое "НЕ" - ~
		    Логическое "И" - &
		    Логическое "ИЛИ" - |
	\.
	<mark style="background: #ABF7F7A6;">Объединение датафреймов</mark>:
		concat:
			df1 = pd.DataFrame[. . .]
			df2 = pd.DataFrame[. . .]
			\.
			frames = [df1, df2]
			result = <mark style="background: #FFF3A3A6;">pd.concat(frames)</mark> - объединение датафреймов
			\.
			Если нужно добавить данные по какому-то формату, то:
			<mark style="background: #FFF3A3A6;">pd.concat([df1, df2], </mark><mark style="background: #D2B3FFA6;">axis=1, join='inner')</mark> 
			- join = 'inner' - пересечение данных
			- join = 'outer' - <mark style="background: #CACFD9A6;">по умолчанию</mark>. Нулевая потеря информации
		\.
		append:
			result = <mark style="background: #FFF3A3A6;">df1.append([df2, df3, ...])</mark> - добавление одного датафрейма в другой
		\.
43 - Machine Learning
	<mark style="background: #ABF7F7A6;">Обзор библиотек</mark>:
		Pandas - для анализа данных, формирования датасетов
		Scarpy - для парсинга данных с веб страниц
		NumPy - для математических вычислений
		SciPy - аналог numpy. Нужен для научных расчетов
		PySpark - аналог pandas, но для более больших данных и распределенной обработки
		xlwt - библиотека для формирования exel файлов
		xlrd - библиотека для извлечения данных из файлов электронной таблицы exel
		Keras - библиотека для создания нейросетей
		TensorFlow - библиотека для машинного обучения нейросетей
	\.
	Отличие традиционной разработки от машинного обучения:
		- В традиционной разработке алгоритм и входные данные известны заранее. Функция пишется для получения нужного значения
		- В машинном обучении известны входные и выходные значения, но неизвестен алгоритм.
	\.
	Подход с машинным обучением основывается на использовании нейронных сетей для нахождения отношений между входными и выходными значениями.
	\.








